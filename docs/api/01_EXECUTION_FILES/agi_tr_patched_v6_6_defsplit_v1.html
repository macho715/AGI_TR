<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1 API documentation</title>
<meta name="description" content="AGI TR RORO Integrated Calculation System …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1</code></h1>
</header>
<section id="section-intro">
<p>AGI TR RORO Integrated Calculation System</p>
<p>Version: 6.8.0-PATCH1111-ENFORCEMENT
Last Updated: 2025-12-16</p>
<h2 id="features">Features</h2>
<ul>
<li>B1-Enhanced: Hydro-based base_tmean_m calculation (SSOT enforcement, no fallback)</li>
<li>B2: Trim_gate auto + ΔTM direction correction (COMPLETE)</li>
<li>C-Enhanced: Iterative ballast correction + Operational columns</li>
<li>CONST_TANKS CSV integration (Option B-2)</li>
</ul>
<p>VALIDATION STATUS:
✅ B1-Enhanced: RuntimeError if Hydro table missing (SSOT enforcement)
✅ B2: Trim_gate auto-calculation + correct ΔTM direction
✅ C-Enhanced: Operational columns (Ballast_alloc, Pump_time_h, Lineup_OK)
✅ CSV auto-loading 8/8 tanks (100% match rate)
✅ Stage 5_PreBallast: FWD ≤ 2.70m
✅ All regulatory constraints satisfied</p>
<p>PATCH1111 COMPLIANCE:
✅ B1: Fallback 2.00m removed (2 locations)
✅ B2: Already complete (Trim_gate + ΔTM)
✅ C: Operational columns added to iterative_ballast_correction()</p>
<p>REGULATORY BASIS:
- Max FWD Draft: 2.70m (AGI Site operational limit)
- Min GM: 1.50m (IMO stability requirement)
- Max Ramp Angle: 6° (SPMT climbing limit)
- Trim Envelope: ±2.40m (240cm)</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.apply_dynamic_loads"><code class="name flex">
<span>def <span class="ident">apply_dynamic_loads</span></span>(<span>share_load_t: float,<br>pin_stress_mpa: float,<br>load_case: 01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_dynamic_loads(
    share_load_t: float,
    pin_stress_mpa: float,
    load_case: LoadCase,
) -&gt; tuple[float, float]:
    &#34;&#34;&#34;
    LoadCase에 따라 동적·제동 하중 계수 적용.

    Returns
    -------
    (share_dyn_t, pin_dyn_mpa)
    &#34;&#34;&#34;
    if load_case == LoadCase.STATIC:
        f_vert = 1.00
        f_pin = 1.00
    elif load_case == LoadCase.DYNAMIC:
        f_vert = 1.10  # 예: 동적계수 1.10
        f_pin = 1.10
    elif load_case == LoadCase.BRAKING:
        f_vert = 1.20  # 예: 동적+제동 영향
        f_pin = 1.30
    else:
        f_vert = 1.00
        f_pin = 1.00

    return share_load_t * f_vert, pin_stress_mpa * f_pin</code></pre>
</details>
<div class="desc"><p>LoadCase에 따라 동적·제동 하중 계수 적용.</p>
<h2 id="returns">Returns</h2>
<p>(share_dyn_t, pin_dyn_mpa)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_ballast_scenarios_from_stage_results"><code class="name flex">
<span>def <span class="ident">build_ballast_scenarios_from_stage_results</span></span>(<span>stage_results: Dict[str, Dict[str, float]],<br>scenario_stage_map: Dict[str, list],<br>pump_rate_tph: float = 100.0,<br>fwd_limit_m: float = 2.7,<br>linkspan_min_freeboard_m: float = 0.28) ‑> Dict[str, Dict[str, float]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_ballast_scenarios_from_stage_results(
    stage_results: Dict[str, Dict[str, float]],
    scenario_stage_map: Dict[str, list],
    pump_rate_tph: float = 100.0,
    fwd_limit_m: float = 2.70,
    linkspan_min_freeboard_m: float = 0.28,
) -&gt; Dict[str, Dict[str, float]]:
    &#34;&#34;&#34;
    Stage_results + 시나리오별 Stage 묶음을 이용해
    옵션 1/2/3 summary dict 자동 생성.

    scenario_stage_map 예:
    {
        &#34;Option 1 – Pre-ballast Only&#34;: [&#34;Stage 5_PreBallast&#34;],
        &#34;Option 2 – D-Day Dynamic&#34;: [&#34;Stage 6A_Critical&#34;],
        &#34;Option 3 – Split Stage&#34;: [&#34;Stage 6A_Critical&#34;, &#34;Stage 6C&#34;],
    }
    &#34;&#34;&#34;
    scenarios: Dict[str, Dict[str, float]] = {}

    for scenario_name, stage_list in scenario_stage_map.items():
        total_ballast = 0.0
        total_time_h = 0.0
        has_time = False

        min_fwd_margin = None
        min_link_margin = None

        for st in stage_list:
            res = stage_results.get(st)
            if not res:
                continue

            ballast_t = float(res.get(&#34;Ballast_t&#34;, 0.0) or 0.0)
            total_ballast += ballast_t

            if res.get(&#34;Ballast_time_h&#34;) is not None:
                try:
                    total_time_h += float(res.get(&#34;Ballast_time_h&#34;) or 0.0)
                    has_time = True
                except (TypeError, ValueError):
                    pass

            dfwd = float(res.get(&#34;Dfwd_m&#34;, fwd_limit_m) or fwd_limit_m)
            fwd_margin = fwd_limit_m - dfwd

            fwd_height = float(res.get(&#34;FWD_Height_m&#34;, 0.0) or 0.0)
            link_margin = fwd_height - linkspan_min_freeboard_m

            if min_fwd_margin is None or fwd_margin &lt; min_fwd_margin:
                min_fwd_margin = fwd_margin
            if min_link_margin is None or link_margin &lt; min_link_margin:
                min_link_margin = link_margin

        # 펌프시간: Stage별 time합 없으면 ballast/pump_rate로 계산
        if not has_time and pump_rate_tph &gt; 0.0:
            total_time_h = total_ballast / pump_rate_tph

        scenarios[scenario_name] = {
            &#34;total_ballast_t&#34;: total_ballast,
            &#34;total_time_h&#34;: total_time_h,
            &#34;fwd_draft_margin_m&#34;: float(min_fwd_margin or 0.0),
            &#34;linkspan_freeboard_margin_m&#34;: float(min_link_margin or 0.0),
        }

    return scenarios</code></pre>
</details>
<div class="desc"><p>Stage_results + 시나리오별 Stage 묶음을 이용해
옵션 1/2/3 summary dict 자동 생성.</p>
<p>scenario_stage_map 예:
{
"Option 1 – Pre-ballast Only": ["Stage 5_PreBallast"],
"Option 2 – D-Day Dynamic": ["Stage 6A_Critical"],
"Option 3 – Split Stage": ["Stage 6A_Critical", "Stage 6C"],
}</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_csm_trace"><code class="name flex">
<span>def <span class="ident">build_csm_trace</span></span>(<span>stage_results: dict) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_csm_trace(stage_results: dict) -&gt; dict:
    &#34;&#34;&#34;
    Build a CSM traceability payload (what securing inputs were used / missing).
    This does NOT compute lashing forces unless input data is provided.
    &#34;&#34;&#34;
    data = _load_securing_input()
    if not data:
        return {
            &#34;available&#34;: False,
            &#34;missing&#34;: &#34;Securing_Input.json&#34;,
            &#34;basis&#34;: &#34;missing&#34;,
            &#34;items&#34;: [],
        }

    items = []
    # Accept either &#34;items&#34; list or &#34;lashings&#34; list
    raw = (
        data.get(&#34;items&#34;)
        if isinstance(data.get(&#34;items&#34;), list)
        else data.get(&#34;lashings&#34;)
    )
    if not isinstance(raw, list):
        raw = []
    for r in raw:
        if not isinstance(r, dict):
            continue
        items.append(
            {
                &#34;id&#34;: r.get(&#34;id&#34;, &#34;&#34;),
                &#34;type&#34;: r.get(&#34;type&#34;, r.get(&#34;lashing_type&#34;, &#34;&#34;)),
                &#34;wll_t&#34;: _as_float(r.get(&#34;wll_t&#34;, r.get(&#34;WLL_t&#34;))),
                &#34;qty&#34;: _as_float(r.get(&#34;qty&#34;, r.get(&#34;quantity&#34;))),
                &#34;remarks&#34;: r.get(&#34;remarks&#34;, &#34;&#34;),
            }
        )

    return {&#34;available&#34;: True, &#34;basis&#34;: data.get(&#34;_basis&#34;, &#34;&#34;), &#34;items&#34;: items}</code></pre>
</details>
<div class="desc"><p>Build a CSM traceability payload (what securing inputs were used / missing).
This does NOT compute lashing forces unless input data is provided.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_opt_c_stage"><code class="name flex">
<span>def <span class="ident">build_opt_c_stage</span></span>(<span>preballast_opt: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_opt_c_stage(preballast_opt: float):
    &#34;&#34;&#34;
    Stage 6A_Critical (Opt C) - Ballast Integrated (DAS Method v4.3 Final Optimized)
    - TR1: final deck position (Fr ≈ 42.0)
    - TR2: ramp tip position (Fr ≈ -5.0)
    - 화물 중량: 280t (TR 217t + SPMT/Acc 63t)
    - Pre-Ballast: 최적화된 값 (preballast_opt) at aft fresh water ballast tanks (FW2, Fr 0-6, Mid_Fr=3.0)
      - FW2: Fr 0-6, Mid_Fr=3.0 → x = fr_to_x(3.0) ≈ +27.15m (AFT 쪽)
    - Total: Cargo 560t + Ballast (preballast_opt)
    - Combined LCG: 재계산 (Even Keel에 근접)
    - target_trim_cm 은 Even Keel 목표로 설정

    Args:
        preballast_opt: 최적화된 Pre-ballast 중량 (ton) - find_preballast_opt() 결과값
    &#34;&#34;&#34;
    # 1. 화물 (Cargo)
    fr_tr1 = 42.0  # TR1 final stowage frame
    fr_tr2 = 17.95  # TR2 Stage 6A_Critical LCG Frame (x=12.20m → Fr=30.151-12.20≈17.95)
    w_tr = 280.0  # TR 217t + SPMT/Acc 63t = 280t
    tr1_weight = w_tr
    tr1_pos_x = fr_to_x(fr_tr1)  # ≈ 11.85 m
    tr2_weight = w_tr
    tr2_pos_x = fr_to_x(fr_tr2)  # ≈ -35.15 m

    # 2. 밸러스트 (Pre-Ballast for Opt C - DAS Method v4.3 Final)
    # DAS Method: 최적화된 Pre-ballast 중량 사용
    # 위치: aft fresh water ballast tanks (FW2, Fr 0-6, Mid_Fr=3.0) - 가장 AFT 쪽
    # FW2: Fr 0-6, Mid_Fr=3.0 → x = fr_to_x(3.0) ≈ +27.15m (AFT 쪽)
    # 무게: 최적화된 값 (preballast_opt)
    w_bal = preballast_opt
    # Aft ballast tank center (FW2, Fr 0-6, Mid_Fr=3.0) - 757 TCP Tank Plan 기준
    ballast_fr_center = 3.0  # FW2 Mid_Fr=3.0 (가장 AFT 쪽)
    ballast_pos_x = fr_to_x(ballast_fr_center)

    # 3. Total Combined (Cargo + Ballast)
    total_weight_opt_c = tr1_weight + tr2_weight + w_bal

    # 모멘트 합산 / 총중량 = 새로운 LCG
    # (Cargo Moment + Ballast Moment) / Total Weight
    moment_cargo = (tr1_weight * tr1_pos_x) + (tr2_weight * tr2_pos_x)
    moment_ballast = w_bal * ballast_pos_x
    combined_lcg_opt_c = (moment_cargo + moment_ballast) / total_weight_opt_c

    return {
        &#34;name&#34;: &#34;Stage 6A_Critical (Opt C)&#34;,
        &#34;weight_t&#34;: total_weight_opt_c,
        &#34;x_from_mid_m&#34;: combined_lcg_opt_c,  # 재계산된 LCG (Ballast 포함)
        &#34;target_trim_cm&#34;: 0.0,  # Even Keel 목표
    }</code></pre>
</details>
<div class="desc"><p>Stage 6A_Critical (Opt C) - Ballast Integrated (DAS Method v4.3 Final Optimized)
- TR1: final deck position (Fr ≈ 42.0)
- TR2: ramp tip position (Fr ≈ -5.0)
- 화물 중량: 280t (TR 217t + SPMT/Acc 63t)
- Pre-Ballast: 최적화된 값 (preballast_opt) at aft fresh water ballast tanks (FW2, Fr 0-6, Mid_Fr=3.0)
- FW2: Fr 0-6, Mid_Fr=3.0 → x = fr_to_x(3.0) ≈ +27.15m (AFT 쪽)
- Total: Cargo 560t + Ballast (preballast_opt)
- Combined LCG: 재계산 (Even Keel에 근접)
- target_trim_cm 은 Even Keel 목표로 설정</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>preballast_opt</code></strong></dt>
<dd>최적화된 Pre-ballast 중량 (ton) - find_preballast_opt() 결과값</dd>
</dl></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_stage5_loads"><code class="name flex">
<span>def <span class="ident">build_stage5_loads</span></span>(<span>preballast_t: float, params: dict) ‑> List[01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_stage5_loads(preballast_t: float, params: dict) -&gt; List[LoadItem]:
    &#34;&#34;&#34;
    Stage 5_PreBallast 구성 (TR1 + TR2 partial + PreBallast)

    Args:
        preballast_t: Pre-ballast 중량 (ton)
        params: 파라미터 딕셔너리
            - W_TR: Transformer + SPMT 중량 (ton)
            - FR_TR1_STOW / FR_TR1: TR1 Frame 번호
            - FR_TR2_RAMP / FR_TR2: TR2 ramp Frame 번호
            - FR_PREBALLAST / FR_PB: PreBallast Frame 번호
            - STAGE5_PROGRESS_PCT: Stage 5 진행률 (%), 기본 71.4

    Returns:
        LoadItem 리스트
    &#34;&#34;&#34;
    W_TR = params.get(&#34;W_TR&#34;, 280.0)
    FR_TR1 = params.get(&#34;FR_TR1_STOW&#34;, params.get(&#34;FR_TR1&#34;, 42.0))
    FR_TR2 = params.get(&#34;FR_TR2_RAMP&#34;, params.get(&#34;FR_TR2&#34;, 17.95))
    FR_PB = params.get(&#34;FR_PREBALLAST&#34;, params.get(&#34;FR_PB&#34;, 3.0))
    stage5_progress_pct = params.get(&#34;STAGE5_PROGRESS_PCT&#34;, 71.4)

    tr2_frac = (stage5_progress_pct - 50.0) / 50.0
    tr2_frac = max(0.0, min(1.0, tr2_frac))
    w_tr2 = W_TR * tr2_frac

    x_tr1 = fr_to_x(FR_TR1)
    x_tr2 = fr_to_x(FR_TR2)
    x_pb = fr_to_x(FR_PB)

    loads = [LoadItem(&#34;TR1+SPMT&#34;, W_TR, x_tr1, &#34;CARGO&#34;)]
    if w_tr2 &gt; 1.0:
        loads.append(LoadItem(&#34;TR2+SPMT&#34;, w_tr2, x_tr2, &#34;CARGO&#34;))
    loads.append(LoadItem(&#34;PreBallast&#34;, preballast_t, x_pb, &#34;BALLAST&#34;))
    return loads</code></pre>
</details>
<div class="desc"><p>Stage 5_PreBallast 구성 (TR1 + TR2 partial + PreBallast)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>preballast_t</code></strong></dt>
<dd>Pre-ballast 중량 (ton)</dd>
<dt><strong><code>params</code></strong></dt>
<dd>파라미터 딕셔너리
- W_TR: Transformer + SPMT 중량 (ton)
- FR_TR1_STOW / FR_TR1: TR1 Frame 번호
- FR_TR2_RAMP / FR_TR2: TR2 ramp Frame 번호
- FR_PREBALLAST / FR_PB: PreBallast Frame 번호
- STAGE5_PROGRESS_PCT: Stage 5 진행률 (%), 기본 71.4</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>LoadItem 리스트</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_stage6a_loads"><code class="name flex">
<span>def <span class="ident">build_stage6a_loads</span></span>(<span>preballast_t: float, params: dict) ‑> List[01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_stage6a_loads(preballast_t: float, params: dict) -&gt; List[LoadItem]:
    &#34;&#34;&#34;
    Stage 6A 구성 (TR1 + TR2 + 동일 PreBallast)

    Args:
        preballast_t: Pre-ballast 중량 (ton)
        params: 파라미터 딕셔너리
            - W_TR: Transformer + SPMT 중량 (ton)
            - FR_TR1: TR1 Frame 번호
            - FR_TR2: TR2 Frame 번호
            - FR_PB: PreBallast Frame 번호 (FWB1/2 중심)

    Returns:
        LoadItem 리스트
    &#34;&#34;&#34;
    W_TR = params.get(&#34;W_TR&#34;, 280.0)
    FR_TR1 = params.get(&#34;FR_TR1&#34;, 42.0)
    FR_TR2 = params.get(&#34;FR_TR2&#34;, 17.95)  # Stage 6A_Critical LCG Frame
    FR_PB = params.get(&#34;FR_PB&#34;, 3.0)  # FW2 중심 Frame (AFT 쪽, Fr 0-6, Mid_Fr=3.0)

    x_tr1 = fr_to_x(FR_TR1)
    x_tr2 = fr_to_x(FR_TR2)
    x_pb = fr_to_x(FR_PB)

    return [
        LoadItem(&#34;TR1+SPMT&#34;, W_TR, x_tr1, &#34;CARGO&#34;),
        LoadItem(&#34;TR2+SPMT&#34;, W_TR, x_tr2, &#34;CARGO&#34;),
        LoadItem(&#34;PreBallast&#34;, preballast_t, x_pb, &#34;BALLAST&#34;),
    ]</code></pre>
</details>
<div class="desc"><p>Stage 6A 구성 (TR1 + TR2 + 동일 PreBallast)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>preballast_t</code></strong></dt>
<dd>Pre-ballast 중량 (ton)</dd>
<dt><strong><code>params</code></strong></dt>
<dd>파라미터 딕셔너리
- W_TR: Transformer + SPMT 중량 (ton)
- FR_TR1: TR1 Frame 번호
- FR_TR2: TR2 Frame 번호
- FR_PB: PreBallast Frame 번호 (FWB1/2 중심)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>LoadItem 리스트</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_stage_loads"><code class="name flex">
<span>def <span class="ident">build_stage_loads</span></span>(<span>stage_name: str, preballast_t: float, params: dict) ‑> List[01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_stage_loads(
    stage_name: str, preballast_t: float, params: dict
) -&gt; List[LoadItem]:
    &#34;&#34;&#34;Stage별 LoadItem 리스트 (모든 Stage 지원).

    이 함수는 각 Stage별로 변동 하중(TR1, TR2, Pre-ballast)을 구성합니다.
    고정 하중(Fuel, FreshWater)은 CONST_TANKS 시트에서 참조되며,
    solve_stage() 함수에서 별도로 처리됩니다.

    Stage 정의 (9개):
      1. Stage 1: Arrival (경하중, 빈 리스트 반환)
      2. Stage 2: TR1 Ramp Start (TR1+SPMT ramp 시작 위치)
      3. Stage 3: TR1 Mid-Ramp (TR1+SPMT ramp 중간 위치)
      4. Stage 4: TR1 On Deck (TR1+SPMT 갑판 도착)
      5. Stage 5: TR1 Final Position (TR1+SPMT 최종 stow 위치)
      6. Stage 5_PreBallast: Water Supply Complete (D-1 Night, TR1 stow + TR2 partial ramp + Stern ballast)
      7. Stage 6A_Critical (Opt C): TR2 Ramp Entry (D-Day, TR1 stow + TR2 ramp + Pre-ballast)
      8. Stage 6C: Final Stowage (TR1 + TR2 모두 stow + Pre-ballast)
      9. Stage 7: Departure (Cargo off, 빈 리스트 반환)

    Args:
        stage_name: Stage 이름
            - 지원 형식: &#34;Stage 1&#34;, &#34;Stage 2&#34;, ..., &#34;Stage 7&#34;
            - &#34;Stage 5_PreBallast&#34;, &#34;Stage 6A_Critical (Opt C)&#34;, &#34;Stage 6C&#34;
        preballast_t: Pre-ballast 중량 (ton)
            - find_preballast_opt() 결과값 사용
            - Stage 5_PreBallast, 6A, 6C에서만 사용
        params: 파라미터 딕셔너리
            - W_TR: Transformer + SPMT 중량 (ton), 기본값 280.0
            - FR_TR1_STOW: TR1 최종 stow Frame 번호, 기본값 42.0
            - FR_TR1_RAMP_MID: TR1 ramp 중간 Frame 번호, 기본값 37.00
            - FR_TR1_RAMP_START: TR1 ramp 시작 Frame 번호, 기본값 40.15
            - FR_TR2_RAMP: TR2 ramp Frame 번호, 기본값 17.95
            - FR_TR2_STOW: TR2 최종 stow Frame 번호, 기본값 40.00
            - FR_PREBALLAST: PreBallast Frame 번호 (FW2 중심, AFT 쪽, Fr 0-6, Mid_Fr=3.0)

    Returns:
        List[LoadItem]: Stage별 변동 하중 리스트
            - LoadItem 구조: (name, weight_t, x_from_mid_m, fsm_t_m)
            - x_from_mid_m: LCG (m from midship, AFT=+, FWD=-)
            - fsm_t_m: FSM (t·m), 변동 하중은 일반적으로 0.0

    하중 구성 요소:
      - TR1+SPMT: 560t (위치 변동, Fr.42 → Fr.17.95)
      - TR2+SPMT: 560t (Stage 6A부터)
      - Pre-ballast: find_preballast_opt() 결과 (Stage 5_PreBallast, 6A, 6C)
      - Fuel/FreshWater: CONST_TANKS 시트 참조 (이 함수에서는 처리하지 않음)

    가정:
      - Stage 2/3/4: TR1+SPMT만 ramp→deck 이동
      - Stage 5: TR1 최종 stow. (추가 하중 없음)
      - Stage 5_PreBallast: TR1 stow + TR2 partial ramp + Pre-ballast
      - Stage 6A: TR1 stow + TR2 ramp 진입 + Pre-ballast
      - Stage 6C: 두 TR 모두 stow + Pre-ballast
      - Stage 7: Cargo off (추가 하중 없음)

    See Also:
        - DATA_SOURCE_DOCUMENTATION.md Section 4.3
        - find_preballast_opt() for pre-ballast optimization
        - solve_stage() for stage calculation with loads
        - CONST_TANKS 시트 for fixed loads (Fuel/FreshWater)
    &#34;&#34;&#34;
    W_TR = params.get(&#34;W_TR&#34;, 280.0)
    fr_tr1_pos = params.get(&#34;FR_TR1_STOW&#34;, params.get(&#34;FR_TR1&#34;, 42.0))
    fr_tr1_ramp_mid = params.get(&#34;FR_TR1_RAMP_MID&#34;, 37.00)
    fr_tr1_ramp_start = params.get(&#34;FR_TR1_RAMP_START&#34;, 40.15)
    fr_tr2_ramp = params.get(&#34;FR_TR2_RAMP&#34;, params.get(&#34;FR_TR2&#34;, 17.95))
    fr_tr2_stow = params.get(&#34;FR_TR2_STOW&#34;, 40.00)
    fr_pb = params.get(
        &#34;FR_PREBALLAST&#34;, params.get(&#34;FR_PB&#34;, 3.0)
    )  # FW2 (AFT 쪽, Fr 0-6, Mid_Fr=3.0)

    loads: List[LoadItem] = []

    if stage_name == &#34;Stage 1&#34;:
        return loads

    if stage_name == &#34;Stage 2&#34;:
        # TR1 ramp start
        loads.append(LoadItem(&#34;TR1+SPMT&#34;, W_TR, fr_to_x(fr_tr1_ramp_start), &#34;CARGO&#34;))
    elif stage_name == &#34;Stage 3&#34;:
        # TR1 mid-ramp
        loads.append(LoadItem(&#34;TR1+SPMT&#34;, W_TR, fr_to_x(fr_tr1_ramp_mid), &#34;CARGO&#34;))
    elif stage_name == &#34;Stage 4&#34;:
        # TR1 on deck
        loads.append(LoadItem(&#34;TR1+SPMT&#34;, W_TR, fr_to_x(fr_tr1_pos), &#34;CARGO&#34;))
    elif stage_name == &#34;Stage 5&#34;:
        # TR1 최종 stow (Trim 이벤트는 base에서 이미 포함된 것으로 간주)
        loads.append(LoadItem(&#34;TR1+SPMT&#34;, W_TR, fr_to_x(fr_tr1_pos), &#34;CARGO&#34;))
    elif stage_name == &#34;Stage 5_PreBallast&#34;:
        loads.extend(build_stage5_loads(preballast_t, params))
    elif stage_name == &#34;Stage 6A_Critical (Opt C)&#34;:
        loads.append(LoadItem(&#34;TR1+SPMT&#34;, W_TR, fr_to_x(fr_tr1_pos), &#34;CARGO&#34;))
        loads.append(LoadItem(&#34;TR2+SPMT&#34;, W_TR, fr_to_x(fr_tr2_ramp), &#34;CARGO&#34;))
        loads.append(LoadItem(&#34;PreBallast&#34;, preballast_t, fr_to_x(fr_pb), &#34;BALLAST&#34;))
    elif stage_name == &#34;Stage 6B Tide Window&#34;:
        # Stage 6B: Stage 6A_Critical과 동일한 하중 (Draft 동일, Tide는 UKC 계산에만 영향)
        loads.append(LoadItem(&#34;TR1+SPMT&#34;, W_TR, fr_to_x(fr_tr1_pos), &#34;CARGO&#34;))
        loads.append(LoadItem(&#34;TR2+SPMT&#34;, W_TR, fr_to_x(fr_tr2_ramp), &#34;CARGO&#34;))
        loads.append(LoadItem(&#34;PreBallast&#34;, preballast_t, fr_to_x(fr_pb), &#34;BALLAST&#34;))
    elif stage_name == &#34;Stage 6C_TotalMassOpt&#34;:
        loads.append(LoadItem(&#34;TR1+SPMT&#34;, W_TR, fr_to_x(fr_tr1_pos), &#34;CARGO&#34;))
        loads.append(LoadItem(&#34;TR2+SPMT&#34;, W_TR, fr_to_x(fr_tr2_stow), &#34;CARGO&#34;))
        loads.append(LoadItem(&#34;PreBallast&#34;, preballast_t, fr_to_x(fr_pb), &#34;BALLAST&#34;))
    elif stage_name == &#34;Stage 6C&#34;:
        loads.append(LoadItem(&#34;TR1+SPMT&#34;, W_TR, fr_to_x(fr_tr1_pos), &#34;CARGO&#34;))
        loads.append(LoadItem(&#34;TR2+SPMT&#34;, W_TR, fr_to_x(fr_tr2_stow), &#34;CARGO&#34;))
        loads.append(LoadItem(&#34;PreBallast&#34;, preballast_t, fr_to_x(fr_pb), &#34;BALLAST&#34;))
    elif stage_name == &#34;Stage 7&#34;:
        return loads

    return loads</code></pre>
</details>
<div class="desc"><p>Stage별 LoadItem 리스트 (모든 Stage 지원).</p>
<p>이 함수는 각 Stage별로 변동 하중(TR1, TR2, Pre-ballast)을 구성합니다.
고정 하중(Fuel, FreshWater)은 CONST_TANKS 시트에서 참조되며,
solve_stage() 함수에서 별도로 처리됩니다.</p>
<p>Stage 정의 (9개):
1. Stage 1: Arrival (경하중, 빈 리스트 반환)
2. Stage 2: TR1 Ramp Start (TR1+SPMT ramp 시작 위치)
3. Stage 3: TR1 Mid-Ramp (TR1+SPMT ramp 중간 위치)
4. Stage 4: TR1 On Deck (TR1+SPMT 갑판 도착)
5. Stage 5: TR1 Final Position (TR1+SPMT 최종 stow 위치)
6. Stage 5_PreBallast: Water Supply Complete (D-1 Night, TR1 stow + TR2 partial ramp + Stern ballast)
7. Stage 6A_Critical (Opt C): TR2 Ramp Entry (D-Day, TR1 stow + TR2 ramp + Pre-ballast)
8. Stage 6C: Final Stowage (TR1 + TR2 모두 stow + Pre-ballast)
9. Stage 7: Departure (Cargo off, 빈 리스트 반환)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stage_name</code></strong></dt>
<dd>Stage 이름
- 지원 형식: "Stage 1", "Stage 2", &hellip;, "Stage 7"
- "Stage 5_PreBallast", "Stage 6A_Critical (Opt C)", "Stage 6C"</dd>
<dt><strong><code>preballast_t</code></strong></dt>
<dd>Pre-ballast 중량 (ton)
- find_preballast_opt() 결과값 사용
- Stage 5_PreBallast, 6A, 6C에서만 사용</dd>
<dt><strong><code>params</code></strong></dt>
<dd>파라미터 딕셔너리
- W_TR: Transformer + SPMT 중량 (ton), 기본값 280.0
- FR_TR1_STOW: TR1 최종 stow Frame 번호, 기본값 42.0
- FR_TR1_RAMP_MID: TR1 ramp 중간 Frame 번호, 기본값 37.00
- FR_TR1_RAMP_START: TR1 ramp 시작 Frame 번호, 기본값 40.15
- FR_TR2_RAMP: TR2 ramp Frame 번호, 기본값 17.95
- FR_TR2_STOW: TR2 최종 stow Frame 번호, 기본값 40.00
- FR_PREBALLAST: PreBallast Frame 번호 (FW2 중심, AFT 쪽, Fr 0-6, Mid_Fr=3.0)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem">LoadItem</a>]</code></dt>
<dd>Stage별 변동 하중 리스트
- LoadItem 구조: (name, weight_t, x_from_mid_m, fsm_t_m)
- x_from_mid_m: LCG (m from midship, AFT=+, FWD=-)
- fsm_t_m: FSM (t·m), 변동 하중은 일반적으로 0.0</dd>
</dl>
<p>하중 구성 요소:
- TR1+SPMT: 560t (위치 변동, Fr.42 → Fr.17.95)
- TR2+SPMT: 560t (Stage 6A부터)
- Pre-ballast: find_preballast_opt() 결과 (Stage 5_PreBallast, 6A, 6C)
- Fuel/FreshWater: CONST_TANKS 시트 참조 (이 함수에서는 처리하지 않음)</p>
<p>가정:
- Stage 2/3/4: TR1+SPMT만 ramp→deck 이동
- Stage 5: TR1 최종 stow. (추가 하중 없음)
- Stage 5_PreBallast: TR1 stow + TR2 partial ramp + Pre-ballast
- Stage 6A: TR1 stow + TR2 ramp 진입 + Pre-ballast
- Stage 6C: 두 TR 모두 stow + Pre-ballast
- Stage 7: Cargo off (추가 하중 없음)</p>
<p>See Also:
- DATA_SOURCE_DOCUMENTATION.md Section 4.3
- find_preballast_opt() for pre-ballast optimization
- solve_stage() for stage calculation with loads
- CONST_TANKS 시트 for fixed loads (Fuel/FreshWater)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_tank_lookup"><code class="name flex">
<span>def <span class="ident">build_tank_lookup</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_tank_lookup():
    &#34;&#34;&#34;
    Tank 좌표/용량 JSON에서 Ballast 탱크 정보 취합.

    Source:
    - data/tank_coordinates.json : data[].Tank_Name, Mid_Fr, x_from_mid_m(선택), Weight_MT, Volume_m3
    - data/tank_data.json        : data[].Tank_Name, Weight_MT (실측 100% 기준)
    - get_fixed_tank_data()      : 757 TCP LCG(AP) → x_from_mid_m 변환 (FWB1/2, FWCARGO1/2)

    좌표계:
    - x_from_mid_m: Midship(0.0) 기준, FWD(-) / AFT(+)
    - FWB1/2, FWCARGO1/2는 Tank Plan 757 TCP의 LCG(AP) → midship 변환값을 항상 우선 사용.
    &#34;&#34;&#34;
    # 1) 고정 탱크 데이터 (FWB1/2, FWCARGO1/2) – LCG(AP) 기반 x, max_t, SG
    fixed_data = get_fixed_tank_data()

    # 2) JSON 로드 (없으면 None)
    coords = _load_json(&#34;data/tank_coordinates.json&#34;)
    tdata = _load_json(&#34;data/tank_data.json&#34;)

    coord_index: dict[str, dict] = {}
    tdata_index: dict[str, dict] = {}

    if isinstance(coords, list):
        for item in coords:
            name = item.get(&#34;Tank_Name&#34;) or item.get(&#34;TankName&#34;)
            if not name:
                continue
            coord_index[name] = item
    elif isinstance(coords, dict) and &#34;data&#34; in coords:
        for item in coords[&#34;data&#34;]:
            name = item.get(&#34;Tank_Name&#34;) or item.get(&#34;TankName&#34;)
            if not name:
                continue
            coord_index[name] = item

    if isinstance(tdata, list):
        for item in tdata:
            name = item.get(&#34;Tank_Name&#34;) or item.get(&#34;TankName&#34;)
            if not name:
                continue
            tdata_index[name] = item
    elif isinstance(tdata, dict) and &#34;data&#34; in tdata:
        for item in tdata[&#34;data&#34;]:
            name = item.get(&#34;Tank_Name&#34;) or item.get(&#34;TankName&#34;)
            if not name:
                continue
            tdata_index[name] = item

    # 3) 전체 탱크 이름 집합
    all_names: set[str] = set()
    all_names.update(coord_index.keys())
    all_names.update(tdata_index.keys())
    all_names.update(fixed_data.keys())

    lookup: dict[str, dict] = {}

    for tank_name in sorted(all_names):
        info: dict[str, float] = {}

        # 3-1) FWB1/2, FWCARGO1/2는 LCG(AP) 기반 fixed_data 최우선
        if tank_name in fixed_data:
            fd = fixed_data[tank_name]
            info[&#34;x_from_mid_m&#34;] = float(fd[&#34;x&#34;])
            info[&#34;max_t&#34;] = float(fd[&#34;max_t&#34;])
            info[&#34;SG&#34;] = float(fd.get(&#34;SG&#34;, 1.0))

        # 3-2) tank_coordinates.json 정보 병합 (Frame 기반 → x 변환 포함)
        c = coord_index.get(tank_name)
        if c:
            x_val = c.get(&#34;x_from_mid_m&#34;)
            if x_val is None:
                mid_fr = c.get(&#34;Mid_Fr&#34;) or c.get(&#34;MidFr&#34;) or c.get(&#34;Fr&#34;)
                if mid_fr is not None:
                    x_val = fr_to_x(float(mid_fr))
            if x_val is not None and &#34;x_from_mid_m&#34; not in info:
                info[&#34;x_from_mid_m&#34;] = float(x_val)

            # JSON 쪽에 Weight_MT가 있고 fixed에 max_t 없으면 사용
            if &#34;max_t&#34; not in info:
                wt = c.get(&#34;Weight_MT&#34;)
                if wt is not None:
                    info[&#34;max_t&#34;] = float(wt)

        # 3-3) tank_data.json 정보 병합 (우선순위: fixed &lt; coords &lt; tdata)
        d = tdata_index.get(tank_name)
        if d:
            if &#34;max_t&#34; not in info:
                wt = d.get(&#34;Weight_MT&#34;) or d.get(&#34;Weight_t&#34;)
                if wt is not None:
                    info[&#34;max_t&#34;] = float(wt)

        # 3-4) SG / air_vent 기본값 – Fresh Water 기준 1.000
        sg = float(info.get(&#34;SG&#34;, 1.0))

        if tank_name.startswith(&#34;FWB&#34;):
            # Fresh Water Ballast – air vent 80mm
            sg = 1.000
            air_vent = 80
        elif tank_name.startswith(&#34;FWCARGO&#34;):
            # Cargo FW tanks – air vent 125mm
            sg = 1.000
            air_vent = 125
        else:
            air_vent = &#34;&#34;

        x_from_mid = float(info.get(&#34;x_from_mid_m&#34;, 0.0))
        max_t = float(info.get(&#34;max_t&#34;, 0.0))

        lookup[tank_name] = {
            &#34;x_from_mid_m&#34;: round(x_from_mid, 2),
            &#34;max_t&#34;: round(max_t, 2),
            &#34;SG&#34;: sg,
            &#34;air_vent_mm&#34;: air_vent,
        }

    print(f&#34;  [OK] Tank lookup built (tanks={len(lookup)})&#34;)
    return lookup</code></pre>
</details>
<div class="desc"><p>Tank 좌표/용량 JSON에서 Ballast 탱크 정보 취합.</p>
<p>Source:
- data/tank_coordinates.json : data[].Tank_Name, Mid_Fr, x_from_mid_m(선택), Weight_MT, Volume_m3
- data/tank_data.json
: data[].Tank_Name, Weight_MT (실측 100% 기준)
- get_fixed_tank_data()
: 757 TCP LCG(AP) → x_from_mid_m 변환 (FWB1/2, FWCARGO1/2)</p>
<p>좌표계:
- x_from_mid_m: Midship(0.0) 기준, FWD(-) / AFT(+)
- FWB1/2, FWCARGO1/2는 Tank Plan 757 TCP의 LCG(AP) → midship 변환값을 항상 우선 사용.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_draft_with_lcf"><code class="name flex">
<span>def <span class="ident">calc_draft_with_lcf</span></span>(<span>tmean_m: float, trim_cm: float, lcf_m: float, lbp_m: float) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_draft_with_lcf(
    tmean_m: float, trim_cm: float, lcf_m: float, lbp_m: float
) -&gt; tuple[float, float]:
    &#34;&#34;&#34;
    Draft 계산 (단일 참조점/부호 규약 고정).

    Conventions (LOCKED)
    --------------------
    - x_from_mid_m: midship 기준, AFT = +, FWD = -
    - trim_cm: (Daft - Dfwd) * 100  [cm]
        * + : stern down (AFT deeper)
        * - : bow down   (FWD deeper)
    - tmean_m: midship draft ≈ (Dfwd + Daft) / 2   [m]
    - lbp_m: LBP/Lpp used for trim slope length     [m]
    - lcf_m: LCF x_from_mid_m (aft+)  [m]
      * NOTE: end-draft conversion에는 LCF가 필요 없지만, mixed-reference 입력을 방지하기 위해
        여기서 범위 검증만 수행한다.

    Returns
    -------
    (Dfwd_m, Daft_m)
    &#34;&#34;&#34;
    if lbp_m &lt;= 0:
        raise ValueError(&#34;LBP must be &gt; 0&#34;)

    halfL = lbp_m / 2.0

    # Guard-rail: LCF는 midship 기준이면 |LCF| &lt;= LBP/2 근처여야 한다.
    # (LCF from AP/FP 값이 들어오면 즉시 실패시켜 혼용을 차단)
    if abs(lcf_m) &gt; halfL + 0.50:
        raise ValueError(
            f&#34;LCF reference mismatch suspected. &#34;
            f&#34;Expected lcf_m as x_from_mid_m (|lcf|&lt;=~{halfL:.3f}), got {lcf_m:.3f}.&#34;
        )

    trim_m = trim_cm / 100.0  # cm -&gt; m

    # Linear trim line about midship:
    # draft(x) = tmean_m + (trim_m / lbp_m) * x_from_mid_m
    dfwd_m = tmean_m + (trim_m / lbp_m) * (-halfL)
    daft_m = tmean_m + (trim_m / lbp_m) * (+halfL)

    # Validate trim definition: trim_cm == (Daft - Dfwd) * 100
    trim_verify_cm = (daft_m - dfwd_m) * 100.0
    if abs(trim_verify_cm - trim_cm) &gt; 0.01:
        logging.warning(
            f&#34;[TrimRef] Trim definition mismatch in calc_draft_with_lcf: &#34;
            f&#34;trim_cm={trim_cm:.2f}, verified_cm={trim_verify_cm:.2f}&#34;
        )

    return dfwd_m, daft_m</code></pre>
</details>
<div class="desc"><p>Draft 계산 (단일 참조점/부호 규약 고정).</p>
<h2 id="conventions-locked">Conventions (LOCKED)</h2>
<ul>
<li>x_from_mid_m: midship 기준, AFT = +, FWD = -</li>
<li>trim_cm: (Daft - Dfwd) * 100
[cm]<ul>
<li>
<ul>
<li>: stern down (AFT deeper)</li>
</ul>
</li>
<li>
<ul>
<li>: bow down
(FWD deeper)</li>
</ul>
</li>
</ul>
</li>
<li>tmean_m: midship draft ≈ (Dfwd + Daft) / 2
[m]</li>
<li>lbp_m: LBP/Lpp used for trim slope length
[m]</li>
<li>lcf_m: LCF x_from_mid_m (aft+)
[m]</li>
<li>NOTE: end-draft conversion에는 LCF가 필요 없지만, mixed-reference 입력을 방지하기 위해
여기서 범위 검증만 수행한다.</li>
</ul>
<h2 id="returns">Returns</h2>
<p>(Dfwd_m, Daft_m)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_gm_effective"><code class="name flex">
<span>def <span class="ident">calc_gm_effective</span></span>(<span>disp_t: float, gm_m: float, fse_t_m: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_gm_effective(disp_t: float, gm_m: float, fse_t_m: float) -&gt; float:
    &#34;&#34;&#34;
    자유수면효과(FSE)를 반영한 유효 GM.
    GM_eff = GM - FSE/Δ
    &#34;&#34;&#34;
    if disp_t &lt;= 0:
        return gm_m

    gm_eff = gm_m - (fse_t_m / disp_t)
    return gm_eff</code></pre>
</details>
<div class="desc"><p>자유수면효과(FSE)를 반영한 유효 GM.
GM_eff = GM - FSE/Δ</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_heel_from_offset"><code class="name flex">
<span>def <span class="ident">calc_heel_from_offset</span></span>(<span>weight_t: float, y_offset_m: float, disp_t: float, gm_m: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_heel_from_offset(
    weight_t: float, y_offset_m: float, disp_t: float, gm_m: float
) -&gt; float:
    &#34;&#34;&#34;
    횡 방향 편심 하중에 의한 Heel 각도 (deg) 계산.
    Small-angle 가정: tan(φ) ≈ φ(rad) 사용.
    &#34;&#34;&#34;
    if disp_t &lt;= 0 or gm_m &lt;= 0 or weight_t == 0 or y_offset_m == 0:
        return 0.0

    m_heeling = weight_t * y_offset_m  # t·m
    m_restoring = disp_t * gm_m  # t·m

    phi_rad = m_heeling / m_restoring
    heel_deg = math.degrees(phi_rad)
    return heel_deg</code></pre>
</details>
<div class="desc"><p>횡 방향 편심 하중에 의한 Heel 각도 (deg) 계산.
Small-angle 가정: tan(φ) ≈ φ(rad) 사용.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_trim"><code class="name flex">
<span>def <span class="ident">calc_trim</span></span>(<span>moment_tm: float, params: dict | None = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_trim(moment_tm: float, params: dict | None = None) -&gt; float:
    &#34;&#34;&#34;
    Return Trim [cm] from moment [t·m].

    우선순위:
    1) params[&#34;MTC_t_m_per_cm&#34;]
    2) params[&#34;MTC&#34;]
    3) 기본값 34.00
    &#34;&#34;&#34;
    if params is None:
        params = DEFAULT_PARAMS

    mtc = params.get(&#34;MTC_t_m_per_cm&#34;, params.get(&#34;MTC&#34;, 34.00))
    return round(moment_tm / mtc, 2)</code></pre>
</details>
<div class="desc"><p>Return Trim [cm] from moment [t·m].</p>
<p>우선순위:
1) params["MTC_t_m_per_cm"]
2) params["MTC"]
3) 기본값 34.00</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_trim_gate_cm_from_tmean"><code class="name flex">
<span>def <span class="ident">calc_trim_gate_cm_from_tmean</span></span>(<span>tmean_m: float, fwd_limit_m: float = 2.7) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_trim_gate_cm_from_tmean(tmean_m: float, fwd_limit_m: float = 2.70) -&gt; float:
    &#34;&#34;&#34;
    Calculate required trim (cm) to satisfy forward draft limit.

    PATCH B2: Trim_gate calculation based on Tmean and FWD limit.

    Formula: Trim_gate_cm = max(0, 2 * (Tmean - FWD_limit) * 100)

    This ensures: Dfwd = Tmean - (Trim/2) &lt;= FWD_limit
    Therefore: Trim &gt;= 2 * (Tmean - FWD_limit)

    Args:
        tmean_m: Mean draft (m)
        fwd_limit_m: Forward draft limit (m), default 2.70

    Returns:
        Required trim in cm (positive = stern down, negative = bow down)
        Returns 0 if Tmean &lt;= FWD_limit (no trim needed)
    &#34;&#34;&#34;
    trim_gate_cm = max(0.0, 2.0 * (tmean_m - fwd_limit_m) * 100.0)
    return float(trim_gate_cm)</code></pre>
</details>
<div class="desc"><p>Calculate required trim (cm) to satisfy forward draft limit.</p>
<p>PATCH B2: Trim_gate calculation based on Tmean and FWD limit.</p>
<p>Formula: Trim_gate_cm = max(0, 2 * (Tmean - FWD_limit) * 100)</p>
<p>This ensures: Dfwd = Tmean - (Trim/2) &lt;= FWD_limit
Therefore: Trim &gt;= 2 * (Tmean - FWD_limit)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tmean_m</code></strong></dt>
<dd>Mean draft (m)</dd>
<dt><strong><code>fwd_limit_m</code></strong></dt>
<dd>Forward draft limit (m), default 2.70</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Required trim in cm (positive = stern down, negative = bow down)
Returns 0 if Tmean &lt;= FWD_limit (no trim needed)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.cleanup_old_backups"><code class="name flex">
<span>def <span class="ident">cleanup_old_backups</span></span>(<span>backup_dir, keep=5)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup_old_backups(backup_dir, keep=5):
    &#34;&#34;&#34;
    BACKUP PLAN: 오래된 백업 파일 정리
    &#34;&#34;&#34;
    try:
        backups = [
            os.path.join(backup_dir, f)
            for f in os.listdir(backup_dir)
            if f.endswith(&#34;.xlsx&#34;)
        ]
        backups.sort(key=os.path.getmtime, reverse=True)

        if len(backups) &gt; keep:
            for old_backup in backups[keep:]:
                os.remove(old_backup)
                logging.info(
                    f&#34;[BACKUP] Removed old backup: {os.path.basename(old_backup)}&#34;
                )
    except Exception as e:
        logging.warning(f&#34;[BACKUP] Cleanup failed: {e}&#34;)</code></pre>
</details>
<div class="desc"><p>BACKUP PLAN: 오래된 백업 파일 정리</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_acceptance_criteria_sheet"><code class="name flex">
<span>def <span class="ident">create_acceptance_criteria_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>stage_results: dict,<br>sheet_name: str = 'MWS_Acceptance_Criteria') ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_acceptance_criteria_sheet(
    wb: Workbook, stage_results: dict, sheet_name: str = &#34;MWS_Acceptance_Criteria&#34;
) -&gt; Worksheet:
    ws = (
        wb.create_sheet(sheet_name)
        if sheet_name not in wb.sheetnames
        else wb[sheet_name]
    )
    styles = get_styles()
    ws[&#34;A1&#34;] = &#34;MWS / Harbour Master – Acceptance Criteria Gate (data-driven)&#34;
    ws[&#34;A1&#34;].font = styles[&#34;title_font&#34;]

    headers = [&#34;Stage&#34;, &#34;Available&#34;, &#34;PASS&#34;, &#34;Missing&#34;, &#34;Checks (key: value op limit)&#34;]
    for c, h in enumerate(headers, start=1):
        cell = ws.cell(row=3, column=c, value=h)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]

    r = 4
    for stage_id, res in stage_results.items():
        acc = (res.get(&#34;BPLUS&#34;) or {}).get(&#34;Acceptance&#34;) or {}
        avail = bool(acc.get(&#34;available&#34;))
        passed = bool(acc.get(&#34;pass&#34;)) if avail else False
        ws.cell(r, 1, stage_id)
        ws.cell(r, 2, &#34;Y&#34; if avail else &#34;N&#34;)
        ws.cell(r, 3, &#34;PASS&#34; if passed else &#34;FAIL&#34;)
        ws.cell(r, 4, acc.get(&#34;missing&#34;, &#34;&#34;))
        checks = acc.get(&#34;checks&#34;) or {}
        parts = []
        for k, v in checks.items():
            if not isinstance(v, dict):
                continue
            parts.append(f&#34;{k}:{v.get(&#39;value&#39;)} {v.get(&#39;op&#39;)} {v.get(&#39;limit&#39;)}&#34;)
        ws.cell(r, 5, &#34;; &#34;.join(parts))
        r += 1

    ws.freeze_panes = &#34;A4&#34;
    ws.column_dimensions[&#34;A&#34;].width = 26
    ws.column_dimensions[&#34;E&#34;].width = 80
    return ws</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_backup_file"><code class="name flex">
<span>def <span class="ident">create_backup_file</span></span>(<span>original_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_backup_file(original_path):
    &#34;&#34;&#34;
    BACKUP PLAN: 생성된 파일의 백업 자동 생성
    backups/ 폴더에 타임스탬프 백업 저장 (최근 5개 유지)
    &#34;&#34;&#34;
    if not os.path.exists(original_path):
        logging.warning(f&#34;Backup failed: {original_path} not found&#34;)
        return None

    # 백업 디렉토리 생성
    backup_dir = os.path.join(os.path.dirname(original_path), &#34;backups&#34;)
    os.makedirs(backup_dir, exist_ok=True)

    # 타임스탬프 백업
    timestamp = datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;)
    filename = os.path.basename(original_path)
    backup_path = os.path.join(backup_dir, f&#34;{timestamp}_{filename}&#34;)

    try:
        shutil.copy2(original_path, backup_path)
        logging.info(f&#34;[BACKUP] Created: {backup_path}&#34;)
        print(f&#34;  [BACKUP] Created: {os.path.basename(backup_path)}&#34;)

        # 오래된 백업 정리 (최근 5개만 유지)
        cleanup_old_backups(backup_dir, keep=5)

        return backup_path
    except Exception as e:
        logging.error(f&#34;[BACKUP] Failed to create backup: {e}&#34;)
        print(f&#34;  [BACKUP] Warning: Backup creation failed: {e}&#34;)
        return None</code></pre>
</details>
<div class="desc"><p>BACKUP PLAN: 생성된 파일의 백업 자동 생성
backups/ 폴더에 타임스탬프 백업 저장 (최근 5개 유지)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_ballast_scenario_comparison_sheet"><code class="name flex">
<span>def <span class="ident">create_ballast_scenario_comparison_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>scenarios: Dict[str, Dict[str, float]],<br>sheet_name: str = 'Ballast_Scenario_Comparison') ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_ballast_scenario_comparison_sheet(
    wb: Workbook,
    scenarios: Dict[str, Dict[str, float]],
    sheet_name: str = &#34;Ballast_Scenario_Comparison&#34;,
) -&gt; Worksheet:
    &#34;&#34;&#34;
    옵션 1/2/3 Ballast 시나리오 비교용 요약 시트 생성.

    기대 입력 형식 (예시):
    scenarios = {
        &#34;Option 1 – Pre-ballast Only&#34;: {
            &#34;total_ballast_t&#34;: 536.0,
            &#34;total_time_h&#34;: 5.36,
            &#34;fwd_draft_margin_m&#34;: 0.28,       # 2.70m 한계 대비 여유
            &#34;linkspan_freeboard_margin_m&#34;: 0.12,
        },
        &#34;Option 2 – D-day Dynamic&#34;: {
            &#34;total_ballast_t&#34;: 420.0,
            &#34;total_time_h&#34;: 6.00,
            &#34;fwd_draft_margin_m&#34;: 0.15,
            &#34;linkspan_freeboard_margin_m&#34;: 0.08,
        },
        ...
    }
    &#34;&#34;&#34;
    styles = get_styles()
    if sheet_name in wb.sheetnames:
        ws = wb[sheet_name]
        wb.remove(ws)

    ws = wb.create_sheet(sheet_name)

    title = ws[&#34;A1&#34;]
    title.value = &#34;Ballast Scenario Comparison (Option 1 / 2 / 3)&#34;
    title.font = styles[&#34;title_font&#34;]

    ws[&#34;A3&#34;].value = (
        &#34;각 시나리오별 총 Ballast, Pump 시간, FWD Draft margin, Linkspan freeboard margin 비교.&#34;
    )
    ws[&#34;A3&#34;].font = styles[&#34;normal_font&#34;]

    header_row = 5
    headers = [
        &#34;Scenario&#34;,
        &#34;Total Ballast_t&#34;,
        &#34;Pump Time_h&#34;,
        &#34;FWD Draft Margin_m&#34;,
        &#34;Linkspan Freeboard Margin_m&#34;,
        &#34;Risk Comment&#34;,
    ]
    for col, h in enumerate(headers, start=1):
        c = ws.cell(row=header_row, column=col, value=h)
        c.font = styles[&#34;header_font&#34;]
        c.fill = styles[&#34;header_fill&#34;]

    number_format = &#34;#,##0.00&#34;
    current_row = header_row + 1

    # Defensive init to avoid NameError if code paths change
    link_margin = 0.0
    fwd_margin = 0.0

    for name, vals in scenarios.items():
        total_ballast = float(vals.get(&#34;total_ballast_t&#34;, 0.0) or 0.0)
        time_h = float(vals.get(&#34;total_time_h&#34;, 0.0) or 0.0)
        fwd_margin = float(vals.get(&#34;fwd_draft_margin_m&#34;, 0.0) or 0.0)
        link_margin = float(vals.get(&#34;linkspan_freeboard_margin_m&#34;, 0.0) or 0.0)

        ws.cell(row=current_row, column=1, value=name).font = styles[&#34;normal_font&#34;]

        def _num(col_idx: int, value: float):
            c = ws.cell(row=current_row, column=col_idx, value=round(float(value), 2))
            c.font = styles[&#34;normal_font&#34;]
            c.number_format = number_format

        _num(2, total_ballast)
        _num(3, time_h)
        _num(4, fwd_margin)
        _num(5, link_margin)

        # 간단 Risk 평가: margin이 0.10m 미만이면 WARN
        risk_comment = []
        if fwd_margin &lt; 0.10:
            risk_comment.append(&#34;FWD margin &lt; 0.10m&#34;)
        if link_margin &lt; 0.10:
            risk_comment.append(&#34;Linkspan margin &lt; 0.10m&#34;)
        ws.cell(row=current_row, column=6, value=&#34;; &#34;.join(risk_comment)).font = styles[
            &#34;normal_font&#34;
        ]

        current_row += 1

    # 컬럼 폭
    for col in range(1, len(headers) + 1):
        ws.column_dimensions[get_column_letter(col)].width = 30

    print(&#34;  [OK] Ballast_Scenario_Comparison sheet created&#34;)
    return ws</code></pre>
</details>
<div class="desc"><p>옵션 1/2/3 Ballast 시나리오 비교용 요약 시트 생성.</p>
<p>기대 입력 형식 (예시):
scenarios = {
"Option 1 – Pre-ballast Only": {
"total_ballast_t": 536.0,
"total_time_h": 5.36,
"fwd_draft_margin_m": 0.28,
# 2.70m 한계 대비 여유
"linkspan_freeboard_margin_m": 0.12,
},
"Option 2 – D-day Dynamic": {
"total_ballast_t": 420.0,
"total_time_h": 6.00,
"fwd_draft_margin_m": 0.15,
"linkspan_freeboard_margin_m": 0.08,
},
&hellip;
}</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_ballast_tanks_sheet"><code class="name flex">
<span>def <span class="ident">create_ballast_tanks_sheet</span></span>(<span>wb)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_ballast_tanks_sheet(wb):
    &#34;&#34;&#34;Ballast_Tanks 시트 생성 (tank_coordinates.json + tank_data.json 기반)&#34;&#34;&#34;
    ws = wb.create_sheet(&#34;Ballast_Tanks&#34;)
    styles = get_styles()

    headers = [&#34;TankName&#34;, &#34;x_from_mid_m&#34;, &#34;max_t&#34;, &#34;SG&#34;, &#34;use_flag&#34;, &#34;air_vent_mm&#34;]

    # 1) JSON 병합: tank_coordinates.json + tank_data.json
    tank_lookup = build_tank_lookup()

    # 2) 이 프로젝트에서 실제로 쓸 Ballast 탱크 목록 + 기본 use_flag
    #    (필요 시 여기에 DO, FO, 기타 탱크 추가 가능)
    target_tanks = [
        (&#34;FWB1.P&#34;, &#34;Y&#34;),
        (&#34;FWB1.S&#34;, &#34;Y&#34;),
        (&#34;FWB2.P&#34;, &#34;Y&#34;),
        (&#34;FWB2.S&#34;, &#34;Y&#34;),
        (&#34;FWCARGO1.P&#34;, &#34;N&#34;),  # 선택 사용
        (&#34;FWCARGO1.S&#34;, &#34;N&#34;),
        (&#34;FWCARGO2.P&#34;, &#34;N&#34;),
        (&#34;FWCARGO2.S&#34;, &#34;N&#34;),
    ]

    # 3) Fallback 값 (JSON 없거나, 특정 탱크 키가 비어 있을 때 사용)
    # Fixed: tank.md 기준 정밀 LCG 변환값 (x_from_mid) 및 SG 1.000 적용
    fallback = {
        &#34;FWB1.P&#34;: {
            &#34;x&#34;: -27.37,  # LCG 57.519m -&gt; x = -27.368
            &#34;max_t&#34;: 50.57,
            &#34;SG&#34;: 1.000,
            &#34;air_vent_mm&#34;: 80,
        },
        &#34;FWB1.S&#34;: {
            &#34;x&#34;: -27.37,
            &#34;max_t&#34;: 50.57,
            &#34;SG&#34;: 1.000,
            &#34;air_vent_mm&#34;: 80,
        },
        &#34;FWB2.P&#34;: {
            &#34;x&#34;: -19.89,  # LCG 50.038m -&gt; x = -19.887
            &#34;max_t&#34;: 109.98,
            &#34;SG&#34;: 1.000,
            &#34;air_vent_mm&#34;: 80,
        },
        &#34;FWB2.S&#34;: {
            &#34;x&#34;: -19.89,
            &#34;max_t&#34;: 109.98,
            &#34;SG&#34;: 1.000,
            &#34;air_vent_mm&#34;: 80,
        },
        &#34;FWCARGO1.P&#34;: {
            &#34;x&#34;: -12.60,  # LCG 42.750m -&gt; x = -12.599
            &#34;max_t&#34;: 148.35,
            &#34;SG&#34;: 1.000,
            &#34;air_vent_mm&#34;: 125,
        },
        &#34;FWCARGO1.S&#34;: {
            &#34;x&#34;: -12.60,
            &#34;max_t&#34;: 148.35,
            &#34;SG&#34;: 1.000,
            &#34;air_vent_mm&#34;: 125,
        },
        &#34;FWCARGO2.P&#34;: {
            &#34;x&#34;: -5.10,  # LCG 35.250m -&gt; x = -5.099
            &#34;max_t&#34;: 148.36,
            &#34;SG&#34;: 1.000,
            &#34;air_vent_mm&#34;: 125,
        },
        &#34;FWCARGO2.S&#34;: {
            &#34;x&#34;: -5.10,
            &#34;max_t&#34;: 148.36,
            &#34;SG&#34;: 1.000,
            &#34;air_vent_mm&#34;: 125,
        },
    }

    # 4) 헤더 작성
    for c, h in enumerate(headers, 1):
        cell = ws.cell(row=1, column=c, value=h)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]
        cell.border = Border(
            left=styles[&#34;thin_border&#34;],
            right=styles[&#34;thin_border&#34;],
            top=styles[&#34;thin_border&#34;],
            bottom=styles[&#34;thin_border&#34;],
        )

    # 5) 데이터 행 작성
    for row_idx, (tank_name, use_flag) in enumerate(target_tanks, start=2):
        info = tank_lookup.get(tank_name, {})
        fb = fallback.get(tank_name, {})

        x_val = info.get(&#34;x_from_mid_m&#34;, fb.get(&#34;x&#34;))
        max_t = info.get(&#34;max_t&#34;, fb.get(&#34;max_t&#34;))
        sg = info.get(&#34;SG&#34;, fb.get(&#34;SG&#34;, 1.0))
        air_vent_mm = info.get(&#34;air_vent_mm&#34;, fb.get(&#34;air_vent_mm&#34;, &#34;&#34;))

        row_data = [tank_name, x_val, max_t, sg, use_flag, air_vent_mm]

        for c, val in enumerate(row_data, 1):
            cell = ws.cell(row=row_idx, column=c, value=val)
            cell.font = styles[&#34;normal_font&#34;]
            if c &gt;= 2:  # 숫자 열
                cell.number_format = &#34;0.00&#34;
            cell.border = Border(
                left=styles[&#34;thin_border&#34;],
                right=styles[&#34;thin_border&#34;],
                top=styles[&#34;thin_border&#34;],
                bottom=styles[&#34;thin_border&#34;],
            )

    # 6) 컬럼 폭 설정
    ws.column_dimensions[&#34;A&#34;].width = 15
    ws.column_dimensions[&#34;B&#34;].width = 15
    ws.column_dimensions[&#34;C&#34;].width = 12
    ws.column_dimensions[&#34;D&#34;].width = 10
    ws.column_dimensions[&#34;E&#34;].width = 10
    ws.column_dimensions[&#34;F&#34;].width = 14

    if tank_lookup:
        print(
            &#34;  [OK] Ballast_Tanks updated with tank_coordinates.json + tank_data.json (2025-11-18)&#34;
        )
    else:
        print(&#34;  [WARN] Ballast_Tanks used fallback hard-coded data (JSON not found)&#34;)</code></pre>
</details>
<div class="desc"><p>Ballast_Tanks 시트 생성 (tank_coordinates.json + tank_data.json 기반)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_calc_sheet"><code class="name flex">
<span>def <span class="ident">create_calc_sheet</span></span>(<span>wb)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_calc_sheet(wb):
    &#34;&#34;&#34;Calc 시트 생성 - 원본 파일 구조와 동일하게 생성&#34;&#34;&#34;
    ws = wb.create_sheet(&#34;Calc&#34;)
    styles = get_styles()

    # Row 2: 제목
    ws.cell(row=2, column=2).value = &#34;LCT BUSHRA — RORO Calculator &amp; Limits&#34;
    ws.cell(row=2, column=2).font = styles[&#34;title_font&#34;]

    # Row 3: 헤더
    headers_row3 = [&#34;&#34;, &#34;SECTION&#34;, &#34;PARAMETER&#34;, &#34;UNIT&#34;, &#34;VALUE&#34;, &#34;NOTES&#34;]
    for col_idx, header in enumerate(headers_row3, start=1):
        if header:
            cell = ws.cell(row=3, column=col_idx)
            cell.value = header
            cell.font = styles[&#34;header_font&#34;]
            cell.fill = styles[&#34;header_fill&#34;]
            cell.alignment = styles[&#34;center_align&#34;]
            cell.border = Border(
                left=styles[&#34;thin_border&#34;],
                right=styles[&#34;thin_border&#34;],
                top=styles[&#34;thin_border&#34;],
                bottom=styles[&#34;thin_border&#34;],
            )

    # INPUT CONSTANTS 섹션 (Row 5-8)
    ws.cell(row=5, column=2).value = &#34;INPUT CONSTANTS&#34;
    ws.cell(row=5, column=3).value = &#34;L_ramp_m&#34;
    ws.cell(row=5, column=4).value = &#34;m&#34;
    ws.cell(row=5, column=5).value = 12.0
    ws.cell(row=5, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=5, column=6).value = &#34;Linkspan length. Calc!D4&#34;

    ws.cell(row=6, column=3).value = &#34;theta_max_deg&#34;
    ws.cell(row=6, column=4).value = &#34;deg&#34;
    ws.cell(row=6, column=5).value = 6.0
    ws.cell(row=6, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=6, column=6).value = &#34;Max ramp angle. Calc!D5&#34;

    ws.cell(row=7, column=3).value = &#34;KminusZ_m&#34;
    ws.cell(row=7, column=4).value = &#34;m&#34;
    ws.cell(row=7, column=5).value = 3.0
    ws.cell(row=7, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=7, column=6).value = &#34;K - Z (UPDATE!). Calc!D6&#34;

    ws.cell(row=8, column=3).value = &#34;D_vessel_m&#34;
    ws.cell(row=8, column=4).value = &#34;m&#34;
    ws.cell(row=8, column=5).value = 3.65
    ws.cell(row=8, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=8, column=6).value = &#34;Molded depth. Calc!D7&#34;

    # LIMITS &amp; OPS 섹션 (Row 10-12)
    ws.cell(row=10, column=2).value = &#34;LIMITS &amp; OPS&#34;
    ws.cell(row=10, column=3).value = &#34;min_fwd_draft_m&#34;
    ws.cell(row=10, column=4).value = &#34;m&#34;
    ws.cell(row=10, column=5).value = 1.5
    ws.cell(row=10, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=10, column=6).value = &#34;Min draft. Calc!D9&#34;

    ws.cell(row=11, column=3).value = &#34;max_fwd_draft_m&#34;
    ws.cell(row=11, column=4).value = &#34;m&#34;
    ws.cell(row=11, column=5).value = 3.5
    ws.cell(row=11, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=11, column=6).value = &#34;Max draft. Calc!D10&#34;

    ws.cell(row=12, column=3).value = &#34;pump_rate_tph&#34;
    ws.cell(row=12, column=4).value = &#34;t/h&#34;
    ws.cell(row=12, column=5).value = 10.0
    ws.cell(row=12, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=12, column=6).value = &#34;Pump rate. Calc!D11&#34;

    # STABILITY 섹션 (Row 14-17)
    ws.cell(row=14, column=2).value = &#34;STABILITY&#34;
    ws.cell(row=14, column=3).value = &#34;MTC_t_m_per_cm&#34;
    ws.cell(row=14, column=4).value = &#34;t·m/cm&#34;
    ws.cell(row=14, column=5).value = (
        34.00  # BUSHRA verified: Reverse-eng from ΔTM 26035 t·m / Δtrim 765cm + booklet
    )
    ws.cell(row=14, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=14, column=6).value = &#34;MTC. Calc!D13&#34;

    ws.cell(row=15, column=3).value = &#34;LCF_m_from_midship&#34;
    ws.cell(row=15, column=4).value = &#34;m&#34;
    ws.cell(row=15, column=5).value = 0.76
    ws.cell(row=15, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=15, column=6).value = &#34;LCF from Midship (Corrected). Calc!D14&#34;

    ws.cell(row=16, column=3).value = &#34;TPC_t_per_cm&#34;
    ws.cell(row=16, column=4).value = &#34;t/cm&#34;
    ws.cell(row=16, column=5).value = (
        8.00  # BUSHRA verified: Approx waterplane 14×60.3×0.85×1.025 ≈680 m² → TPC≈8.00
    )
    ws.cell(row=16, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=16, column=6).value = &#34;TPC. Calc!D15&#34;

    ws.cell(row=17, column=3).value = &#34;Lpp_m&#34;
    ws.cell(row=17, column=4).value = &#34;m&#34;
    ws.cell(row=17, column=5).value = 60.302
    ws.cell(row=17, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=17, column=6).value = &#34;Length between perpendiculars. Calc!D16&#34;

    ws.cell(row=18, column=2).value = &#34;OPERATIONS&#34;
    ws.cell(row=18, column=3).value = &#34;max_fwd_draft_ops_m&#34;
    ws.cell(row=18, column=4).value = &#34;m&#34;
    ws.cell(row=18, column=5).value = 2.70
    ws.cell(row=18, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=18, column=6).value = &#34;Max forward draft for operations. Calc!D9&#34;

    ws.cell(row=19, column=3).value = &#34;ramp_door_offset_m&#34;
    ws.cell(row=19, column=4).value = &#34;m&#34;
    ws.cell(row=19, column=5).value = 0.15
    ws.cell(row=19, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=19, column=6).value = &#34;Ramp door offset. Calc!D11&#34;

    ws.cell(row=20, column=3).value = &#34;linkspan_freeboard_target_m&#34;
    ws.cell(row=20, column=4).value = &#34;m&#34;
    ws.cell(row=20, column=5).value = 0.28
    ws.cell(row=20, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=20, column=6).value = &#34;Linkspan freeboard target. Calc!D12&#34;

    ws.cell(row=21, column=3).value = &#34;gm_target_m&#34;
    ws.cell(row=21, column=4).value = &#34;m&#34;
    ws.cell(row=21, column=5).value = 1.50
    ws.cell(row=21, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=21, column=6).value = &#34;GM target. Calc!D13&#34;

    # STRUCTURAL LIMITS 섹션 (Row 23-26)
    ws.cell(row=23, column=2).value = &#34;STRUCTURAL LIMITS&#34;
    ws.cell(row=23, column=3).value = &#34;limit_reaction_t&#34;
    ws.cell(row=23, column=4).value = &#34;t&#34;
    ws.cell(row=23, column=5).value = 201.60
    ws.cell(row=23, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=23, column=6).value = (
        &#34;Aries Ramp hinge limit 201.60 t (share ratio 0.545, 2025-11-18)&#34;
    )

    ws.cell(row=24, column=3).value = &#34;limit_share_load_t&#34;
    ws.cell(row=24, column=4).value = &#34;t&#34;
    ws.cell(row=24, column=5).value = 118.80
    ws.cell(row=24, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=24, column=6).value = &#34;Max Share Load on LCT (Mammoet)&#34;

    ws.cell(row=25, column=3).value = &#34;limit_deck_press_tpm2&#34;
    ws.cell(row=25, column=4).value = &#34;t/m²&#34;
    ws.cell(row=25, column=5).value = 10.00
    ws.cell(row=25, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=25, column=6).value = &#34;Max Deck Pressure (Spec)&#34;

    ws.cell(row=26, column=3).value = &#34;linkspan_area_m2&#34;
    ws.cell(row=26, column=4).value = &#34;m²&#34;
    ws.cell(row=26, column=5).value = 12.00
    ws.cell(row=26, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=26, column=6).value = (
        &#34;Linkspan 실제 접지 12.00 m² (Ramp 1 TR only 규정)&#34;
    )

    # BALLAST FIX CHECK 섹션 (Row 27-29)
    ws.cell(row=27, column=2).value = &#34;BALLAST FIX CHECK&#34;
    ws.cell(row=27, column=3).value = &#34;max_aft_ballast_cap_t&#34;
    ws.cell(row=27, column=4).value = &#34;t&#34;
    ws.cell(row=27, column=5).value = 28.00
    ws.cell(row=27, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=27, column=6).value = &#34;Max AFT Ballast Capacity (FW2 P/S, Fr 0–6, ~28t)&#34;

    ws.cell(row=28, column=3).value = &#34;max_fwd_ballast_cap_t&#34;
    ws.cell(row=28, column=4).value = &#34;t&#34;
    ws.cell(row=28, column=5).value = 321.00
    ws.cell(row=28, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=28, column=6).value = (
        &#34;Max Forward Ballast Capacity (FWB1/2, Fr 48–65, ~321t)&#34;
    )

    ws.cell(row=29, column=3).value = &#34;max_pump_time_h&#34;
    ws.cell(row=29, column=4).value = &#34;h&#34;
    ws.cell(row=29, column=5).value = 6.00
    ws.cell(row=29, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=29, column=6).value = &#34;Max Allowed Pump Time for Fix&#34;

    # VENT &amp; PUMP 섹션 (Row 30-32)
    ws.cell(row=30, column=2).value = &#34;VENT &amp; PUMP&#34;
    ws.cell(row=30, column=3).value = &#34;vent_flow_coeff&#34;
    ws.cell(row=30, column=4).value = &#34;t/h per mm&#34;
    ws.cell(row=30, column=5).value = 0.86
    ws.cell(row=30, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=30, column=6).value = &#34;실측 보정 0.86 (2025-11-18, MAPE 0.30%)&#34;

    ws.cell(row=31, column=3).value = &#34;pump_rate_tph&#34;
    ws.cell(row=31, column=4).value = &#34;t/h&#34;
    ws.cell(row=31, column=5).value = 100.00
    ws.cell(row=31, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=31, column=6).value = &#34;Hired pump rate&#34;

    ws.cell(row=32, column=3).value = &#34;pump_rate_effective_tph&#34;
    ws.cell(row=32, column=4).value = &#34;t/h&#34;
    ws.cell(row=32, column=5).value = (
        &#39;=MIN(E31, SUMPRODUCT((Ballast_Tanks!E$2:E$100=&#34;Y&#34;)*(Ballast_Tanks!F$2:F$100)*E30))&#39;
    )
    ws.cell(row=32, column=5).fill = styles[&#34;ok_fill&#34;]
    ws.cell(row=32, column=6).value = &#34;실효 펌프 속도 (vent bottleneck, 68.80 t/h)&#34;

    # RAMP GEOMETRY 섹션 (Row 33-36)
    ws.cell(row=33, column=2).value = &#34;RAMP GEOMETRY&#34;
    ws.cell(row=33, column=3).value = &#34;ramp_hinge_x_mid_m&#34;
    ws.cell(row=33, column=4).value = &#34;m&#34;
    ws.cell(row=33, column=5).value = -30.151
    ws.cell(row=33, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=33, column=6).value = &#34;LBP 60.302 m 기준&#34;

    ws.cell(row=34, column=3).value = &#34;ramp_length_m&#34;
    ws.cell(row=34, column=4).value = &#34;m&#34;
    ws.cell(row=34, column=5).value = 8.30
    ws.cell(row=34, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=34, column=6).value = &#34;TRE Cert 2020-08-04&#34;

    ws.cell(row=35, column=3).value = &#34;linkspan_height_m&#34;
    ws.cell(row=35, column=4).value = &#34;m&#34;
    ws.cell(row=35, column=5).value = 2.00
    ws.cell(row=35, column=5).fill = styles[&#34;input_fill&#34;]

    ws.cell(row=36, column=3).value = &#34;ramp_end_clearance_min_m&#34;
    ws.cell(row=36, column=4).value = &#34;m&#34;
    ws.cell(row=36, column=5).value = 0.40
    ws.cell(row=36, column=5).fill = styles[&#34;input_fill&#34;]

    # HINGE STRESS 섹션 (Row 37-38)
    ws.cell(row=37, column=2).value = &#34;HINGE STRESS&#34;
    ws.cell(row=37, column=3).value = &#34;hinge_pin_area_m2&#34;
    ws.cell(row=37, column=4).value = &#34;m²&#34;
    ws.cell(row=37, column=5).value = 0.117
    ws.cell(row=37, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=37, column=6).value = &#34;Doubler 390x300 mm (Aries)&#34;

    ws.cell(row=38, column=3).value = &#34;hinge_limit_rx_t&#34;
    ws.cell(row=38, column=4).value = &#34;t&#34;
    ws.cell(row=38, column=5).value = 201.60
    ws.cell(row=38, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=38, column=6).value = (
        &#34;Max Hinge Reaction (duplicate of E23 for clarity)&#34;
    )

    # PRECISION PARAMETERS 섹션 (Row 40-44)
    ws.cell(row=40, column=2).value = &#34;PRECISION PARAMETERS&#34;
    ws.cell(row=40, column=2).font = styles[&#34;normal_font&#34;]

    ws.cell(row=41, column=3).value = &#34;LBP_m&#34;
    ws.cell(row=41, column=4).value = &#34;m&#34;
    ws.cell(row=41, column=5).value = 60.302  # LBP_m
    ws.cell(row=41, column=5).comment = Comment(&#34;LBP (m) - Calc!$E$41&#34;, &#34;System&#34;)
    ws.cell(row=41, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=41, column=6).value = (
        &#34;Length Between Perpendiculars (for precise draft calculation)&#34;
    )

    ws.cell(row=42, column=3).value = &#34;LCF_from_mid_m&#34;
    ws.cell(row=42, column=4).value = &#34;m&#34;
    ws.cell(row=42, column=5).value = (
        0.76  # BUSHRA verified: LCF_from_AP (30.91) - AP_to_midship (30.151) = 0.759 m
    )
    ws.cell(row=42, column=5).comment = Comment(
        &#34;LCF from mid (m) - Calc!$E$42&#34;, &#34;System&#34;
    )
    ws.cell(row=42, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=42, column=6).value = (
        &#34;LCF from midship (BUSHRA verified, for precise draft calculation)&#34;
    )

    ws.cell(row=43, column=3).value = &#34;dynamic_factor&#34;
    ws.cell(row=43, column=4).value = &#34;-&#34;
    ws.cell(row=43, column=5).value = 1.15
    ws.cell(row=43, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=43, column=6).value = (
        &#34;Dynamic load amplification factor (for Load Case B)&#34;
    )

    ws.cell(row=44, column=3).value = &#34;heel_y_offset_m&#34;
    ws.cell(row=44, column=4).value = &#34;m&#34;
    ws.cell(row=44, column=5).value = 1.50
    ws.cell(row=44, column=5).fill = styles[&#34;input_fill&#34;]
    ws.cell(row=44, column=6).value = &#34;Heel y-offset (for heel angle calculation)&#34;

    # 폰트 적용
    for row in range(5, 45):
        for col in range(2, 7):
            cell = ws.cell(row=row, column=col)
            if cell.value is not None:
                cell.font = styles[&#34;normal_font&#34;]

    ws.column_dimensions[&#34;B&#34;].width = 20
    ws.column_dimensions[&#34;C&#34;].width = 25
    ws.column_dimensions[&#34;D&#34;].width = 10
    ws.column_dimensions[&#34;E&#34;].width = 12
    ws.column_dimensions[&#34;F&#34;].width = 35

    print(&#34;  [OK] Calc sheet created with VENT&amp;PUMP 실측 0.86&#34;)</code></pre>
</details>
<div class="desc"><p>Calc 시트 생성 - 원본 파일 구조와 동일하게 생성</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_captain_report_sheet"><code class="name flex">
<span>def <span class="ident">create_captain_report_sheet</span></span>(<span>wb, stages, first_data_row)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_captain_report_sheet(wb, stages, first_data_row):
    &#34;&#34;&#34;
    Creates the OPERATION SUMMARY sheet summary.
    Updated for v4.3: DAS Method &amp; Critical Checkpoints Highlight.
    &#34;&#34;&#34;
    if &#34;OPERATION SUMMARY&#34; in wb.sheetnames:
        wb.remove(wb[&#34;OPERATION SUMMARY&#34;])

    ws = wb.create_sheet(&#34;OPERATION SUMMARY&#34;)
    styles = get_styles()

    # --- 1. Report Title &amp; Header ---
    ws.merge_cells(&#34;A1:J1&#34;)
    ws[&#34;A1&#34;] = &#34;LCT BUSHRA – OPERATION SUMMARY (DAS METHOD)&#34;
    ws[&#34;A1&#34;].font = styles[&#34;title_font&#34;]
    ws[&#34;A1&#34;].alignment = styles[&#34;center_align&#34;]
    ws[&#34;A1&#34;].fill = styles[&#34;header_fill&#34;]

    # --- 2. Critical Limits (기준값) ---
    headers_limit = [&#34;PARAMETER&#34;, &#34;LIMIT&#34;, &#34;UNIT&#34;, &#34;REMARK&#34;]
    limits_data = [
        (&#34;Summer Draft Max&#34;, 2.70, &#34;m&#34;, &#34;Operational Limit (Harbour: Check Depth)&#34;),
        (&#34;Min Freeboard&#34;, 0.28, &#34;m&#34;, &#34;Linkspan Connection Safety&#34;),
        (&#34;Min GM&#34;, 1.50, &#34;m&#34;, &#34;Stability Requirement&#34;),
        (&#34;Max Ramp Angle&#34;, 6.0, &#34;deg&#34;, &#34;SPMT Climbing Limit&#34;),
    ]

    # Write Limit Table
    ws.merge_cells(&#34;A3:D3&#34;)
    ws[&#34;A3&#34;] = &#34;1. OPERATIONAL LIMITS&#34;
    ws[&#34;A3&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;A3&#34;].fill = styles[&#34;structure_fill&#34;]  # Orange

    for col, text in enumerate(headers_limit, 1):
        cell = ws.cell(row=4, column=col, value=text)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]

    for i, (param, val, unit, rem) in enumerate(limits_data, 5):
        ws.cell(row=i, column=1, value=param).font = styles[&#34;normal_font&#34;]
        ws.cell(row=i, column=2, value=val).font = styles[&#34;normal_font&#34;]
        ws.cell(row=i, column=2).number_format = &#34;0.00&#34;
        ws.cell(row=i, column=2).fill = styles[&#34;input_fill&#34;]
        ws.cell(row=i, column=3, value=unit).font = styles[&#34;normal_font&#34;]
        ws.cell(row=i, column=4, value=rem).font = styles[&#34;normal_font&#34;]

        # 테두리 적용
        for c in range(1, 5):
            ws.cell(row=i, column=c).border = Border(bottom=styles[&#34;thin_border&#34;])

    # --- 3. Stage Summary Table ---
    table_start_row = 10
    ws.merge_cells(f&#34;A{table_start_row-1}:J{table_start_row-1}&#34;)
    ws[f&#34;A{table_start_row-1}&#34;] = &#34;2. STAGE-BY-STAGE SAFETY CHECK&#34;
    ws[f&#34;A{table_start_row-1}&#34;].font = styles[&#34;header_font&#34;]
    ws[f&#34;A{table_start_row-1}&#34;].fill = styles[&#34;structure_fill&#34;]

    headers_table = [
        &#34;Stage&#34;,
        &#34;Condition&#34;,
        &#34;Trim (m)&#34;,
        &#34;Fwd Draft&#34;,
        &#34;Aft Draft&#34;,
        &#34;Draft Check&#34;,
        &#34;Freeboard&#34;,
        &#34;Deck Check&#34;,
        &#34;Action / Note&#34;,
    ]

    # Write Headers
    for col, text in enumerate(headers_table, 1):
        cell = ws.cell(row=table_start_row, column=col, value=text)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]

    # Write Data Rows (Link to RORO Sheet)
    # Mapping from RORO sheet columns:
    # Stage(A), Trim_m(F), Dfwd(O), Daft(P), Phys_Freeboard_m(Z)

    roro_sheet = &#34;RORO_Stage_Scenarios&#34;

    for i, stage_name in enumerate(stages):
        r_rept = table_start_row + 1 + i
        r_roro = first_data_row + i
        r_str = str(r_roro)

        # A: Stage Name
        ws.cell(row=r_rept, column=1, value=f&#34;=&#39;{roro_sheet}&#39;!A{r_str}&#34;)

        # B: Condition (Custom Logic based on Stage Name)
        ws.cell(
            row=r_rept,
            column=2,
            value=f&#39;=IF(ISNUMBER(SEARCH(&#34;PreBallast&#34;,A{r_rept})),&#34;PRE-BALLAST&#34;,IF(ISNUMBER(SEARCH(&#34;Critical&#34;,A{r_rept})),&#34;CRITICAL&#34;,&#34;NORMAL&#34;))&#39;,
        )

        # C: Trim
        ws.cell(row=r_rept, column=3, value=f&#34;=&#39;{roro_sheet}&#39;!F{r_str}&#34;)
        ws.cell(row=r_rept, column=3).number_format = &#34;0.00&#34;

        # D: Fwd Draft
        ws.cell(row=r_rept, column=4, value=f&#34;=&#39;{roro_sheet}&#39;!O{r_str}&#34;)
        ws.cell(row=r_rept, column=4).number_format = &#34;0.00&#34;

        # E: Aft Draft
        ws.cell(row=r_rept, column=5, value=f&#34;=&#39;{roro_sheet}&#39;!P{r_str}&#34;)
        ws.cell(row=r_rept, column=5).number_format = &#34;0.00&#34;

        # F: Draft Check (Max Draft vs Limit 2.70)
        # Logic: If PreBallast -&gt; Check Depth (Warning), Else -&gt; Check 2.70
        check_formula = (
            f&#39;=IF(B{r_rept}=&#34;PRE-BALLAST&#34;, &#34;CHECK DEPTH&#34;, &#39;
            f&#39;IF(MAX(D{r_rept},E{r_rept})&lt;=$B$5, &#34;OK&#34;, &#34;OVER DRAFT&#34;))&#39;
        )
        ws.cell(row=r_rept, column=6, value=check_formula)

        # G: Freeboard (Phys_Freeboard_m from RORO sheet Z column)
        ws.cell(row=r_rept, column=7, value=f&#34;=&#39;{roro_sheet}&#39;!Z{r_str}&#34;)
        ws.cell(row=r_rept, column=7).number_format = &#34;0.00&#34;

        # H: Deck Check (Freeboard vs 0.28)
        ws.cell(
            row=r_rept, column=8, value=f&#39;=IF(G{r_rept}&gt;=$B$6, &#34;OK&#34;, &#34;SUBMERGED/LOW&#34;)&#39;
        )

        # I: Action / Note (From RORO G column - Explanation)
        ws.cell(row=r_rept, column=9, value=f&#34;=&#39;{roro_sheet}&#39;!G{6 + i}&#34;)
        ws.cell(row=r_rept, column=9).alignment = styles[&#34;left_align&#34;]

        # Formatting (Colors for Critical Stages)
        # Conditional Formatting logic is hard in openpyxl, so we use static logic if possible or just row styling
        if &#34;PreBallast&#34; in stage_name or &#34;Critical&#34; in stage_name:
            for c in range(1, 10):
                ws.cell(row=r_rept, column=c).fill = styles[
                    &#34;input_fill&#34;
                ]  # Yellow highlight

        # Borders
        for c in range(1, 10):
            ws.cell(row=r_rept, column=c).border = Border(bottom=styles[&#34;thin_border&#34;])

    # Column Widths
    ws.column_dimensions[&#34;A&#34;].width = 25
    ws.column_dimensions[&#34;B&#34;].width = 15
    ws.column_dimensions[&#34;F&#34;].width = 15
    ws.column_dimensions[&#34;H&#34;].width = 15
    ws.column_dimensions[&#34;I&#34;].width = 50

    print(&#34;  [OK] OPERATION SUMMARY sheet updated (DAS Method Specialized)&#34;)</code></pre>
</details>
<div class="desc"><p>Creates the OPERATION SUMMARY sheet summary.
Updated for v4.3: DAS Method &amp; Critical Checkpoints Highlight.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_const_tanks_sheet"><code class="name flex">
<span>def <span class="ident">create_const_tanks_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook, const_rows=None, meta=None) ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_const_tanks_sheet(wb: Workbook, const_rows=None, meta=None) -&gt; Worksheet:
    &#34;&#34;&#34;CONST_TANKS 시트 생성 - Permanent Loads (Fuel/FreshWater)

    Patch Option B-2: 실측 Const Tank Total 연동을 위한 시트 (CSV 지원)

    이 시트는 모든 Stage 계산의 기초가 되는 고정 하중(Fuel 및 FreshWater)과
    FSM(Free Surface Moment)을 관리합니다. PATCH.MD Option B 정밀도 패치의 핵심입니다.

    시트 구조:
      - Row 3: 헤더 (Tank, Type, Weight_t, LCG_m, FSM_mt_m, Remarks)
      - Row 4-11: 8개 탱크 데이터
        * DO.P/S: Fuel, 3.05t each, FSM 0.34 t·m each
        * LRFO.P/S: Fuel, 154.89t each, FSM 133.89 t·m each
        * FW1.P/S: FreshWater, 23.16t each, FSM 1.15 t·m each
        * FW2.P/S: FreshWater, 13.92t each, FSM 3.71 t·m each
      - Row 13: 합계 수식
        * C13: =SUM(C4:C11) → Total Weight
        * E13: =SUM(E4:E11) → Total FSM

    데이터 소스:
      - CSV 파일 (--const-csv 옵션 사용 시)
      - 하드코딩 기본값 (CSV 없을 경우)

    참조 관계:
      - CAPTAIN_REPORT AD열: =CONST_TANKS!$C$13 + L + B (Total Displacement)
      - CAPTAIN_REPORT AS열: =U - CONST_TANKS!$E$13 / AD (GM_eff)
      - RORO_Stage_Scenarios AD열: =CONST_TANKS!$C$13 (Base Weight)
      - RORO_Stage_Scenarios AS열: =U - CONST_TANKS!$E$13 / AD (GM_eff)
      - solve_stage() params[&#34;Const_FSM_t_m&#34;]: 887.0 (E13 값 사용)

    GM_eff 계산:
      GM_eff = GM - FSM / Displacement
      FSM 값은 CONST_TANKS!E13을 사용합니다.

    Args:
        wb: openpyxl Workbook 객체
        const_rows: CSV에서 로딩한 탱크 데이터 (None이면 기본값 사용)
        meta: CSV 로딩 메타데이터

    Returns:
        Worksheet: 생성된 CONST_TANKS 시트

    See Also:
        - DATA_SOURCE_DOCUMENTATION.md Section 3
        - PATCH.MD for Option B-2 patch requirements
        - load_const_tanks_snapshot() for CSV loading
    &#34;&#34;&#34;
    ws = wb.create_sheet(&#34;CONST_TANKS&#34;)
    styles = get_styles()

    # CSV 데이터가 없으면 기본 하드코딩 데이터 로딩
    if const_rows is None:
        const_rows, meta = load_const_tanks_snapshot()

    # 헤더 작성 (row 3)
    headers = [&#34;Tank&#34;, &#34;Type&#34;, &#34;Weight_t&#34;, &#34;LCG_m&#34;, &#34;FSM_mt_m&#34;, &#34;Remarks&#34;]
    for c, h in enumerate(headers, start=1):
        cell = ws.cell(row=3, column=c, value=h)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]
        cell.border = Border(
            left=styles[&#34;thin_border&#34;],
            right=styles[&#34;thin_border&#34;],
            top=styles[&#34;thin_border&#34;],
            bottom=styles[&#34;thin_border&#34;],
        )

    # 데이터 행 작성 (row 4부터) - CSV 또는 기본 하드코딩 데이터 사용
    r = 4
    for row_data in const_rows:
        t = row_data[&#34;tank&#34;]
        tp = row_data[&#34;type&#34;]
        wt = row_data[&#34;weight_t&#34;]
        x = row_data[&#34;lcg_m&#34;]
        fsm = row_data[&#34;fsm_mt_m&#34;]
        rm = row_data.get(&#34;src&#34;, &#34;&#34;)
        ws.cell(r, 1, t).font = styles[&#34;normal_font&#34;]
        ws.cell(r, 2, tp).font = styles[&#34;normal_font&#34;]
        ws.cell(r, 3, wt).font = styles[&#34;normal_font&#34;]
        ws.cell(r, 3).number_format = &#34;0.00&#34;
        ws.cell(r, 4, x).font = styles[&#34;normal_font&#34;]
        ws.cell(r, 4).number_format = &#34;0.00&#34;
        ws.cell(r, 5, fsm).font = styles[&#34;normal_font&#34;]
        ws.cell(r, 5).number_format = &#34;0.00&#34;
        ws.cell(r, 6, rm).font = styles[&#34;normal_font&#34;]

        # 테두리 적용
        for col in range(1, 7):
            ws.cell(r, col).border = Border(
                left=styles[&#34;thin_border&#34;],
                right=styles[&#34;thin_border&#34;],
                top=styles[&#34;thin_border&#34;],
                bottom=styles[&#34;thin_border&#34;],
            )
        r += 1

    # 제목 및 합계
    ws[&#34;B1&#34;] = &#34;CONST_TANKS – Permanent Loads (Fuel/FW)&#34;
    ws[&#34;B1&#34;].font = styles[&#34;title_font&#34;]
    ws[&#34;B1&#34;].fill = styles[&#34;header_fill&#34;]

    # 레이블 (row 12, 데이터는 row 4-11)
    ws[&#34;C12&#34;] = &#34;Total Weight [t]&#34;
    ws[&#34;C12&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;E12&#34;] = &#34;Total FSM [mt·m]&#34;
    ws[&#34;E12&#34;].font = styles[&#34;header_font&#34;]

    # 합계 수식 (row 13, 실제 데이터는 4-11행) - 순환 참조 방지
    ws[&#34;C13&#34;] = &#34;=SUM(C4:C11)&#34;  # Const Total Weight t
    ws[&#34;C13&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;C13&#34;].number_format = &#34;0.00&#34;
    ws[&#34;C13&#34;].fill = styles[&#34;input_fill&#34;]

    ws[&#34;E13&#34;] = &#34;=SUM(E4:E11)&#34;  # Const Total FSM mt·m
    ws[&#34;E13&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;E13&#34;].number_format = &#34;0.00&#34;
    ws[&#34;E13&#34;].fill = styles[&#34;input_fill&#34;]

    # 컬럼 폭 설정
    ws.column_dimensions[&#34;A&#34;].width = 12
    ws.column_dimensions[&#34;B&#34;].width = 15
    ws.column_dimensions[&#34;C&#34;].width = 12
    ws.column_dimensions[&#34;D&#34;].width = 12
    ws.column_dimensions[&#34;E&#34;].width = 12
    ws.column_dimensions[&#34;F&#34;].width = 15

    # 로그 출력
    if meta and meta.get(&#34;used_csv&#34;):
        matched = meta.get(&#34;matched_count&#34;, 0)
        total = meta.get(&#34;total_tanks&#34;, len(const_rows))
        print(
            f&#34;  [OK] CONST_TANKS sheet created (Patch Option B-2: CSV {matched}/{total} tanks)&#34;
        )
    else:
        print(&#34;  [OK] CONST_TANKS sheet created (Patch Option B: Default values)&#34;)

    return ws</code></pre>
</details>
<div class="desc"><p>CONST_TANKS 시트 생성 - Permanent Loads (Fuel/FreshWater)</p>
<p>Patch Option B-2: 실측 Const Tank Total 연동을 위한 시트 (CSV 지원)</p>
<p>이 시트는 모든 Stage 계산의 기초가 되는 고정 하중(Fuel 및 FreshWater)과
FSM(Free Surface Moment)을 관리합니다. PATCH.MD Option B 정밀도 패치의 핵심입니다.</p>
<p>시트 구조:
- Row 3: 헤더 (Tank, Type, Weight_t, LCG_m, FSM_mt_m, Remarks)
- Row 4-11: 8개 탱크 데이터
* DO.P/S: Fuel, 3.05t each, FSM 0.34 t·m each
* LRFO.P/S: Fuel, 154.89t each, FSM 133.89 t·m each
* FW1.P/S: FreshWater, 23.16t each, FSM 1.15 t·m each
* FW2.P/S: FreshWater, 13.92t each, FSM 3.71 t·m each
- Row 13: 합계 수식
* C13: =SUM(C4:C11) → Total Weight
* E13: =SUM(E4:E11) → Total FSM</p>
<p>데이터 소스:
- CSV 파일 (&ndash;const-csv 옵션 사용 시)
- 하드코딩 기본값 (CSV 없을 경우)</p>
<p>참조 관계:
- CAPTAIN_REPORT AD열: =CONST_TANKS!$C$13 + L + B (Total Displacement)
- CAPTAIN_REPORT AS열: =U - CONST_TANKS!$E$13 / AD (GM_eff)
- RORO_Stage_Scenarios AD열: =CONST_TANKS!$C$13 (Base Weight)
- RORO_Stage_Scenarios AS열: =U - CONST_TANKS!$E$13 / AD (GM_eff)
- solve_stage() params["Const_FSM_t_m"]: 887.0 (E13 값 사용)</p>
<p>GM_eff 계산:
GM_eff = GM - FSM / Displacement
FSM 값은 CONST_TANKS!E13을 사용합니다.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wb</code></strong></dt>
<dd>openpyxl Workbook 객체</dd>
<dt><strong><code>const_rows</code></strong></dt>
<dd>CSV에서 로딩한 탱크 데이터 (None이면 기본값 사용)</dd>
<dt><strong><code>meta</code></strong></dt>
<dd>CSV 로딩 메타데이터</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Worksheet</code></dt>
<dd>생성된 CONST_TANKS 시트</dd>
</dl>
<p>See Also:
- DATA_SOURCE_DOCUMENTATION.md Section 3
- PATCH.MD for Option B-2 patch requirements
- load_const_tanks_snapshot() for CSV loading</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_csm_trace_sheet"><code class="name flex">
<span>def <span class="ident">create_csm_trace_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>csm_trace: dict,<br>sheet_name: str = 'CSM_Trace') ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_csm_trace_sheet(
    wb: Workbook, csm_trace: dict, sheet_name: str = &#34;CSM_Trace&#34;
) -&gt; Worksheet:
    ws = (
        wb.create_sheet(sheet_name)
        if sheet_name not in wb.sheetnames
        else wb[sheet_name]
    )
    styles = get_styles()
    ws[&#34;A1&#34;] = &#34;CSM Traceability – Inputs used for securing (CSS Code / CSM)&#34;
    ws[&#34;A1&#34;].font = styles[&#34;title_font&#34;]

    ws[&#34;A3&#34;] = &#34;Available&#34;
    ws[&#34;B3&#34;] = &#34;Y&#34; if csm_trace.get(&#34;available&#34;) else &#34;N&#34;
    ws[&#34;A4&#34;] = &#34;Basis&#34;
    ws[&#34;B4&#34;] = csm_trace.get(&#34;basis&#34;, &#34;&#34;)
    ws[&#34;A5&#34;] = &#34;Missing&#34;
    ws[&#34;B5&#34;] = csm_trace.get(&#34;missing&#34;, &#34;&#34;)

    headers = [&#34;id&#34;, &#34;type&#34;, &#34;wll_t&#34;, &#34;qty&#34;, &#34;remarks&#34;]
    for c, h in enumerate(headers, start=1):
        cell = ws.cell(row=7, column=c, value=h)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]

    r = 8
    items = csm_trace.get(&#34;items&#34;) or []
    for it in items:
        ws.cell(r, 1, it.get(&#34;id&#34;, &#34;&#34;))
        ws.cell(r, 2, it.get(&#34;type&#34;, &#34;&#34;))
        v = _as_float(it.get(&#34;wll_t&#34;))
        if v is not None:
            ws.cell(r, 3, float(v)).number_format = &#34;#,##0.00&#34;
        ws.cell(r, 4, it.get(&#34;qty&#34;, &#34;&#34;))
        ws.cell(r, 5, it.get(&#34;remarks&#34;, &#34;&#34;))
        r += 1

    ws.freeze_panes = &#34;A8&#34;
    ws.column_dimensions[&#34;A&#34;].width = 14
    ws.column_dimensions[&#34;B&#34;].width = 18
    ws.column_dimensions[&#34;E&#34;].width = 60
    return ws</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_frame_table_sheet"><code class="name flex">
<span>def <span class="ident">create_frame_table_sheet</span></span>(<span>wb)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_frame_table_sheet(wb):
    &#34;&#34;&#34;Frame_to_x_Table 시트 생성&#34;&#34;&#34;
    ws = wb.create_sheet(&#34;Frame_to_x_Table&#34;)
    styles = get_styles()

    headers = [&#34;Fr&#34;, &#34;x_from_mid_m&#34;, &#34;비고&#34;]
    for c, h in enumerate(headers, 1):
        cell = ws.cell(row=1, column=c, value=h)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]
        cell.border = Border(
            left=styles[&#34;thin_border&#34;],
            right=styles[&#34;thin_border&#34;],
            top=styles[&#34;thin_border&#34;],
            bottom=styles[&#34;thin_border&#34;],
        )

    # JSON 파일 로드 (상대 경로 사용)
    frame_data = _load_json(&#34;data/Frame_x_from_mid_m.json&#34;)

    if frame_data:
        try:
            # frame_data가 리스트인지 확인
            if isinstance(frame_data, list):
                for idx, entry in enumerate(frame_data, start=0):
                    row = 2 + idx

                    cell_a = ws.cell(row=row, column=1)
                    cell_a.value = entry.get(&#34;Fr&#34;, 0.0)
                    cell_a.font = styles[&#34;normal_font&#34;]
                    cell_a.number_format = &#34;0.00&#34;

                    cell_b = ws.cell(row=row, column=2)
                    cell_b.value = entry.get(&#34;x_from_mid_m&#34;, 0.0)
                    cell_b.font = styles[&#34;normal_font&#34;]
                    cell_b.number_format = &#34;0.00&#34;

                    cell_c = ws.cell(row=row, column=3)
                    cell_c.value = entry.get(&#34;비고&#34;, &#34;&#34;)
                    cell_c.font = styles[&#34;normal_font&#34;]

                print(
                    f&#34;  [OK] Frame_to_x_Table sheet created with {len(frame_data)} rows&#34;
                )
            else:
                print(f&#34;  [WARNING] Frame data is not a list. Creating empty sheet.&#34;)
        except Exception as e:
            print(
                f&#34;  [WARNING] Error processing frame data: {e}. Creating empty sheet.&#34;
            )
            frame_data = None

    if not frame_data:
        print(
            f&#34;  [WARNING] JSON file not found. Creating empty Frame_to_x_Table sheet.&#34;
        )
        for row in range(2, 123):  # 121 rows + header
            ws.cell(row=row, column=1).font = styles[&#34;normal_font&#34;]
            ws.cell(row=row, column=1).number_format = &#34;0.00&#34;
            ws.cell(row=row, column=2).font = styles[&#34;normal_font&#34;]
            ws.cell(row=row, column=2).number_format = &#34;0.00&#34;
            ws.cell(row=row, column=3).font = styles[&#34;normal_font&#34;]

    ws.column_dimensions[&#34;A&#34;].width = 12
    ws.column_dimensions[&#34;B&#34;].width = 15
    ws.column_dimensions[&#34;C&#34;].width = 20</code></pre>
</details>
<div class="desc"><p>Frame_to_x_Table 시트 생성</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_hourly_sheet"><code class="name flex">
<span>def <span class="ident">create_hourly_sheet</span></span>(<span>wb)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_hourly_sheet(wb):
    &#34;&#34;&#34;Hourly_FWD_AFT_Heights 시트 생성&#34;&#34;&#34;
    ws = wb.create_sheet(&#34;Hourly_FWD_AFT_Heights&#34;)
    styles = get_styles()

    headers = [
        &#34;DateTime (GST)&#34;,
        &#34;Tide_m&#34;,
        &#34;Dfwd_req_m (even)&#34;,
        &#34;Trim_m (optional)&#34;,
        &#34;Dfwd_adj_m&#34;,
        &#34;Daft_adj_m&#34;,
        &#34;Ramp_Angle_deg&#34;,
        &#34;Status&#34;,
        &#34;FWD_Height_m&#34;,
        &#34;AFT_Height_m&#34;,
        &#34;Notes&#34;,
        &#34;&#34;,
        &#34;Trim_m (optional)&#34;,
        &#34;&#34;,
    ]
    for col_idx, header in enumerate(headers, start=1):
        cell = ws.cell(row=1, column=col_idx)
        cell.value = header if header else &#34;&#34;
        if header:
            cell.font = styles[&#34;header_font&#34;]
            cell.fill = styles[&#34;header_fill&#34;]
            cell.alignment = styles[&#34;center_align&#34;]
            cell.border = Border(
                left=styles[&#34;thin_border&#34;],
                right=styles[&#34;thin_border&#34;],
                top=styles[&#34;thin_border&#34;],
                bottom=styles[&#34;thin_border&#34;],
            )

    for row in range(2, 746):
        row_str = str(row)
        ws.cell(row=row, column=1).value = (
            f&#39;=IF(December_Tide_2025!A{row_str}=&#34;&#34;,&#34;&#34;,December_Tide_2025!A{row_str})&#39;
        )
        ws.cell(row=row, column=2).value = (
            f&#39;=IF(December_Tide_2025!B{row_str}=&#34;&#34;,&#34;&#34;,December_Tide_2025!B{row_str})&#39;
        )
        ws.cell(row=row, column=3).value = (
            f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;, &#39;
            f&#39;INDEX(Calc!$E:$E, MATCH(&#34;KminusZ_m&#34;, Calc!$C:$C, 0)) + $B{row_str} - &#39;
            f&#39;INDEX(Calc!$E:$E, MATCH(&#34;L_ramp_m&#34;, Calc!$C:$C, 0)) * &#39;
            f&#39;TAN(RADIANS(INDEX(Calc!$E:$E, MATCH(&#34;theta_max_deg&#34;, Calc!$C:$C, 0)))))&#39;
        )
        ws.cell(row=row, column=5).value = (
            f&#39;=IF($C{row_str}=&#34;&#34;,&#34;&#34;, IF($D{row_str}=&#34;&#34;, $C{row_str}, $C{row_str} - $D{row_str}/2))&#39;
        )
        ws.cell(row=row, column=6).value = (
            f&#39;=IF($C{row_str}=&#34;&#34;,&#34;&#34;, IF($D{row_str}=&#34;&#34;, $C{row_str}, $C{row_str} + $D{row_str}/2))&#39;
        )
        ws.cell(row=row, column=7).value = (
            f&#39;=IF($E{row_str}=&#34;&#34;,&#34;&#34;, &#39;
            f&#39;DEGREES(ATAN((INDEX(Calc!$E:$E, MATCH(&#34;KminusZ_m&#34;, Calc!$C:$C, 0)) - $E{row_str} + $B{row_str}) / &#39;
            f&#39;INDEX(Calc!$E:$E, MATCH(&#34;L_ramp_m&#34;, Calc!$C:$C, 0)))))&#39;
        )
        ws.cell(row=row, column=8).value = (
            f&#39;=IF($E{row_str}=&#34;&#34;,&#34;&#34;, &#39;
            f&#39;IF(AND($E{row_str}&gt;=INDEX(Calc!$E:$E, MATCH(&#34;min_fwd_draft_m&#34;, Calc!$C:$C, 0)), &#39;
            f&#39;$E{row_str}&lt;=INDEX(Calc!$E:$E, MATCH(&#34;max_fwd_draft_m&#34;, Calc!$C:$C, 0)), &#39;
            f&#39;$G{row_str}&lt;=INDEX(Calc!$E:$E, MATCH(&#34;theta_max_deg&#34;, Calc!$C:$C, 0))), &#34;OK&#34;, &#34;CHECK&#34;))&#39;
        )
        ws.cell(row=row, column=9).value = (
            f&#39;=IF($E{row_str}=&#34;&#34;,&#34;&#34;, &#39;
            f&#39;INDEX(Calc!$E:$E, MATCH(&#34;D_vessel_m&#34;, Calc!$C:$C, 0)) - $E{row_str} + $B{row_str})&#39;
        )
        ws.cell(row=row, column=10).value = (
            f&#39;=IF($F{row_str}=&#34;&#34;,&#34;&#34;, &#39;
            f&#39;INDEX(Calc!$E:$E, MATCH(&#34;D_vessel_m&#34;, Calc!$C:$C, 0)) - $F{row_str} + $B{row_str})&#39;
        )
        ws.cell(row=row, column=11).value = f&#39;=IF(D{row_str}=0, &#34;Even Keel&#34;, &#34;&#34;)&#39;

        if row == 2:
            ws.cell(row=row, column=14).value = (
                &#34;← Defaults to 0.00 (Even-Keel). To apply the actual trim, manually enter the value in this cell.&#34;
            )
            ws.cell(row=row, column=14).font = styles[&#34;normal_font&#34;]

        ws.cell(row=row, column=2).number_format = &#34;0.00&#34;
        ws.cell(row=row, column=3).number_format = &#34;0.00&#34;
        ws.cell(row=row, column=4).number_format = &#34;0.00&#34;
        ws.cell(row=row, column=5).number_format = &#34;0.00&#34;
        ws.cell(row=row, column=6).number_format = &#34;0.00&#34;
        ws.cell(row=row, column=7).number_format = &#34;0.00&#34;
        ws.cell(row=row, column=9).number_format = &#34;0.00&#34;
        ws.cell(row=row, column=10).number_format = &#34;0.00&#34;

        for col in range(1, 12):
            ws.cell(row=row, column=col).font = styles[&#34;normal_font&#34;]

    ws.column_dimensions[&#34;A&#34;].width = 20
    ws.column_dimensions[&#34;B&#34;].width = 12
    ws.column_dimensions[&#34;C&#34;].width = 15
    ws.column_dimensions[&#34;D&#34;].width = 12
    ws.column_dimensions[&#34;E&#34;].width = 15
    ws.column_dimensions[&#34;F&#34;].width = 15
    ws.column_dimensions[&#34;G&#34;].width = 18
    ws.column_dimensions[&#34;H&#34;].width = 12
    ws.column_dimensions[&#34;I&#34;].width = 15
    ws.column_dimensions[&#34;J&#34;].width = 15
    ws.column_dimensions[&#34;K&#34;].width = 15
    ws.column_dimensions[&#34;L&#34;].width = 12
    ws.column_dimensions[&#34;M&#34;].width = 12
    ws.column_dimensions[&#34;N&#34;].width = 80

    print(f&#34;  [OK] Hourly_FWD_AFT_Heights sheet created&#34;)</code></pre>
</details>
<div class="desc"><p>Hourly_FWD_AFT_Heights 시트 생성</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_hydro_table_sheet"><code class="name flex">
<span>def <span class="ident">create_hydro_table_sheet</span></span>(<span>wb)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_hydro_table_sheet(wb):
    &#34;&#34;&#34;Hydro_Table 시트 생성 (Option B ready: LCF/MCTC/TPC/GM_min optional)&#34;&#34;&#34;
    ws = wb.create_sheet(&#34;Hydro_Table&#34;)
    styles = get_styles()

    # Base headers (Option B). Only keys present in JSON will be shown; unknown keys appended at the end.
    base_headers = [
        &#34;Disp_t&#34;,
        &#34;Tmean_m&#34;,
        &#34;Trim_m&#34;,
        &#34;GM_m&#34;,
        &#34;Draft_FWD&#34;,
        &#34;Draft_AFT&#34;,
        # Option B recommended (approved booklet / NAPA export)
        &#34;LCF_m_from_midship&#34;,  # x_from_mid_m, AFT=+
        &#34;MCTC_t_m_per_cm&#34;,  # (alias: MTC_t_m_per_cm)
        &#34;TPC_t_per_cm&#34;,
        &#34;GM_min_m&#34;,  # optional curve point
    ]
    headers = base_headers

    # Note:
    # - Trim_m column (if present) is reference-only. Stage trim is derived from TM/MCTC.
    # - For Engineering-grade, provide LCF/MCTC/TPC vs draft in the same hydro table.
    json_data = _load_hydro_table()
    data = []

    if json_data and isinstance(json_data, list) and len(json_data) &gt; 0:
        if isinstance(json_data[0], dict):
            existing = list(json_data[0].keys())

            # map common aliases into canonical keys (if present in JSON)
            alias_map = {
                &#34;MTC_t_m_per_cm&#34;: &#34;MCTC_t_m_per_cm&#34;,
                &#34;MTC&#34;: &#34;MCTC_t_m_per_cm&#34;,
                &#34;TPC&#34;: &#34;TPC_t_per_cm&#34;,
                &#34;LCF&#34;: &#34;LCF_m_from_midship&#34;,
                &#34;LCF_from_mid_m&#34;: &#34;LCF_m_from_midship&#34;,
            }

            # normalize each entry into a new dict (do not mutate original)
            norm_rows = []
            for entry in json_data:
                if not isinstance(entry, dict):
                    continue
                e = dict(entry)
                for k_src, k_dst in alias_map.items():
                    if k_src in e and k_dst not in e:
                        e[k_dst] = e.get(k_src)
                norm_rows.append(e)

            if norm_rows:
                existing_norm = list(norm_rows[0].keys())
                headers = [h for h in base_headers if h in existing_norm]
                extras = [k for k in existing_norm if k not in headers]
                headers += extras

                for entry in norm_rows:
                    data.append([entry.get(h, &#34;&#34;) for h in headers])

            print(
                f&#34;  [OK] Hydro_Table loaded ({len(data)} points), columns={len(headers)}&#34;
            )
        else:
            # already in array format
            data = json_data
            print(f&#34;  [OK] Hydro_Table loaded (array, {len(data)} rows)&#34;)
    else:
        # fallback points (legacy) - only base part
        print(&#34;  [FALLBACK] Using built-in 4 points (no JSON hydro table found)&#34;)
        headers = [&#34;Disp_t&#34;, &#34;Tmean_m&#34;, &#34;Trim_m&#34;, &#34;GM_m&#34;, &#34;Draft_FWD&#34;, &#34;Draft_AFT&#34;]
        data = [
            [2991.25, 2.20, 0.20, 2.85, 2.10, 2.30],
            [3208.25, 3.18, -0.53, 1.68, 2.92, 3.45],
            [3265.25, 3.00, 0.60, 1.88, 2.68, 3.28],
            [3425.25, 3.00, 0.70, 1.85, 2.65, 3.35],
        ]

    # header row styling
    for c, h in enumerate(headers, 1):
        cell = ws.cell(row=1, column=c, value=h)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]
        cell.border = Border(
            left=styles[&#34;thin_border&#34;],
            right=styles[&#34;thin_border&#34;],
            top=styles[&#34;thin_border&#34;],
            bottom=styles[&#34;thin_border&#34;],
        )

    # sort by Tmean_m if possible (VLOOKUP approximate requires ascending)
    try:
        tmean_idx = headers.index(&#34;Tmean_m&#34;)
    except ValueError:
        tmean_idx = 1  # legacy

    def _sort_key(row):
        try:
            v = row[tmean_idx]
            if isinstance(v, str) and v.strip() == &#34;&#34;:
                return 0.0
            return float(v)
        except Exception:
            return 0.0

    data_sorted = sorted(data, key=_sort_key)

    # data rows
    for r, row_data in enumerate(data_sorted, 2):
        for c, val in enumerate(row_data, 1):
            cell = ws.cell(row=r, column=c, value=val)
            cell.number_format = &#34;0.00&#34;
            cell.alignment = styles[&#34;center_align&#34;]
            cell.border = Border(
                left=styles[&#34;thin_border&#34;],
                right=styles[&#34;thin_border&#34;],
                top=styles[&#34;thin_border&#34;],
                bottom=styles[&#34;thin_border&#34;],
            )

    # column widths (simple)
    for col in range(1, len(headers) + 1):
        ws.column_dimensions[get_column_letter(col)].width = 14</code></pre>
</details>
<div class="desc"><p>Hydro_Table 시트 생성 (Option B ready: LCF/MCTC/TPC/GM_min optional)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_index_match_formula"><code class="name flex">
<span>def <span class="ident">create_index_match_formula</span></span>(<span>lookup_value, lookup_range, return_range)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_index_match_formula(lookup_value, lookup_range, return_range):
    &#34;&#34;&#34;INDEX/MATCH 조합 수식 생성&#34;&#34;&#34;
    return f&#39;=INDEX({return_range}, MATCH(&#34;{lookup_value}&#34;, {lookup_range}, 0))&#39;</code></pre>
</details>
<div class="desc"><p>INDEX/MATCH 조합 수식 생성</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_iscode_check_sheet"><code class="name flex">
<span>def <span class="ident">create_iscode_check_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>stage_results: dict,<br>sheet_name: str = 'RORO_ISCODE_Check') ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_iscode_check_sheet(
    wb: Workbook, stage_results: dict, sheet_name: str = &#34;RORO_ISCODE_Check&#34;
) -&gt; Worksheet:
    &#34;&#34;&#34;RORO_ISCODE_Check 시트 생성 - IMO IS Code 2008 일반 기준 검증

    이 시트는 각 Stage별로 IMO IS Code 2008 일반 기준을 검증합니다.
    GZ curve 기반으로 6개 기준을 검증하며, 모든 기준을 통과해야 PASS입니다.

    데이터 소스:
      1. stage_results[&#39;BPLUS&#39;][&#39;ISCODE&#39;]:
         - available: GZ curve 사용 가능 여부
         - pass: 전체 기준 통과 여부
         - area_0_30_mrad: 0-30도 면적 (m·rad)
         - area_0_40_mrad: 0-40도 면적
         - area_30_40_mrad: 30-40도 면적
         - gz_max_m: 최대 GZ (m)
         - gz_max_angle_deg: 최대 GZ 각도
         - stable_range_deg: 복원 범위

      2. GZ Curve 파일:
         - 위치: data/GZ/*.json
         - 형식: {&#34;stage_id&#34;: &#34;...&#34;, &#34;points&#34;: [{&#34;heel_deg&#34;: 0, &#34;gz_m&#34;: 0}, ...]}
         - 로딩: _load_gz_curve(stage_id) (L1019)
         - Dual naming 지원: 공백 포함 원본 형식 및 언더스코어 형식 모두 지원

    검증 기준 (IMO IS Code 2008):
      - Area 0-30°: ≥ 3.151 m·rad
      - Area 0-40°: ≥ 5.157 m·rad
      - Area 30-40°: ≥ 1.719 m·rad
      - GZ_max: ≥ 0.20 m
      - Angle at GZ_max: ≥ 25°
      - GM: ≥ 0.15 m

    시트 구조:
      - Row 3: 헤더 (Stage, Available, PASS, A0-30, A0-40, A30-40, GZmax, Ang@GZmax, StableRange, Basis/Missing)
      - Row 4+: 각 Stage별 검증 결과

    Args:
        wb: openpyxl Workbook 객체
        stage_results: Stage별 계산 결과 딕셔너리
            - 각 Stage의 &#39;BPLUS&#39; 키에 &#39;ISCODE&#39; 데이터 포함
        sheet_name: 시트 이름, 기본값 &#34;RORO_ISCODE_Check&#34;

    Returns:
        Worksheet: 생성된 RORO_ISCODE_Check 시트

    See Also:
        - DATA_SOURCE_DOCUMENTATION.md Section 5.1
        - _load_gz_curve() for GZ curve loading
        - FINAL_VERIFICATION_SUMMARY.md for validation results
    &#34;&#34;&#34;
    ws = (
        wb.create_sheet(sheet_name)
        if sheet_name not in wb.sheetnames
        else wb[sheet_name]
    )
    styles = get_styles()
    ws[&#34;A1&#34;] = &#34;IS Code (2008) – General Criteria Check (GZ-based)&#34;
    ws[&#34;A1&#34;].font = styles[&#34;title_font&#34;]

    headers = [
        &#34;Stage&#34;,
        &#34;Available&#34;,
        &#34;PASS&#34;,
        &#34;A0-30 (m-rad)&#34;,
        &#34;A0-40 (m-rad)&#34;,
        &#34;A30-40 (m-rad)&#34;,
        &#34;GZmax (m)&#34;,
        &#34;Ang@GZmax (deg)&#34;,
        &#34;StableRange (deg)&#34;,
        &#34;Basis/Missing&#34;,
    ]
    for c, h in enumerate(headers, start=1):
        cell = ws.cell(row=3, column=c, value=h)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]

    r = 4
    nf = &#34;#,##0.00&#34;
    for stage_id, res in stage_results.items():
        iscode = (res.get(&#34;BPLUS&#34;) or {}).get(&#34;ISCODE&#34;) or {}
        avail = bool(iscode.get(&#34;available&#34;))
        passed = bool(iscode.get(&#34;pass&#34;)) if avail else False
        ws.cell(r, 1, stage_id)
        ws.cell(r, 2, &#34;Y&#34; if avail else &#34;N&#34;)
        ws.cell(r, 3, &#34;PASS&#34; if passed else &#34;FAIL&#34;)
        for j, k in enumerate(
            [
                &#34;area_0_30_mrad&#34;,
                &#34;area_0_40_mrad&#34;,
                &#34;area_30_40_mrad&#34;,
                &#34;gz_max_m&#34;,
                &#34;gz_max_angle_deg&#34;,
                &#34;stable_range_deg&#34;,
            ],
            start=4,
        ):
            v = _as_float(iscode.get(k))
            if v is not None:
                ws.cell(r, j, float(v)).number_format = nf
            else:
                ws.cell(r, j, &#34;&#34;)
        basis = iscode.get(&#34;basis&#34;, &#34;&#34;)
        missing = iscode.get(&#34;missing&#34;, &#34;&#34;)
        ws.cell(r, 10, basis if basis != &#34;missing&#34; else missing)
        r += 1

    ws.freeze_panes = &#34;A4&#34;
    ws.column_dimensions[&#34;A&#34;].width = 26
    return ws</code></pre>
</details>
<div class="desc"><p>RORO_ISCODE_Check 시트 생성 - IMO IS Code 2008 일반 기준 검증</p>
<p>이 시트는 각 Stage별로 IMO IS Code 2008 일반 기준을 검증합니다.
GZ curve 기반으로 6개 기준을 검증하며, 모든 기준을 통과해야 PASS입니다.</p>
<p>데이터 소스:
1. stage_results['BPLUS']['ISCODE']:
- available: GZ curve 사용 가능 여부
- pass: 전체 기준 통과 여부
- area_0_30_mrad: 0-30도 면적 (m·rad)
- area_0_40_mrad: 0-40도 면적
- area_30_40_mrad: 30-40도 면적
- gz_max_m: 최대 GZ (m)
- gz_max_angle_deg: 최대 GZ 각도
- stable_range_deg: 복원 범위</p>
<ol>
<li>GZ Curve 파일:<ul>
<li>위치: data/GZ/*.json</li>
<li>형식: {"stage_id": "&hellip;", "points": [{"heel_deg": 0, "gz_m": 0}, &hellip;]}</li>
<li>로딩: _load_gz_curve(stage_id) (L1019)</li>
<li>Dual naming 지원: 공백 포함 원본 형식 및 언더스코어 형식 모두 지원</li>
</ul>
</li>
</ol>
<p>검증 기준 (IMO IS Code 2008):
- Area 0-30°: ≥ 3.151 m·rad
- Area 0-40°: ≥ 5.157 m·rad
- Area 30-40°: ≥ 1.719 m·rad
- GZ_max: ≥ 0.20 m
- Angle at GZ_max: ≥ 25°
- GM: ≥ 0.15 m</p>
<p>시트 구조:
- Row 3: 헤더 (Stage, Available, PASS, A0-30, A0-40, A30-40, GZmax, Ang@GZmax, StableRange, Basis/Missing)
- Row 4+: 각 Stage별 검증 결과</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wb</code></strong></dt>
<dd>openpyxl Workbook 객체</dd>
<dt><strong><code>stage_results</code></strong></dt>
<dd>Stage별 계산 결과 딕셔너리
- 각 Stage의 'BPLUS' 키에 'ISCODE' 데이터 포함</dd>
<dt><strong><code>sheet_name</code></strong></dt>
<dd>시트 이름, 기본값 "RORO_ISCODE_Check"</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Worksheet</code></dt>
<dd>생성된 RORO_ISCODE_Check 시트</dd>
</dl>
<p>See Also:
- DATA_SOURCE_DOCUMENTATION.md Section 5.1
- _load_gz_curve() for GZ curve loading
- FINAL_VERIFICATION_SUMMARY.md for validation results</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_mws_pack_index_sheet"><code class="name flex">
<span>def <span class="ident">create_mws_pack_index_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook, sheet_name: str = 'MWS_Pack_Index') ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_mws_pack_index_sheet(
    wb: Workbook, sheet_name: str = &#34;MWS_Pack_Index&#34;
) -&gt; Worksheet:
    ws = (
        wb.create_sheet(sheet_name)
        if sheet_name not in wb.sheetnames
        else wb[sheet_name]
    )
    styles = get_styles()
    ws[&#34;A1&#34;] = &#34;MWS-ready Pack Index (B+) – Evidence &amp; Submittals Checklist&#34;
    ws[&#34;A1&#34;].font = styles[&#34;title_font&#34;]
    ws[&#34;A3&#34;] = &#34;Item&#34;
    ws[&#34;B3&#34;] = &#34;Owner&#34;
    ws[&#34;C3&#34;] = &#34;Status&#34;
    ws[&#34;D3&#34;] = &#34;Remarks / Where to attach&#34;
    for c in [&#34;A3&#34;, &#34;B3&#34;, &#34;C3&#34;, &#34;D3&#34;]:
        ws[c].font = styles[&#34;header_font&#34;]
        ws[c].fill = styles[&#34;header_fill&#34;]
        ws[c].alignment = styles[&#34;center_align&#34;]

    rows = [
        (
            &#34;Approved Stability Booklet / Hydro Tables&#34;,
            &#34;Vessel Owner&#34;,
            &#34;REQ&#34;,
            &#34;Hydro_Table_Engineering.json + GM_Min_Curve.json&#34;,
        ),
        (
            &#34;GZ Curve (per stage) for IS Code check&#34;,
            &#34;Naval Arch.&#34;,
            &#34;REQ&#34;,
            &#34;data/GZ/&lt;stage&gt;.json or data/GZ_Curves.json&#34;,
        ),
        (
            &#34;Cargo Securing Manual (CSM) / Lashing Plan&#34;,
            &#34;3PL / Marine&#34;,
            &#34;REQ&#34;,
            &#34;Securing_Input.json (trace) + drawings&#34;,
        ),
        (
            &#34;Ramp Plate Certificate / Deck Load Chart&#34;,
            &#34;Port / Vessel&#34;,
            &#34;REQ&#34;,
            &#34;Structural_Limits.json + cert scan&#34;,
        ),
        (
            &#34;Method Statement / Operation Manual&#34;,
            &#34;Contractor&#34;,
            &#34;REQ&#34;,
            &#34;Attach in submission pack&#34;,
        ),
        (
            &#34;Weather Window / Alpha factor basis&#34;,
            &#34;MWS&#34;,
            &#34;REQ&#34;,
            &#34;Acceptance_Criteria.json + forecast tie-out&#34;,
        ),
        (
            &#34;Tow / Mooring / Pilotage plan (AGI)&#34;,
            &#34;Marine Ops&#34;,
            &#34;REQ&#34;,
            &#34;Attach drawings + approvals&#34;,
        ),
        (
            &#34;Evidence photos/videos + timestamps&#34;,
            &#34;Marine Ops&#34;,
            &#34;REQ&#34;,
            &#34;15+ photos tagged per site rule&#34;,
        ),
    ]
    r = 4
    for item, owner, status, remarks in rows:
        ws.cell(r, 1, item)
        ws.cell(r, 2, owner)
        ws.cell(r, 3, status)
        ws.cell(r, 4, remarks)
        r += 1

    ws.column_dimensions[&#34;A&#34;].width = 44
    ws.column_dimensions[&#34;B&#34;].width = 16
    ws.column_dimensions[&#34;C&#34;].width = 10
    ws.column_dimensions[&#34;D&#34;].width = 60
    ws.freeze_panes = &#34;A4&#34;
    return ws</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_delta_lever_report_sheet"><code class="name flex">
<span>def <span class="ident">create_roro_delta_lever_report_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>stage_results: Dict[str, Dict[str, float]],<br>trim_target_map: Dict[str, float] | None = None,<br>sheet_name: str = 'RORO_Stage_Scenarios',<br>delta_tm_col: str = 'I') ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_roro_delta_lever_report_sheet(
    wb: Workbook,
    stage_results: Dict[str, Dict[str, float]],
    trim_target_map: Optional[Dict[str, float]] = None,
    sheet_name: str = &#34;RORO_Stage_Scenarios&#34;,
    delta_tm_col: str = &#34;I&#34;,  # 가정: 엑셀 ΔTM_cm_tm 컬럼 (I열)
) -&gt; Worksheet:
    &#34;&#34;&#34;
    RORO_Stage_Scenarios Stage 테이블 기준
    - Python 엔진(Trim_cm, Stage별 Trim_target, MTC, X_ballast, LCF, Lpp)을 사용해
      ΔTM_cm_tm, Lever_arm_m, Ballast_t_calc 를 재계산하고
      엑셀 수식 결과와의 차이를 한눈에 볼 수 있는 리포트 시트를 생성한다.

    비교 포인트:
    - ΔTM_cm_tm (Python vs Excel)
    - |ΔTM_diff| &gt; 0.50 → Flag = &#34;CHECK&#34;, 그 이하면 &#34;OK&#34;

    데이터 소스:
    1. stage_results (Python 계산 결과):
       - create_roro_sheet() 함수 내에서 생성 (L3758-3824)
       - 각 Stage별로 solve_stage() 호출하여 계산된 값
       - 포함 데이터: W_stage_t, x_stage_m, Trim_cm 등
    2. RORO_Stage_Scenarios 시트에서 읽는 전역 파라미터 (L4786-4798):
       - B8: Trim_target_cm (전역)
       - B9: MTC_t_m_per_cm
       - B10: LCF_m_from_midship
       - B14: X_Ballast_from_AP_m
       - B15: Lpp_m
    3. RORO_Stage_Scenarios 시트에서 읽는 Excel 계산값 (L4877-4886):
       - I열 (delta_tm_col): ΔTM_cm_tm (Excel 수식 계산 결과)
       - Stage 이름을 A열에서 찾아 해당 행의 I열 값 읽기
    4. trim_target_map (Stage별 Trim 타깃):
       - TRIM_TARGET_MAP (L4124-4136에서 정의)
       - Stage별 Trim 타깃 값으로 ΔTM 계산에 사용
    &#34;&#34;&#34;
    styles = get_styles()
    number_format = &#34;#,##0.00&#34;

    if sheet_name not in wb.sheetnames:
        print(f&#34;[WARN] 워크북에 시트 &#39;{sheet_name}&#39;가 없습니다. ΔTM/Lever 리포트 생략.&#34;)
        return wb.create_sheet(&#34;RORO_Delta_Lever_Report&#34;)

    ws = wb[sheet_name]

    # ===== 1) 전역 파라미터 (Stage Param 블록에서 값 읽기) =====
    def _safe_float(cell_addr: str, default: float = 0.0) -&gt; float:
        try:
            v = ws[cell_addr].value
            return float(v) if v is not None else default
        except Exception:
            return default

    trim_target_global = _safe_float(&#34;B8&#34;, 0.0)  # Trim_target_cm (전역)
    mtc = _safe_float(&#34;B9&#34;, 0.0)  # MTC_t_m_per_cm
    lcf_from_mid = _safe_float(&#34;B10&#34;, 0.0)  # LCF_m_from_midship
    x_ballast_ap = _safe_float(&#34;B14&#34;, 0.0)  # X_Ballast_from_AP_m
    lpp_m = _safe_float(&#34;B15&#34;, 0.0)  # Lpp_m

    lever_arm_calc = None
    if lpp_m != 0.0:
        lcf_from_ap = lcf_from_mid + lpp_m / 2.0
        lever_arm_calc = round(x_ballast_ap - lcf_from_ap, 2)
    else:
        print(&#34;[WARN] Lpp_m=0.0 이라 Lever_arm 계산 불가.&#34;)

    # Stage별 Trim 타깃 맵 준비
    if trim_target_map is None:
        try:
            trim_target_map = TRIM_TARGET_MAP  # type: ignore[name-defined]
        except NameError:
            trim_target_map = {}

    # ===== 2) 원본 RORO 시트에서 Stage → Row 맵 작성 (엑셀 ΔTM 읽기용) =====
    stage_row_map: Dict[str, int] = {}
    for row in range(1, ws.max_row + 1):
        val = ws.cell(row=row, column=1).value  # A열 (Stage 이름)
        if val is None:
            continue
        name = str(val).strip()
        if name:
            stage_row_map[name] = row

    # ===== 3) 리포트 시트 생성 =====
    report_ws = wb.create_sheet(&#34;RORO_Delta_Lever_Report&#34;)
    report_ws.title = &#34;RORO_Delta_Lever_Report&#34;

    # Title
    title_cell = report_ws[&#34;A1&#34;]
    title_cell.value = &#34;RORO Stage ΔTM &amp; Lever Arm Verification Report&#34;
    title_cell.font = styles[&#34;title_font&#34;]

    report_ws[&#34;A3&#34;].value = (
        &#34;주의: ΔTM(Python) vs ΔTM(Excel) 비교. |ΔTM_diff| &gt; 0.50 → Flag=CHECK.&#34;
    )
    report_ws[&#34;A3&#34;].font = styles[&#34;normal_font&#34;]

    # 헤더 행
    header_row = 5
    headers = [
        &#34;Stage&#34;,
        &#34;W_stage_t&#34;,
        &#34;x_stage_m&#34;,
        &#34;Trim_cm (Python)&#34;,
        &#34;Trim_target_stage_cm&#34;,
        &#34;MTC_t_m_per_cm&#34;,
        &#34;ΔTM_cm_tm (Python)&#34;,
        &#34;ΔTM_cm_tm (Excel)&#34;,
        &#34;ΔTM_diff (Py-XL)&#34;,
        &#34;Flag (|ΔTM_diff|&gt;0.50)&#34;,
        &#34;Lever_arm_m (Python)&#34;,
        &#34;Ballast_t_calc (Python)&#34;,
        &#34;비고&#34;,
    ]
    for col, name in enumerate(headers, start=1):
        c = report_ws.cell(row=header_row, column=col, value=name)
        c.font = styles[&#34;header_font&#34;]
        c.fill = styles[&#34;header_fill&#34;]

    # ===== 4) Stage별 데이터 라인 =====
    current_row = header_row + 1

    for stage_name, res in stage_results.items():
        w_stage = float(res.get(&#34;W_stage_t&#34;, 0.0) or 0.0)
        x_stage = float(res.get(&#34;x_stage_m&#34;, 0.0) or 0.0)
        trim_cm = float(res.get(&#34;Trim_cm&#34;, 0.0) or 0.0)

        target_trim_cm = float(
            (trim_target_map.get(stage_name) if trim_target_map else trim_target_global)
            or trim_target_global
        )

        # ΔTM(Python)
        # PATCH B2-3: Reverse direction to (Target - Actual) to match Excel formula
        delta_tm_py = (target_trim_cm - trim_cm) * mtc if mtc != 0.0 else 0.0

        # ΔTM(Excel)
        excel_row = stage_row_map.get(stage_name)
        delta_tm_xl: Optional[float]
        if excel_row is not None:
            try:
                excel_val = ws[f&#34;{delta_tm_col}{excel_row}&#34;].value
                delta_tm_xl = float(excel_val) if excel_val is not None else None
            except Exception:
                delta_tm_xl = None
        else:
            delta_tm_xl = None

        # ΔTM_diff &amp; Flag
        delta_tm_diff: Optional[float]
        flag = &#34;&#34;
        if delta_tm_xl is not None:
            delta_tm_diff = delta_tm_py - delta_tm_xl
            if abs(delta_tm_diff) &gt; 0.50:
                flag = &#34;CHECK&#34;
            else:
                flag = &#34;OK&#34;
        else:
            delta_tm_diff = None
            flag = &#34;NO_DATA&#34;

        # Lever_arm &amp; Ballast
        if lever_arm_calc not in (None, 0.0):
            ballast_calc = delta_tm_py / lever_arm_calc
        else:
            ballast_calc = 0.0

        row = current_row

        # 공통 숫자 셀 세팅 함수
        def _set_num(col_idx: int, value: Optional[float]):
            if value is None:
                return
            c = report_ws.cell(row=row, column=col_idx, value=round(float(value), 2))
            c.font = styles[&#34;normal_font&#34;]
            c.number_format = number_format

        # Stage
        report_ws.cell(row=row, column=1, value=stage_name).font = styles[&#34;normal_font&#34;]

        _set_num(2, w_stage)
        _set_num(3, x_stage)
        _set_num(4, trim_cm)
        _set_num(5, target_trim_cm)
        _set_num(6, mtc)
        _set_num(7, delta_tm_py)
        _set_num(8, delta_tm_xl)
        _set_num(9, delta_tm_diff)

        # Flag
        flag_cell = report_ws.cell(row=row, column=10, value=flag)
        flag_cell.font = styles[&#34;normal_font&#34;]

        # Lever &amp; Ballast
        _set_num(11, lever_arm_calc if lever_arm_calc is not None else 0.0)
        _set_num(12, ballast_calc)

        # 비고
        note = []
        if mtc == 0.0:
            note.append(&#34;MTC=0.0&#34;)
        if lever_arm_calc is None:
            note.append(&#34;Lever_arm 파라미터 부족&#34;)
        if delta_tm_xl is None:
            note.append(&#34;Excel ΔTM 없음&#34;)
        report_ws.cell(
            row=row, column=13, value=&#34;; &#34;.join(note) if note else &#34;&#34;
        ).font = styles[&#34;normal_font&#34;]

        current_row += 1

    # 컬럼 폭
    for col in range(1, len(headers) + 1):
        report_ws.column_dimensions[get_column_letter(col)].width = 20

    print(&#34;  [OK] RORO_Delta_Lever_Report sheet created (with ΔTM diff &amp; Flag)&#34;)
    return report_ws</code></pre>
</details>
<div class="desc"><p>RORO_Stage_Scenarios Stage 테이블 기준
- Python 엔진(Trim_cm, Stage별 Trim_target, MTC, X_ballast, LCF, Lpp)을 사용해
ΔTM_cm_tm, Lever_arm_m, Ballast_t_calc 를 재계산하고
엑셀 수식 결과와의 차이를 한눈에 볼 수 있는 리포트 시트를 생성한다.</p>
<p>비교 포인트:
- ΔTM_cm_tm (Python vs Excel)
- |ΔTM_diff| &gt; 0.50 → Flag = "CHECK", 그 이하면 "OK"</p>
<p>데이터 소스:
1. stage_results (Python 계산 결과):
- create_roro_sheet() 함수 내에서 생성 (L3758-3824)
- 각 Stage별로 solve_stage() 호출하여 계산된 값
- 포함 데이터: W_stage_t, x_stage_m, Trim_cm 등
2. RORO_Stage_Scenarios 시트에서 읽는 전역 파라미터 (L4786-4798):
- B8: Trim_target_cm (전역)
- B9: MTC_t_m_per_cm
- B10: LCF_m_from_midship
- B14: X_Ballast_from_AP_m
- B15: Lpp_m
3. RORO_Stage_Scenarios 시트에서 읽는 Excel 계산값 (L4877-4886):
- I열 (delta_tm_col): ΔTM_cm_tm (Excel 수식 계산 결과)
- Stage 이름을 A열에서 찾아 해당 행의 I열 값 읽기
4. trim_target_map (Stage별 Trim 타깃):
- TRIM_TARGET_MAP (L4124-4136에서 정의)
- Stage별 Trim 타깃 값으로 ΔTM 계산에 사용</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_draft_margin_check_sheet"><code class="name flex">
<span>def <span class="ident">create_roro_draft_margin_check_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>stage_results: Dict[str, Dict[str, float]],<br>roro_sheet_name: str = 'RORO_Stage_Scenarios',<br>fwd_limit_m: float = 2.7,<br>linkspan_min_freeboard_m: float = 0.28) ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_roro_draft_margin_check_sheet(
    wb: Workbook,
    stage_results: Dict[str, Dict[str, float]],
    roro_sheet_name: str = &#34;RORO_Stage_Scenarios&#34;,
    fwd_limit_m: float = 2.70,
    linkspan_min_freeboard_m: float = 0.28,
) -&gt; Worksheet:
    &#34;&#34;&#34;
    Stage별 Draft / Freeboard margin 자동 검증 시트.

    가정:
    - RORO_Stage_Scenarios 시트 구조 (예: 우리가 쓰는 표):
      A: Stage
      O: Dfwd_m
      P: Daft_m
      S: FWD_DeckElev_CD_m (Chart Datum 기준 Deck Elevation, Tide 포함)
      Python stage_results: FWD_Height_m (Freeboard, Tide 미포함)

    규칙:
    - FWD_margin = fwd_limit_m - Dfwd_m
      * FWD_margin &lt; 0.00 → FWD_FLAG = &#34;LIMIT&#34;
      * 0.00 &lt;= FWD_margin &lt; 0.10 → &#34;WARN&#34;
      * &gt;= 0.10 → &#34;OK&#34;
    - Linkspan_margin = FWD_Freeboard_m - linkspan_min_freeboard_m
      * FWD_Freeboard_m = D_vessel - Dfwd_m (Python FWD_Height_m 사용)
      * &lt; 0.00 → LINK_FLAG = &#34;CONTACT&#34;
      * 0.00 ~ 0.10 → &#34;WARN&#34;
      * &gt;= 0.10 → &#34;OK&#34;
    - Final Flag = FWD_FLAG / LINK_FLAG 중 가장 심각한 수준

    데이터 소스:
    1. stage_results (Python 계산 결과, 우선순위 1):
       - create_roro_sheet() 함수 내에서 생성 (L3758-3824)
       - 각 Stage별로 solve_stage() 호출하여 계산된 값
       - 포함 데이터: Dfwd_m, Daft_m, FWD_Height_m (Freeboard, Tide 미포함)
    2. RORO_Stage_Scenarios 시트에서 읽는 값 (Fallback, 우선순위 2, L5189-5203):
       - stage_results에 값이 없을 경우 Excel 시트에서 읽기
       - O열: Dfwd_m
       - P열: Daft_m
       - S열: FWD_DeckElev_CD_m (Deck Elevation, Tide 포함)
    3. 하드코딩된 상수 (함수 파라미터):
       - fwd_limit_m = 2.70 (FWD draft limit, 기본값)
       - linkspan_min_freeboard_m = 0.28 (Linkspan 최소 freeboard, 기본값)
    &#34;&#34;&#34;
    styles = get_styles()
    number_format = &#34;#,##0.00&#34;

    if roro_sheet_name not in wb.sheetnames:
        print(f&#34;[WARN] &#39;{roro_sheet_name}&#39; 시트가 없어 Draft Margin 체크 생략.&#34;)
        return wb.create_sheet(&#34;RORO_Draft_Margin_Check&#34;)

    ws_src = wb[roro_sheet_name]
    # Header 기반 컬럼 탐지(시트 구조 변경에 견고)
    header_row_src = 5  # RORO_Stage_Scenarios header row
    header_map: Dict[str, int] = {}
    for col in range(1, ws_src.max_column + 1):
        hv = ws_src.cell(row=header_row_src, column=col).value
        if isinstance(hv, str) and hv.strip():
            header_map[hv.strip().lower()] = col

    def _col(*names: str) -&gt; int | None:
        for nm in names:
            c = header_map.get(nm.strip().lower())
            if c is not None:
                return c
        return None

    # 대표 헤더 후보들
    _dfwd_col = _col(&#34;Dfwd_m&#34;, &#34;Fwd Draft (m)&#34;, &#34;Fwd Draft(m)&#34;, &#34;FWD_precise_m&#34;)
    _daft_col = _col(&#34;Daft_m&#34;, &#34;Aft Draft (m)&#34;, &#34;Aft Draft(m)&#34;, &#34;AFT_precise_m&#34;)
    _fwdh_col = _col(
        &#34;FWD_Height_m&#34;,
        &#34;FWD_Height_m (Linkspan FB)&#34;,
        &#34;Deck elevation (m)&#34;,
        &#34;Freeboard (m)&#34;,
    )

    _dfwd_col = _col(&#34;Dfwd_m&#34;, &#34;Fwd Draft (m)&#34;, &#34;Fwd Draft(m)&#34;, &#34;FWD_precise_m&#34;)
    _daft_col = _col(&#34;Daft_m&#34;, &#34;Aft Draft (m)&#34;, &#34;Aft Draft(m)&#34;, &#34;AFT_precise_m&#34;)
    _fwdh_col = _col(
        &#34;FWD_Height_m&#34;,
        &#34;FWD_Height_m (Linkspan FB)&#34;,
        &#34;Deck elevation (m)&#34;,
        &#34;Freeboard (m)&#34;,
    )

    # Stage → row 맵 (A열 기준)
    stage_row_map: Dict[str, int] = {}
    for row in range(1, ws_src.max_row + 1):
        v = ws_src.cell(row=row, column=1).value
        if v is None:
            continue
        stage_row_map[str(v).strip()] = row

    ws = wb.create_sheet(&#34;RORO_Draft_Margin_Check&#34;)

    title = ws[&#34;A1&#34;]
    title.value = &#34;RORO Stage Draft &amp; Freeboard Margin Check&#34;
    title.font = styles[&#34;title_font&#34;]

    ws[&#34;A3&#34;].value = (
        f&#34;FWD limit={fwd_limit_m:.2f} m, Linkspan min freeboard={linkspan_min_freeboard_m:.2f} m 기준.&#34;
    )
    ws[&#34;A3&#34;].font = styles[&#34;normal_font&#34;]

    header_row = 5
    headers = [
        &#34;Stage&#34;,
        &#34;Dfwd_m&#34;,
        &#34;Daft_m&#34;,
        &#34;FWD_margin_m (limit-DFWD)&#34;,
        &#34;FWD_Flag&#34;,
        &#34;FWD_Freeboard_m (D-Dfwd)&#34;,
        &#34;Linkspan_margin_m&#34;,
        &#34;Linkspan_Flag&#34;,
        &#34;Final_Flag&#34;,
        &#34;비고&#34;,
    ]
    for col, h in enumerate(headers, start=1):
        c = ws.cell(row=header_row, column=col, value=h)
        c.font = styles[&#34;header_font&#34;]
        c.fill = styles[&#34;header_fill&#34;]

    def _flag_fwd(margin: float) -&gt; str:
        if margin &lt; 0.0:
            return &#34;LIMIT&#34;
        if margin &lt; 0.10:
            return &#34;WARN&#34;
        return &#34;OK&#34;

    def _flag_link(margin: float) -&gt; str:
        if margin &lt; 0.0:
            return &#34;CONTACT&#34;
        if margin &lt; 0.10:
            return &#34;WARN&#34;
        return &#34;OK&#34;

    severity_rank = {&#34;OK&#34;: 0, &#34;WARN&#34;: 1, &#34;LIMIT&#34;: 2, &#34;CONTACT&#34;: 2, &#34;NO_DATA&#34;: 3}

    current_row = header_row + 1
    for stage_name, res in stage_results.items():
        src_row = stage_row_map.get(stage_name)

        # 우선 stage_results(Python 계산) 사용, 부족하면 원본 시트에서 보강
        def _cell_num(col_idx: int | None, default: float = 0.0) -&gt; float:
            if col_idx is None or src_row is None:
                return default
            try:
                v = ws_src.cell(row=src_row, column=col_idx).value
                return float(v) if v is not None and v != &#34;&#34; else default
            except Exception:
                return default

        dfwd = (
            float(res.get(&#34;Dfwd_m&#34;))
            if res.get(&#34;Dfwd_m&#34;) is not None
            else _cell_num(_dfwd_col, 0.0)
        )
        daft = (
            float(res.get(&#34;Daft_m&#34;))
            if res.get(&#34;Daft_m&#34;) is not None
            else _cell_num(_daft_col, 0.0)
        )
        fwd_height = (
            float(res.get(&#34;FWD_Height_m&#34;))
            if res.get(&#34;FWD_Height_m&#34;) is not None
            else _cell_num(_fwdh_col, 0.0)
        )

        fwd_margin = fwd_limit_m - dfwd
        link_margin = fwd_height - linkspan_min_freeboard_m

        fwd_flag = _flag_fwd(fwd_margin)
        link_flag = _flag_link(link_margin)

        # 최종 Flag (심각도 높은 쪽)
        flags = [fwd_flag, link_flag]
        final_flag = max(flags, key=lambda x: severity_rank.get(x, 0))

        # 기록
        ws.cell(row=current_row, column=1, value=stage_name).font = styles[
            &#34;normal_font&#34;
        ]

        def _num(col_idx: int, v: float):
            c = ws.cell(row=current_row, column=col_idx, value=round(v, 3))
            c.font = styles[&#34;normal_font&#34;]
            c.number_format = number_format

        _num(2, dfwd)
        _num(3, daft)
        _num(4, fwd_margin)

        ws.cell(row=current_row, column=5, value=fwd_flag).font = styles[&#34;normal_font&#34;]

        _num(6, fwd_height)
        _num(7, link_margin)
        ws.cell(row=current_row, column=8, value=link_flag).font = styles[&#34;normal_font&#34;]
        ws.cell(row=current_row, column=9, value=final_flag).font = styles[
            &#34;normal_font&#34;
        ]

        note = []
        if src_row is None:
            note.append(&#34;Stage_row 없음&#34;)
        ws.cell(row=current_row, column=10, value=&#34;; &#34;.join(note)).font = styles[
            &#34;normal_font&#34;
        ]

        current_row += 1

    for col in range(1, len(headers) + 1):
        ws.column_dimensions[get_column_letter(col)].width = 22

    print(&#34;  [OK] RORO_Draft_Margin_Check sheet created&#34;)
    return ws</code></pre>
</details>
<div class="desc"><p>Stage별 Draft / Freeboard margin 자동 검증 시트.</p>
<p>가정:
- RORO_Stage_Scenarios 시트 구조 (예: 우리가 쓰는 표):
A: Stage
O: Dfwd_m
P: Daft_m
S: FWD_DeckElev_CD_m (Chart Datum 기준 Deck Elevation, Tide 포함)
Python stage_results: FWD_Height_m (Freeboard, Tide 미포함)</p>
<p>규칙:
- FWD_margin = fwd_limit_m - Dfwd_m
* FWD_margin &lt; 0.00 → FWD_FLAG = "LIMIT"
* 0.00 &lt;= FWD_margin &lt; 0.10 → "WARN"
* &gt;= 0.10 → "OK"
- Linkspan_margin = FWD_Freeboard_m - linkspan_min_freeboard_m
* FWD_Freeboard_m = D_vessel - Dfwd_m (Python FWD_Height_m 사용)
* &lt; 0.00 → LINK_FLAG = "CONTACT"
* 0.00 ~ 0.10 → "WARN"
* &gt;= 0.10 → "OK"
- Final Flag = FWD_FLAG / LINK_FLAG 중 가장 심각한 수준</p>
<p>데이터 소스:
1. stage_results (Python 계산 결과, 우선순위 1):
- create_roro_sheet() 함수 내에서 생성 (L3758-3824)
- 각 Stage별로 solve_stage() 호출하여 계산된 값
- 포함 데이터: Dfwd_m, Daft_m, FWD_Height_m (Freeboard, Tide 미포함)
2. RORO_Stage_Scenarios 시트에서 읽는 값 (Fallback, 우선순위 2, L5189-5203):
- stage_results에 값이 없을 경우 Excel 시트에서 읽기
- O열: Dfwd_m
- P열: Daft_m
- S열: FWD_DeckElev_CD_m (Deck Elevation, Tide 포함)
3. 하드코딩된 상수 (함수 파라미터):
- fwd_limit_m = 2.70 (FWD draft limit, 기본값)
- linkspan_min_freeboard_m = 0.28 (Linkspan 최소 freeboard, 기본값)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_sheet"><code class="name flex">
<span>def <span class="ident">create_roro_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_roro_sheet(wb: Workbook):
    &#34;&#34;&#34;RORO_Stage_Scenarios 생성 (build_stage_loads + solve_stage 기반)&#34;&#34;&#34;
    ws = wb.create_sheet(&#34;RORO_Stage_Scenarios&#34;)
    styles = get_styles()

    # =====================================================================
    # Pre-ballast 최적화 및 Stage별 계산 (Python 엔진 사용)
    # =====================================================================
    # Hydro table 로드
    hydro_table_data = _load_hydro_table()
    if not hydro_table_data:
        print(&#34;[WARNING] hydro_table.json not found. Using empty table.&#34;)
        hydro_table_data = []

    # CONFIG (REMOVED - 중복 cfg 제거, stage_results.csv SSOT 사용)
    # ⚠️ PATCH 2024-12-23: stage_results.csv에서 실제 계산값 읽기
    import csv
    from pathlib import Path

    stage_results_path = Path(&#34;stage_results.csv&#34;)
    if not stage_results_path.exists():
        print(&#34;[WARNING] stage_results.csv not found. Using default cfg values.&#34;)
        cfg = {
            &#34;W_TR&#34;: 271.20,
            &#34;FR_TR1_RAMP_START&#34;: 26.15,
            &#34;FR_TR1_RAMP_MID&#34;: 26.15,
            &#34;FR_TR1_STOW&#34;: 25.65,
            &#34;FR_TR2_RAMP&#34;: 25.04,
            &#34;FR_TR2_STOW&#34;: 29.39,
            &#34;FR_PREBALLAST&#34;: 25.58,
        }
    else:
        print(&#34;[INFO] Reading TR positions from stage_results.csv (SSOT)&#34;)
        stage_data = {}
        with open(stage_results_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            reader = csv.DictReader(f)
            for row in reader:
                stage_name = row.get(&#34;Stage&#34;, &#34;&#34;)
                try:
                    x_stage_m = float(row.get(&#34;x_stage_m&#34;, 0.0))
                    w_stage_t = float(row.get(&#34;W_stage_t&#34;, 0.0))
                    stage_data[stage_name] = {&#34;x&#34;: x_stage_m, &#34;w&#34;: w_stage_t}
                except (ValueError, TypeError):
                    pass

        def x_to_fr(x_m: float) -&gt; float:
            return 30.151 - x_m

        cfg = {
            &#34;W_TR&#34;: 271.20,
            &#34;FR_TR1_RAMP_START&#34;: x_to_fr(stage_data.get(&#34;Stage 2&#34;, {}).get(&#34;x&#34;, 4.0)),
            &#34;FR_TR1_RAMP_MID&#34;: x_to_fr(stage_data.get(&#34;Stage 3&#34;, {}).get(&#34;x&#34;, 4.0)),
            &#34;FR_TR1_STOW&#34;: x_to_fr(stage_data.get(&#34;Stage 4&#34;, {}).get(&#34;x&#34;, 4.5)),
            &#34;FR_TR2_RAMP&#34;: x_to_fr(
                stage_data.get(&#34;Stage 6A_Critical (Opt C)&#34;, {}).get(&#34;x&#34;, 5.11)
            ),
            &#34;FR_TR2_STOW&#34;: x_to_fr(stage_data.get(&#34;Stage 6C&#34;, {}).get(&#34;x&#34;, 0.76)),
            &#34;FR_PREBALLAST&#34;: x_to_fr(
                stage_data.get(&#34;Stage 5_PreBallast&#34;, {}).get(&#34;x&#34;, 4.57)
            ),
        }
        print(f&#34;[INFO] cfg from stage_results.csv: {cfg}&#34;)

    # 선박 고정 파라미터
    MTC = 34.00
    LCF = 0.76
    LBP = 60.302
    D_vessel = 3.65
    base_disp_t = 2800.00
    # PATCH B1-2 Enhanced: Calculate base_tmean_m dynamically from hydro table (SSOT enforcement)
    if hydro_table_data and len(hydro_table_data) &gt; 0:
        base_tmean_m = interpolate_tmean_from_disp(base_disp_t, hydro_table_data)
        print(
            f&#34;[PATCH B1] base_tmean_m calculated from hydro table: {base_tmean_m:.3f} m (base_disp_t={base_disp_t:.2f} t)&#34;
        )
    else:
        raise RuntimeError(
            &#34;[PATCH B1-Enhanced] hydro_table_data missing; cannot compute base_tmean_m. &#34;
            &#34;Provide Hydro_Table_Engineering.json (SSOT). &#34;
            &#34;Location: bplus_inputs/Hydro_Table_Engineering.json&#34;
        )

    params = {
        &#34;MTC&#34;: MTC,
        &#34;LCF&#34;: LCF,
        &#34;LBP&#34;: LBP,
        &#34;D_vessel&#34;: D_vessel,
        &#34;hydro_table&#34;: hydro_table_data,
        &#34;FWD_DRAFT_LIMIT&#34;: 2.70,
        &#34;GM_MIN&#34;: 1.50,
        # Patch Option B: FSM from CONST_TANKS (Fuel + FreshWater)
        &#34;Const_FSM_t_m&#34;: 887.0,  # CONST_TANKS!E5 합계값 (DO.P/S + LRFO.P/S + FW1.P/S + FW2.P/S)
        # Pre-ballast 탐색 범위 및 해 선택 기준
        &#34;PREBALLAST_MIN_T&#34;: 30.0,  # 최소 30t 이상부터 탐색 (0t 해를 배제)
        &#34;PREBALLAST_MAX_T&#34;: 600.0,  # 400.0 → 600.0으로 확대
        &#34;PREBALLAST_STEP_T&#34;: 2.0,  # 5.0 → 2.0으로 축소 (더 세밀한 탐색)
        &#34;CHECK_STAGE5&#34;: True,  # Stage 5_PreBallast도 FWD≤2.70m, |Trim|≤240cm를 강제 (Harbor Master 제출용)
    }
    params.update(cfg)

    # Pre-ballast 최적화 (필수 조건)
    w_tr = cfg[&#34;W_TR&#34;]

    preballast_result = find_preballast_opt(
        w_tr_unit_t=w_tr,
        base_disp_t=base_disp_t,
        fr_tr1_stow=cfg.get(&#34;FR_TR1_STOW&#34;, FR_TR1_STOW),
        fr_tr2_ramp=cfg.get(&#34;FR_TR2_RAMP&#34;, FR_TR2_RAMP),
        fr_preballast=cfg.get(&#34;FR_PREBALLAST&#34;, FR_PREBALLAST),
        params=params,
        search_min_t=params.get(&#34;PREBALLAST_MIN_T&#34;, 20.0),  # FIX: enforce 20t minimum
        search_max_t=params.get(&#34;PREBALLAST_MAX_T&#34;, 400.0),
        search_step_t=params.get(&#34;PREBALLAST_STEP_T&#34;, 1.0),
    )

    if not preballast_result[&#34;ok&#34;]:
        # 실패 시: 기존 PREBALLAST_T_TARGET 사용 등 fallback
        preballast_opt = params.get(&#34;PREBALLAST_T_TARGET&#34;, 250.0)
        print(
            f&#34;\n[WARNING] Pre-ballast optimization failed: {preballast_result[&#39;reason&#39;]}&#34;
        )
        print(f&#34;[WARNING] Using fallback pre-ballast value: {preballast_opt:.2f} t&#34;)
        stage5_pb = None
        stage6A_pb = None
    else:
        preballast_opt = preballast_result[&#34;w_preballast_t&#34;]
        stage5_pb = preballast_result.get(&#34;stage5&#34;) or {}
        stage6A_pb = preballast_result.get(&#34;stage6A&#34;) or {}

        # PATCH FIX #1: 안전한 FWD 값 읽기 (키 이름 불일치 대응)
        def _read_fwd(stage: dict) -&gt; float:
            for key in (&#34;FWD_m&#34;, &#34;FWD&#34;, &#34;FWD_draft_m&#34;, &#34;Dfwd_m&#34;):
                if key in stage:
                    return float(stage[key])
            return 0.0

        fwd5 = _read_fwd(stage5_pb)
        fwd6 = _read_fwd(stage6A_pb)

        print(f&#34;\n[INFO] [OK] Pre-ballast optimization successful&#34;)
        print(f&#34;[INFO] Stern Pre-Ballast (FW2): {preballast_opt:.2f} t&#34;)
        print(f&#34;[INFO] Stage 5 FWD: {fwd5:.2f} m (Limit: 2.70m)&#34;)
        print(f&#34;[INFO] Stage 6A FWD: {fwd6:.2f} m (Limit: 2.70m)&#34;)
        safety_margin = 2.70 - fwd6
        print(
            f&#34;[INFO] Safety Margin: {safety_margin:.2f} m ({safety_margin/2.70*100:.1f}%)&#34;
        )

        # VALIDATION CHECK
        if fwd5 &gt; 2.70 or fwd6 &gt; 2.70:
            print(f&#34;[ERROR] [FAIL] FWD DRAFT EXCEEDS 2.70m LIMIT - DESIGN INVALID&#34;)
        else:
            print(f&#34;[INFO] [OK] All draft constraints satisfied - DESIGN APPROVED&#34;)
    print(f&#34;[INFO] Using Pre-ballast: {preballast_opt:.2f} t (used for all stages)&#34;)

    # =====================================================================
    # Stage별 계산 결과 저장 (stage_results 딕셔너리 생성)
    # =====================================================================
    # 이 딕셔너리는 다음 리포트 시트들의 주요 데이터 소스입니다:
    # - RORO_Delta_Lever_Report: Python 계산값과 Excel 수식 결과 비교
    # - RORO_Draft_Margin_Check: Draft/Freeboard margin 검증
    # - RORO_Stability_GM_Check: GM 검증
    # - 기타 BPLUS 관련 체크 시트들
    #
    # 데이터 흐름:
    #   solve_stage() → res (각 Stage 계산 결과)
    #     ↓
    #   Pre-ballast 최적화 결과로 Stage 5_PreBallast, Stage 6A_Critical override
    #     ↓
    #   stage_results[stage_name] = res
    #     ↓
    #   리포트 시트 생성 함수들에서 사용
    # =====================================================================
    stage_results = {}
    stages_order = [
        &#34;Stage 1&#34;,
        &#34;Stage 2&#34;,
        &#34;Stage 3&#34;,
        &#34;Stage 4&#34;,
        &#34;Stage 5&#34;,
        &#34;Stage 5_PreBallast&#34;,
        &#34;Stage 6A_Critical (Opt C)&#34;,
        &#34;Stage 6C_TotalMassOpt&#34;,
        &#34;Stage 6C&#34;,
        &#34;Stage 7&#34;,
    ]

    for st in stages_order:
        loads = build_stage_loads(st, preballast_opt, params)
        res = solve_stage(base_disp_t, base_tmean_m, loads, **params)

        # ⭐ Pre-ballast 결과로 Stage 5_PreBallast / Stage 6A 값 override
        if st == &#34;Stage 5_PreBallast&#34; and stage5_pb is not None:
            # Pre-ballast 계산 결과의 FWD/AFT/Trim/TM 값으로 교체
            res[&#34;W_stage_t&#34;] = float(stage5_pb.get(&#34;W_stage_t&#34;, res[&#34;W_stage_t&#34;]))
            if abs(res[&#34;W_stage_t&#34;] - res[&#34;Disp_t&#34;]) &gt; 0.1:
                print(
                    f&#34;[WARN] Stage 5_PreBallast: W_stage_t ({res[&#39;W_stage_t&#39;]:.2f}) != Disp_t ({res[&#39;Disp_t&#39;]:.2f}); forcing consistency&#34;
                )
                res[&#34;W_stage_t&#34;] = res[&#34;Disp_t&#34;]
            res[&#34;x_stage_m&#34;] = float(stage5_pb.get(&#34;x_stage_m&#34;, res[&#34;x_stage_m&#34;]))
            res[&#34;TM_LCF_tm&#34;] = float(stage5_pb.get(&#34;TM_tm&#34;, res[&#34;TM_LCF_tm&#34;]))
            res[&#34;Trim_cm&#34;] = float(stage5_pb.get(&#34;Trim_cm&#34;, res[&#34;Trim_cm&#34;]))
            res[&#34;Dfwd_m&#34;] = float(stage5_pb.get(&#34;FWD_m&#34;, res[&#34;Dfwd_m&#34;]))
            res[&#34;Daft_m&#34;] = float(stage5_pb.get(&#34;AFT_m&#34;, res[&#34;Daft_m&#34;]))
            # FWD_Height_m, AFT_Height_m 재계산
            res[&#34;FWD_Height_m&#34;] = D_vessel - res[&#34;Dfwd_m&#34;]
            res[&#34;AFT_Height_m&#34;] = D_vessel - res[&#34;Daft_m&#34;]
            print(
                f&#34;[INFO] Stage 5_PreBallast: Applied pre-ballast FWD={res[&#39;Dfwd_m&#39;]:.2f}m, AFT={res[&#39;Daft_m&#39;]:.2f}m&#34;
            )

        if st == &#34;Stage 6A_Critical (Opt C)&#34; and stage6A_pb is not None:
            # Pre-ballast 계산 결과의 FWD/AFT/Trim/TM 값으로 교체
            res[&#34;W_stage_t&#34;] = float(stage6A_pb.get(&#34;W_stage_t&#34;, res[&#34;W_stage_t&#34;]))
            if abs(res[&#34;W_stage_t&#34;] - res[&#34;Disp_t&#34;]) &gt; 0.1:
                print(
                    f&#34;[WARN] Stage 6A_Critical: W_stage_t ({res[&#39;W_stage_t&#39;]:.2f}) != Disp_t ({res[&#39;Disp_t&#39;]:.2f}); forcing consistency&#34;
                )
                res[&#34;W_stage_t&#34;] = res[&#34;Disp_t&#34;]
            res[&#34;x_stage_m&#34;] = float(stage6A_pb.get(&#34;x_stage_m&#34;, res[&#34;x_stage_m&#34;]))
            res[&#34;TM_LCF_tm&#34;] = float(stage6A_pb.get(&#34;TM_tm&#34;, res[&#34;TM_LCF_tm&#34;]))
            res[&#34;Trim_cm&#34;] = float(stage6A_pb.get(&#34;Trim_cm&#34;, res[&#34;Trim_cm&#34;]))
            res[&#34;Dfwd_m&#34;] = float(stage6A_pb.get(&#34;FWD_m&#34;, res[&#34;Dfwd_m&#34;]))
            res[&#34;Daft_m&#34;] = float(stage6A_pb.get(&#34;AFT_m&#34;, res[&#34;Daft_m&#34;]))
            # FWD_Height_m, AFT_Height_m 재계산
            res[&#34;FWD_Height_m&#34;] = D_vessel - res[&#34;Dfwd_m&#34;]
            res[&#34;AFT_Height_m&#34;] = D_vessel - res[&#34;Daft_m&#34;]
            print(
                f&#34;[INFO] Stage 6A_Critical: Applied pre-ballast FWD={res[&#39;Dfwd_m&#39;]:.2f}m, AFT={res[&#39;Daft_m&#39;]:.2f}m&#34;
            )

        # B2 Gate 기반 초기 Ballast 추정 (물리식)
        # ΔTrim × MTC / Lever_arm
        MTC = float(params.get(&#34;MTC&#34;, params.get(&#34;MTC_t_m_per_cm&#34;, 0.0)) or 0.0)
        lcf_mid = float(params.get(&#34;LCF&#34;, params.get(&#34;LCF_m_from_midship&#34;, 0.0)) or 0.0)
        fr_pb = params.get(&#34;FR_PREBALLAST&#34;, params.get(&#34;FR_PB&#34;, 3.0))
        ballast_x_mid = fr_to_x(fr_pb)
        lever_arm_m = ballast_x_mid - lcf_mid
        fwd_limit = float(params.get(&#34;max_fwd_draft_ops_m&#34;, 2.70))
        trim_gate_cm = calc_trim_gate_cm_from_tmean(
            float(res.get(&#34;Tmean_m&#34;, 0.0) or 0.0), fwd_limit
        )
        delta_trim_cm = trim_gate_cm - float(res.get(&#34;Trim_cm&#34;, 0.0) or 0.0)
        ballast_est_t = (
            (delta_trim_cm * MTC) / lever_arm_m
            if abs(lever_arm_m) &gt; 1e-6 and abs(MTC) &gt; 1e-6
            else 0.0
        )
        pump_rate_eff = float(
            params.get(&#34;pump_rate_effective_tph&#34;) or params.get(&#34;pump_rate_tph&#34;) or 10.0
        )
        res[&#34;Trim_gate_cm&#34;] = round(trim_gate_cm, 2)
        res[&#34;Ballast_t_calc&#34;] = round(ballast_est_t, 2)
        res[&#34;Ballast_time_h_calc&#34;] = (
            round(abs(ballast_est_t) / pump_rate_eff, 2) if pump_rate_eff &gt; 0 else 0.0
        )
        # Backward-compat keys (Iterative에서 사용)
        res[&#34;Ballast_t&#34;] = res[&#34;Ballast_t_calc&#34;]
        res[&#34;Ballast_time_h&#34;] = res[&#34;Ballast_time_h_calc&#34;]

        # Stage 결과를 딕셔너리에 저장
        # 포함된 주요 키: W_stage_t, x_stage_m, Trim_cm, Dfwd_m, Daft_m,
        #                 FWD_Height_m, AFT_Height_m, GM_m, Disp_t, Ballast_t 등
        stage_results[st] = res

    # Title
    ws[&#34;A1&#34;] = &#34;RORO Stage Scenarios – Option C (Target 240cm Safe Margin)&#34;
    ws[&#34;A1&#34;].font = styles[&#34;title_font&#34;]

    # Row 2: Input parameter 안내
    ws[&#34;C2&#34;] = &#34;← Input parameter(yellow cellls only)&#34;
    ws[&#34;C2&#34;].font = styles[&#34;normal_font&#34;]

    # 숫자 포맷 통일: 천단위 구분, 소수점 2자리
    number_format = &#34;#,##0.00&#34;

    # Row 4: 섹션 제목 추가
    ws[&#34;A4&#34;] = &#34;1.Critical Stage Verification: Trim &amp; Draft Status Sequence&#34;
    ws[&#34;A4&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F4&#34;] = &#34;2. Stage Sequence Table&#34;
    ws[&#34;F4&#34;].font = styles[&#34;normal_font&#34;]

    # Row 5: 헤더 추가
    ws[&#34;A5&#34;] = &#34;Parameter&#34;
    ws[&#34;A5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;A5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;A5&#34;].alignment = styles[&#34;center_align&#34;]

    ws[&#34;B5&#34;] = &#34;Value&#34;
    ws[&#34;B5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;B5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;B5&#34;].alignment = styles[&#34;center_align&#34;]

    ws[&#34;C5&#34;] = &#34;Unit&#34;
    ws[&#34;C5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;C5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;C5&#34;].alignment = styles[&#34;center_align&#34;]

    ws[&#34;D5&#34;] = &#34;REMARK&#34;
    ws[&#34;D5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;D5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;D5&#34;].alignment = styles[&#34;center_align&#34;]

    ws[&#34;F5&#34;] = &#34;Stage&#34;
    ws[&#34;F5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;F5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;F5&#34;].alignment = styles[&#34;center_align&#34;]

    ws[&#34;G5&#34;] = &#34;EXPLANATION&#34;
    ws[&#34;G5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;G5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;G5&#34;].alignment = styles[&#34;center_align&#34;]

    ws[&#34;O5&#34;] = &#34;Fwd Draft (m)&#34;
    ws[&#34;O5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;O5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;O5&#34;].alignment = styles[&#34;center_align&#34;]

    ws[&#34;P5&#34;] = &#34;Freeboard (m)&#34;
    ws[&#34;P5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;P5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;P5&#34;].alignment = styles[&#34;center_align&#34;]

    ws[&#34;Q5&#34;] = &#34;Aft Draft (m)&#34;
    ws[&#34;Q5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;Q5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;Q5&#34;].alignment = styles[&#34;center_align&#34;]

    ws[&#34;R5&#34;] = &#34;Status Assessment&#34;
    ws[&#34;R5&#34;].font = styles[&#34;header_font&#34;]
    ws[&#34;R5&#34;].fill = styles[&#34;header_fill&#34;]
    ws[&#34;R5&#34;].alignment = styles[&#34;center_align&#34;]

    # 파라미터 세로 배치 (A6-A15: Parameter, B6-B15: Value, C6-C15: Unit, D6-D15: REMARK, F6-F15: Stage)
    # A6: Tmean_baseline
    ws[&#34;A6&#34;] = &#34;Tmean_baseline&#34;
    # PATCH B1-3: Use dynamically calculated base_tmean_m instead of hardcoded 2.00
    ws[&#34;B6&#34;] = float(base_tmean_m)  # Calculated from hydro table (PATCH B1-2)
    ws[&#34;B6&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;B6&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B6&#34;].number_format = number_format
    ws[&#34;C6&#34;] = &#34;m&#34;
    ws[&#34;C6&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D6&#34;] = &#34;Baseline mean draft (from hydro table)&#34;
    ws[&#34;D6&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F6&#34;] = &#34;Stage 1&#34;
    ws[&#34;F6&#34;].font = styles[&#34;normal_font&#34;]

    # A7: Forecast_Tide_m (FORECAST ONLY, NOT Required WL)
    ws[&#34;A7&#34;] = &#34;Forecast_Tide_m&#34;
    ws[&#34;B7&#34;] = 2.00  # BUSHRA verified: Mina Zayed high tide avg 1.80-2.20m
    ws[&#34;B7&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;B7&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B7&#34;].number_format = number_format
    ws[&#34;C7&#34;] = &#34;m&#34;
    ws[&#34;C7&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D7&#34;] = &#34;Forecast tide level (CD). NOT Required_WL_m.&#34;
    ws[&#34;D7&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F7&#34;] = &#34;Stage 2&#34;
    ws[&#34;F7&#34;].font = styles[&#34;normal_font&#34;]

    # A8: Trim_target_cm
    ws[&#34;A8&#34;] = &#34;Trim_target_cm&#34;
    ws[&#34;B8&#34;] = 10.00  # BUSHRA verified: Ops safe limit (by stern max)
    ws[&#34;B8&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;B8&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B8&#34;].number_format = number_format
    ws[&#34;C8&#34;] = &#34;cm&#34;
    ws[&#34;C8&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D8&#34;] = &#34;Target trim&#34;
    ws[&#34;D8&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F8&#34;] = &#34;Stage 3&#34;
    ws[&#34;F8&#34;].font = styles[&#34;normal_font&#34;]

    # A9: MTC
    ws[&#34;A9&#34;] = &#34;MTC&#34;
    ws[&#34;B9&#34;] = &#39;=INDEX(Calc!$E:$E, MATCH(&#34;MTC_t_m_per_cm&#34;, Calc!$C:$C, 0))&#39;
    ws[&#34;B9&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;B9&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B9&#34;].number_format = number_format
    ws[&#34;C9&#34;] = &#34;t·m/cm&#34;
    ws[&#34;C9&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D9&#34;] = &#34;Moment to change trim&#34;
    ws[&#34;D9&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F9&#34;] = &#34;Stage 4&#34;
    ws[&#34;F9&#34;].font = styles[&#34;normal_font&#34;]

    # A10: LCF (midship 기준, TM 계산용)
    ws[&#34;A10&#34;] = &#34;LCF&#34;
    ws[&#34;B10&#34;] = &#34;=Calc!$E$15&#34;  # LCF_m_from_midship 직접 참조 (0.76 m)
    ws[&#34;B10&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B10&#34;].number_format = number_format
    ws[&#34;B10&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;C10&#34;] = &#34;m&#34;
    ws[&#34;C10&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D10&#34;] = &#34;Longitudinal center of flotation (from midship, for TM calculation)&#34;
    ws[&#34;D10&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F10&#34;] = &#34;Stage 5&#34;
    ws[&#34;F10&#34;].font = styles[&#34;normal_font&#34;]

    # A11: D_vessel
    ws[&#34;A11&#34;] = &#34;D_vessel&#34;
    ws[&#34;B11&#34;] = 3.65  # BUSHRA verified: Booklet + TCP confirmed
    ws[&#34;B11&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B11&#34;].number_format = number_format
    ws[&#34;B11&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;C11&#34;] = &#34;m&#34;
    ws[&#34;C11&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D11&#34;] = &#34;Vessel depth&#34;
    ws[&#34;D11&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F11&#34;] = &#34;Stage 5_PreBallast&#34;
    ws[&#34;F11&#34;].font = styles[&#34;normal_font&#34;]

    # A12: TPC
    ws[&#34;A12&#34;] = &#34;TPC&#34;
    ws[&#34;B12&#34;] = &#39;=INDEX(Calc!$E:$E, MATCH(&#34;TPC_t_per_cm&#34;, Calc!$C:$C, 0))&#39;
    ws[&#34;B12&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B12&#34;].number_format = number_format
    ws[&#34;B12&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;C12&#34;] = &#34;t/cm&#34;
    ws[&#34;C12&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D12&#34;] = &#34;Tons per centimeter&#34;
    ws[&#34;D12&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F12&#34;] = &#34;Stage 6A_Critical (Opt C)&#34;
    ws[&#34;F12&#34;].font = styles[&#34;normal_font&#34;]

    # A13: pump_rate_effective_tph
    ws[&#34;A13&#34;] = &#34;pump_rate_effective_tph&#34;
    ws[&#34;B13&#34;] = (
        &#39;=INDEX(Calc!$E:$E, MATCH(&#34;pump_rate_effective_tph&#34;, Calc!$C:$C, 0))&#39;  # BUSHRA verified: 100.00 t/h (2×50 t/h pumps)
    )
    ws[&#34;B13&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;B13&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B13&#34;].number_format = number_format
    ws[&#34;C13&#34;] = &#34;t/h&#34;
    ws[&#34;C13&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D13&#34;] = &#34;Effective pump rate&#34;
    ws[&#34;D13&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F13&#34;] = &#34;Stage 6C_TotalMassOpt&#34;
    ws[&#34;F13&#34;].font = styles[&#34;normal_font&#34;]

    # A14: X_Ballast (AP 기준, Stern FW2 탱크 중심)
    ws[&#34;A14&#34;] = &#34;X_Ballast&#34;
    ws[&#34;B14&#34;] = 0.119  # FW2 tank LCG from AP (m) – Stern pre-ballast 기준
    ws[&#34;B14&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B14&#34;].number_format = number_format
    ws[&#34;B14&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;C14&#34;] = &#34;m&#34;
    ws[&#34;C14&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D14&#34;] = &#34;Ballast center position (from AP, Stern FW2)&#34;
    ws[&#34;D14&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F14&#34;] = &#34;Stage 6C&#34;
    ws[&#34;F14&#34;].font = styles[&#34;normal_font&#34;]

    # A15: Lpp
    ws[&#34;A15&#34;] = &#34;Lpp&#34;
    ws[&#34;B15&#34;] = 60.302  # BUSHRA verified: Booklet confirmed
    ws[&#34;B15&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;B15&#34;].number_format = number_format
    ws[&#34;B15&#34;].fill = styles[&#34;input_fill&#34;]
    ws[&#34;C15&#34;] = &#34;m&#34;
    ws[&#34;C15&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;D15&#34;] = &#34;Length between perpendiculars&#34;
    ws[&#34;D15&#34;].font = styles[&#34;normal_font&#34;]
    ws[&#34;F15&#34;] = &#34;Stage 7&#34;
    ws[&#34;F15&#34;].font = styles[&#34;normal_font&#34;]

    # Row 17: 섹션 제목 추가 (pre-ballast 값은 Python에서 자동 결정)
    ws[&#34;A17&#34;] = (
        &#34;4. Ballast Water Optimization Matrix &amp; Safety Margins (Auto Pre-ballast)&#34;
    )
    ws[&#34;A17&#34;].font = styles[&#34;normal_font&#34;]

    # Stage 1-10 Notes를 G6-G15로 배치 (DAS Method Operation)
    # stages 리스트 순서대로 G6부터 시작 (Excel 시트 순서와 일치: A26에 Stage 6C_TotalMassOpt 포함)
    stages_list = [
        &#34;Stage 1&#34;,  # Arrival
        &#34;Stage 2&#34;,  # TR1 Ramp Start
        &#34;Stage 3&#34;,  # TR1 Mid-Ramp
        &#34;Stage 4&#34;,  # TR1 On Deck
        &#34;Stage 5&#34;,  # TR1 Final Position
        &#34;Stage 5_PreBallast&#34;,  # [D-1 Night] Water Supply Complete
        &#34;Stage 6A_Critical (Opt C)&#34;,  # [D-Day] TR2 Ramp Entry
        &#34;Stage 6C_TotalMassOpt&#34;,  # Alternative total mass optimized condition
        &#34;Stage 6C&#34;,  # Final Stowage
        &#34;Stage 7&#34;,  # Departure
    ]

    # DAS / AGI 공통 – Pre-ballast + Tug 보조 컨셉 설명
    explanations = {
        &#34;Stage 1&#34;: &#34;Arrival lightship condition. Baseline drafts, trim, and GM are checked before any cargo loading or ballast change.&#34;,
        &#34;Stage 2&#34;: &#34;TR1 roll-on start – first axle on the ramp. Initial bow-down trim response is checked against allowable draft and freeboard limits.&#34;,
        &#34;Stage 3&#34;: &#34;TR1 mid-ramp – transformer COG on the ramp. Progressive bow-down trim is monitored to remain within the allowable envelope.&#34;,
        &#34;Stage 4&#34;: &#34;TR1 fully on deck. Weight is completely transferred from ramp to vessel deck; deck loading, ramp condition, drafts, and trim are verified.&#34;,
        &#34;Stage 5&#34;: &#34;TR1 secured at final aft stowage position (around Fr.42). New reference condition with TR1 only on board, used as the basis for D-1 stern pre-ballasting using FW2 (Fr.0–6, aft).&#34;,
        &#34;Stage 5_PreBallast&#34;: (
            &#34;Pre-ballast condition with TR1 only on board (D-1, using shore water). &#34;
            &#34;An intentional stern trim is set using the aft FW2 fresh water tanks (Fr.0–6, AFT, Ballast CG near FR 3.0) &#34;
            &#34;so that the bow-down trimming moment of TR2 at ramp entry is counterbalanced and the forward draft remains within the 2.70 m AGI limit &#34;
            &#34;without any major dynamic ballasting during the critical RORO operation on D-day.&#34;
        ),
        &#34;Stage 6A_Critical (Opt C)&#34;: &#34;Critical TR2 ramp-entry condition on D-day with the D-1 stern pre-ballast (FW2, Fr.0–6) kept fixed. This stage is used to check worst-case forward draft against the 2.70 m limit, trim envelope, GM criteria, and ramp/linkspan clearance under combined TR1+TR2 loading.&#34;,
        &#34;Stage 6C_TotalMassOpt&#34;: &#39;Alternative &#34;total mass optimized&#34; final condition with TR1 and TR2 on deck and higher combined cargo+ballast weight. Sensitivity case to assess maximum displacement effects on drafts, trim, GM and freeboard.&#39;,
        &#34;Stage 6C&#34;: &#34;Planned final stowage condition with TR1 and TR2 secured on deck and ballast as per departure plan. Main departure case for checking GM, trim and freeboard criteria.&#34;,
        &#34;Stage 7&#34;: &#34;Post-operation lightship/reference condition after cargo is discharged. Used to reconfirm hydrostatic characteristics and GM consistency against Stage 1.&#34;,
    }

    for idx, stage_name in enumerate(stages_list, start=0):
        g_row = 6 + idx  # G6부터 시작 (G6-G15)
        if stage_name in explanations:
            ws.cell(row=g_row, column=7).value = explanations[
                stage_name
            ]  # G = column 7
            ws.cell(row=g_row, column=7).font = styles[&#34;normal_font&#34;]
            ws.cell(row=g_row, column=7).fill = styles[&#34;input_fill&#34;]  # G6-G15 색상 추가

    # Stage table header
    header_row = 18  # 기존 파일과 동일하게 Row 18
    stage_headers = [
        &#34;Stage&#34;,
        &#34;W_stage_t&#34;,
        &#34;Fr_stage&#34;,
        &#34;x_stage_m&#34;,
        &#34;TM (t·m)&#34;,
        &#34;Trim_cm&#34;,
        &#34;FWD_precise_m&#34;,  # v4.0: Changed from Trim_m to FWD_precise_m
        &#34;AFT_precise_m&#34;,  # v4.0: Changed from Trim_target_cm to AFT_precise_m
        &#34;ΔTM_cm_tm&#34;,
        &#34;Lever_arm_m&#34;,
        &#34;Ballast_t_calc&#34;,
        &#34;Ballast_time_h_calc&#34;,
        &#34;Ballast_t&#34;,
        &#34;Ballast_time_h&#34;,
        &#34;Trim_Check&#34;,
        &#34;Dfwd_m&#34;,
        &#34;Daft_m&#34;,
        &#34;Trim_target_stage_cm&#34;,  # sdsdds.md: Q열 추가 (Stage별 타깃, 없으면 B6 사용)
        &#34;FWD_DeckElev_CD_m&#34;,  # S(19): Chart Datum 기준 Deck Elevation (Tide 포함)
        &#34;AFT_DeckElev_CD_m&#34;,  # T(20): Chart Datum 기준 Deck Elevation (Tide 포함)
        &#34;Difference&#34;,  # T(20) 컬럼: 기존 파일과 동일하게
        # U-AE는 extend_roro_captain_req()에서 작성됨
        # PATCH C 컬럼들은 AF-AJ로 이동 (헤더는 별도 작성)
    ]
    for col, header in enumerate(stage_headers, start=1):
        cell = ws.cell(row=header_row, column=col)
        cell.value = header if header else &#34;&#34;
        if header:
            cell.font = styles[&#34;header_font&#34;]
            cell.fill = styles[&#34;header_fill&#34;]
            cell.alignment = styles[&#34;center_align&#34;]

    # PATCH C headers (AF-AJ, column 32-36)
    patch_c_headers = [
        (&#34;AF&#34;, 32, &#34;Trim_gate_cm&#34;),
        (&#34;AG&#34;, 33, &#34;Gate_Ballast_net_t&#34;),
        (&#34;AH&#34;, 34, &#34;Dfwd_gate_m&#34;),
        (&#34;AI&#34;, 35, &#34;Gate_iter_n&#34;),
        (&#34;AJ&#34;, 36, &#34;Gate_Flag&#34;),
    ]
    for letter, col, header in patch_c_headers:
        cell = ws.cell(row=header_row, column=col)
        cell.value = header
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]

    # Stage names (DAS Method Operation - 10 stages)
    stages = [
        &#34;Stage 1&#34;,  # Arrival
        &#34;Stage 2&#34;,  # TR1 Ramp Start
        &#34;Stage 3&#34;,  # TR1 Mid-Ramp
        &#34;Stage 4&#34;,  # TR1 On Deck
        &#34;Stage 5&#34;,  # TR1 Final Position
        &#34;Stage 5_PreBallast&#34;,  # [D-1 Night] Water Supply Complete
        &#34;Stage 6A_Critical (Opt C)&#34;,  # [D-Day] TR2 Ramp Entry
        &#34;Stage 6C_TotalMassOpt&#34;,  # Total Mass Optimization
        &#34;Stage 6C&#34;,  # Final Stowage
        &#34;Stage 7&#34;,  # Departure
    ]
    # PATCH B2-2: Calculate Trim_gate_cm dynamically from Tmean instead of hardcoded values
    # Trim_gate_cm = max(0, 2 * (Tmean - 2.70) * 100) to ensure FWD &lt;= 2.70m
    target_trim_by_stage = {}
    FWD_LIMIT_M = 2.70  # Forward draft limit (m)

    for stage_name in stages_order:
        if stage_name in stage_results:
            res = stage_results[stage_name]
            tmean_m = res.get(&#34;Tmean_m&#34;, 0.0)
            # Calculate required trim to satisfy FWD limit
            trim_gate_cm = calc_trim_gate_cm_from_tmean(tmean_m, FWD_LIMIT_M)
            target_trim_by_stage[stage_name] = trim_gate_cm
            print(
                f&#34;[PATCH B2] {stage_name}: Tmean={tmean_m:.3f}m → Trim_gate={trim_gate_cm:.2f}cm&#34;
            )
        else:
            # Fallback for stages not in stage_results (shouldn&#39;t happen, but safe)
            target_trim_by_stage[stage_name] = 0.00

    # Also handle Stage 6C_TotalMassOpt if it exists separately
    if &#34;Stage 6C_TotalMassOpt&#34; not in target_trim_by_stage:
        # Use Stage 6C value as fallback
        target_trim_by_stage[&#34;Stage 6C_TotalMassOpt&#34;] = target_trim_by_stage.get(
            &#34;Stage 6C&#34;, 0.00
        )

    first_data_row = 19  # header_row가 18이므로 first_data_row는 19
    trim5_row = None

    # =====================================================================
    # Stage별 기본 데이터 (build_stage_loads 결과 기반)
    # =====================================================================
    # Stage 6C Total Mass Opt용 상수
    TOTAL_CARGO_WEIGHT_T = 568.83  # 총 화물 중량 (예시값, 필요시 조정)
    PREBALLAST_T_TARGET = preballast_opt  # 최적화된 Pre-ballast 사용

    # Stage별 기본 데이터 (solve_stage 결과에서 추출)
    stage_defaults = {}
    for stage_name in stages_order:
        if stage_name in stage_results:
            res = stage_results[stage_name]
            # Fr_stage는 build_stage_loads에서 사용한 위치에서 역산
            # 또는 단순히 x_stage_m에서 역산
            x_stage = res[&#34;x_stage_m&#34;]
            fr_stage = x_to_fr(x_stage) if abs(x_stage) &gt; 0.01 else None

            stage_defaults[stage_name] = {
                &#34;W&#34;: res[&#34;W_stage_t&#34;],
                &#34;Fr&#34;: fr_stage,
                &#34;x&#34;: x_stage,
                &#34;Dfwd_m&#34;: res.get(&#34;Dfwd_m&#34;),  # Pre-ballast override 값 포함
                &#34;Daft_m&#34;: res.get(&#34;Daft_m&#34;),  # Pre-ballast override 값 포함
                &#34;FWD_precise_m&#34;: res.get(&#34;Dfwd_m&#34;),  # FWD_precise_m = Dfwd_m
                &#34;AFT_precise_m&#34;: res.get(&#34;Daft_m&#34;),  # AFT_precise_m = Daft_m
                &#34;TM_LCF_tm&#34;: res.get(&#34;TM_LCF_tm&#34;),
                &#34;Trim_cm&#34;: res.get(&#34;Trim_cm&#34;),
            }
        else:
            # Fallback (Stage 1, 7 등)
            stage_defaults[stage_name] = {&#34;W&#34;: 0.0, &#34;Fr&#34;: None, &#34;x&#34;: 0.0}

    for idx, stage_name in enumerate(stages, start=0):
        row = first_data_row + idx
        row_str = str(row)

        ws.cell(row=row, column=1, value=stage_name)

        if stage_name in stage_defaults:
            defaults = stage_defaults[stage_name]
            # W_stage_t: Python에서 계산된 값 사용
            ws.cell(row=row, column=2, value=defaults[&#34;W&#34;])
            # Fr_stage 컬럼 (column 3): Python에서 계산된 값 사용
            if defaults[&#34;Fr&#34;] is not None:
                ws.cell(row=row, column=3, value=round(defaults[&#34;Fr&#34;], 2))
            else:
                ws.cell(row=row, column=3, value=&#34;&#34;)  # Stage 1은 Fr 없음
            # x_stage_m 컬럼 (column 4): Python에서 계산된 값 사용 (Excel 수식 대신)
            ws.cell(row=row, column=4, value=round(defaults[&#34;x&#34;], 2))
        else:
            # stage_defaults에 없는 경우 기본값 설정
            print(
                f&#34;[WARNING] Stage &#39;{stage_name}&#39; not found in stage_defaults, using defaults&#34;
            )
            ws.cell(row=row, column=2, value=0.0)  # W_stage_t
            ws.cell(row=row, column=3, value=&#34;&#34;)  # Fr_stage
            ws.cell(row=row, column=4, value=0.0)  # x_stage_m

        ws.cell(row=row, column=2).fill = styles[&#34;input_fill&#34;]
        ws.cell(row=row, column=2).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=2).number_format = number_format
        ws.cell(row=row, column=3).fill = styles[&#34;input_fill&#34;]
        ws.cell(row=row, column=3).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=3).number_format = number_format
        ws.cell(row=row, column=4).fill = styles[&#34;input_fill&#34;]
        ws.cell(row=row, column=4).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=4).number_format = number_format

        # TM (t·m): Python stage_results(TM_LCF_tm) 우선, 없으면 기존 수식
        tm_val = stage_defaults.get(stage_name, {}).get(&#34;TM_LCF_tm&#34;)
        if tm_val is None:
            ws.cell(row=row, column=5).value = (
                f&#39;=IF(OR(B{row_str}=&#34;&#34;, D{row_str}=&#34;&#34;, $B$10=&#34;&#34;), &#34;&#34;, B{row_str} * (D{row_str} - $B$10))&#39;
            )
        else:
            ws.cell(row=row, column=5).value = float(tm_val)
        ws.cell(row=row, column=5).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=5).number_format = number_format

        # Trim_cm: Python stage_results(Trim_cm) 우선, 없으면 E/B9
        trim_val = stage_defaults.get(stage_name, {}).get(&#34;Trim_cm&#34;)
        if trim_val is None:
            ws.cell(row=row, column=6).value = (
                f&#39;=IF(OR(E{row_str}=&#34;&#34;, OR($B$9=&#34;&#34;, $B$9=0)), &#34;&#34;, E{row_str} / $B$9)&#39;
            )
        else:
            ws.cell(row=row, column=6).value = float(trim_val)
        ws.cell(row=row, column=6).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=6).number_format = number_format
        # FWD_precise_m / AFT_precise_m:
        # - Python stage_results(Dfwd/Daft) 값을 우선 사용하여 LCF-aware 계산 결과 사용
        # - Excel 수식(B6 ± F/2)은 LCF를 고려하지 않으므로 정확도가 낮음
        # - 모든 Stage에 Python 계산 결과를 사용하여 일관성 유지
        dfwd_val = None
        daft_val = None

        # 1순위: stage_results에서 직접 가져오기
        if stage_name in stage_results:
            res = stage_results[stage_name]
            dfwd_val = res.get(&#34;Dfwd_m&#34;)
            daft_val = res.get(&#34;Daft_m&#34;)

        # 2순위: stage_defaults에서 가져오기
        if dfwd_val is None or daft_val is None:
            defaults = stage_defaults.get(stage_name, {})
            dfwd_val = defaults.get(&#34;FWD_precise_m&#34;) or defaults.get(&#34;Dfwd_m&#34;)
            daft_val = defaults.get(&#34;AFT_precise_m&#34;) or defaults.get(&#34;Daft_m&#34;)

        # 값이 있으면 Python 계산 결과 사용 (LCF-aware)
        if dfwd_val is not None and daft_val is not None:
            ws.cell(row=row, column=7).value = float(dfwd_val)
            ws.cell(row=row, column=8).value = float(daft_val)
        else:
            # DEBUG: 이 경우는 발생하지 않아야 합니다
            # 모든 Stage는 stage_results에 있어야 하므로, 여기 도달하면 문제가 있습니다
            if stage_name not in [
                &#34;Stage 1&#34;,
                &#34;Stage 7&#34;,
            ]:  # Stage 1, 7은 값이 없을 수 있음
                logging.warning(
                    f&#34;[FWD_Draft] {stage_name}: Python 값 없음, Excel 수식 사용. &#34;
                    f&#34;stage_results 키: {list(stage_results.keys())[:3]}...&#34;
                )
            # 최종 fallback: Excel 수식 사용 (부정확하지만 계산은 가능)
            ws.cell(row=row, column=7).value = (
                f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;,$B$6 - (F{row_str}/100)/2)&#39;
            )
            ws.cell(row=row, column=8).value = (
                f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;,$B$6 + (F{row_str}/100)/2)&#39;
            )

        ws.cell(row=row, column=7).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=7).number_format = number_format
        ws.cell(row=row, column=8).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=8).number_format = number_format

        if stage_name == &#34;Stage 5&#34;:
            trim5_row = row

        # v4.0: G 컬럼이 AFT_precise_m로 변경되므로 target_trim은 제거
        # target_trim은 이제 사용되지 않음 (G가 AFT_precise_m로 계산됨)
        # target_trim = target_trim_by_stage.get(stage_name)
        # if target_trim is not None:
        #     ws.cell(row=row, column=8).value = target_trim
        #     ws.cell(row=row, column=8).fill = styles[&#34;input_fill&#34;]

        # I (9): ΔTM_cm_tm - PATCH B2-3: (Target − Actual) × MTC (reversed direction)
        # 수식: =IF($A{row}=&#34;&#34;,&#34;&#34;, (IF($R{row}=&#34;&#34;,$B$8,$R{row}) - F{row}) * $B$9)
        # 의미:
        #   - F{row} = 실제 Trim_cm
        #   - $R{row} = Stage별 Trim_target_stage_cm (R열, Trim_gate_cm)
        #   - IF($R{row}=&#34;&#34;,$B$8,$R{row}) = R열이 비어있으면 전역 타깃(B8) 사용, 있으면 Stage별 타깃 사용
        #   - $B$9 = MTC (t·m/cm)
        #   - 결과: (Target - Actual) × MTC = 필요한 Trim 모멘트 변화량 (cm·t·m)
        #   - 양수 = Target &gt; Actual → 추가 ballast 필요 (stern down)
        #   - 음수 = Target &lt; Actual → De-ballast 필요 (bow down)
        ws.cell(row=row, column=9).value = (
            f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;,&#39;
            f&#39;(IF($R{row_str}=&#34;&#34;,$B$8,$R{row_str}) - F{row_str}) * $B$9)&#39;
        )
        ws.cell(row=row, column=9).number_format = number_format
        ws.cell(row=row, column=9).font = styles[&#34;normal_font&#34;]
        # J (10): Lever_arm_m - Ballast 레버 암 고정식
        # 수식: =IF(OR(ISBLANK($B$14), ISBLANK($B$10), ISBLANK($B$15), ISERROR($B$10)), &#34;&#34;, ROUND($B$14 - ($B$10 + $B$15/2), 2))
        # 의미:
        #   - $B$14 = X_Ballast_from_AP_m (Ballast CG 위치, 예: 52.50 m)
        #   - $B$10 = LCF_from_midship
        #   - $B$15 = Lpp
        #   - LCF_from_AP = B10 + B15/2
        #   - Lever_arm = X_Ballast_from_AP - LCF_from_AP (예: 21.59 m)
        #   - Stage별로 변하지 않는 상수 레버 암
        ws.cell(row=row, column=10).value = (
            f&#39;=IF(OR(ISBLANK($B$14), ISBLANK($B$10), ISBLANK($B$15), ISERROR($B$10)), &#34;&#34;, ROUND($B$14 - ($B$10 + $B$15/2), 2))&#39;
        )
        ws.cell(row=row, column=10).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=10).number_format = number_format
        # K (11): Ballast_t_calc - 새 설계 핵심: ΔTM / Lever_arm = 이론상 필요한 Ballast 톤수
        # 수식: =IF(OR($A{row}=&#34;&#34;,$J{row}=&#34;&#34;, $J{row}=0), &#34;&#34;, ROUND(I{row} / $J{row}, 2))
        # 의미:
        #   - I{row} = ΔTM_cm_tm (column 9)
        #   - $J{row} = Lever_arm_m (column 10)
        #   - Ballast_t_calc = ΔTM / Lever_arm (이론상 필요한 Ballast 무게, t)
        #   - A열 Stage 이름이 비어있거나, 레버 암(J)이 0/공백이면 빈 셀 유지
        ws.cell(row=row, column=11).value = (
            f&#39;=IF(OR($A{row_str}=&#34;&#34;,$J{row_str}=&#34;&#34;, $J{row_str}=0),&#34;&#34;,ROUND(I{row_str} / $J{row_str}, 2))&#39;
        )
        ws.cell(row=row, column=11).number_format = number_format
        ws.cell(row=row, column=11).font = styles[&#34;normal_font&#34;]
        # L (12): Ballast_time_h_calc - 펌프 시간 계산
        # 수식: =IF(OR(K{row}=&#34;&#34;, $B$13=&#34;&#34;, $B$13=0, ISERROR($B$13)), &#34;&#34;, ROUND(K{row} / $B$13, 2))
        # 의미:
        #   - K{row} = Ballast_t_calc (column 11)
        #   - $B$13 = pump_rate_effective_tph (펌프 속도, t/h)
        #   - Ballast_time_h_calc = Ballast_t_calc / Pump_rate (펌프에 소요되는 시간, h)
        ws.cell(row=row, column=12).value = (
            f&#39;=IF(OR(K{row_str}=&#34;&#34;, $B$13=&#34;&#34;, $B$13=0, ISERROR($B$13)), &#34;&#34;, ROUND(ABS(K{row_str}) / $B$13, 2))&#39;
        )
        ws.cell(row=row, column=12).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=12).number_format = number_format
        # L (12): Ballast_t - v4.0: G가 FWD_precise_m로 변경되었으므로 Trim_m은 F/100 사용
        ws.cell(row=row, column=13).value = (
            f&#39;=IF(OR(F{row_str}=&#34;&#34;, OR($B$12=&#34;&#34;, $B$12=0)), &#34;&#34;, ROUND(ABS(F{row_str}/100) * 50 * $B$12, 2))&#39;
        )
        ws.cell(row=row, column=13).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=13).number_format = number_format
        # M (13): Ballast_time_h - L(Ballast_t)를 펌프 레이트(B13)로 나눈 시간
        # L = column 13 (Ballast_t)
        ws.cell(row=row, column=14).value = (
            f&#39;=IF(OR(L{row_str}=&#34;&#34;, $B$13=&#34;&#34;, $B$13=0, ISERROR($B$13)), &#34;&#34;, ROUND(L{row_str} / $B$13, 2))&#39;
        )
        ws.cell(row=row, column=14).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=14).number_format = number_format
        # N (14): Trim_Check - v4.0: G가 FWD_precise_m로 변경되었으므로 Trim_m은 F/100 사용
        ws.cell(row=row, column=15).value = (
            f&#39;=IF(F{row_str}=&#34;&#34;, &#34;&#34;, IF(ABS(F{row_str}/100) &lt;= ($B$15/50), &#34;OK&#34;, &#34;EXCESSIVE&#34;))&#39;
        )
        # P (16): Dfwd_m - FWD_precise_m 참조 (모든 Stage 동일)
        # Q (17): Daft_m - AFT_precise_m 참조 (모든 Stage 동일)
        # (하드코딩 제거 - Stage 5_PreBallast, Stage 6A_Critical도 수식으로 계산)
        ws.cell(row=row, column=16).value = (
            f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;,G{row_str})&#39;  # P (16): Dfwd_m
        )
        ws.cell(row=row, column=16).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=16).number_format = number_format
        ws.cell(row=row, column=17).value = (
            f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;,H{row_str})&#39;  # Q (17): Daft_m
        )
        ws.cell(row=row, column=17).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=17).number_format = number_format
        # R (18): Trim_target_stage_cm - Stage별 Trim 타깃 (새 설계)
        # Stage 설명 세트 기준으로 고정된 값:
        #   Stage 1: 0.00 (기준 Lightship, Trim 타깃 없음)
        #   Stage 2: -96.50 (TR1 램프 진입, 허용 범위 내 bow-down 목표)
        #   Stage 3: -96.50 (TR1 mid-ramp, 같은 목표 유지)
        #   Stage 4: -96.50 (TR1 온덱, 같은 목표 유지)
        #   Stage 5: -89.58 (TR1 aft stow 후 기준 상태)
        #   Stage 5_PreBallast: 240.00 (D-1 Pre-ballast, 의도적 stern trim; FW2 Fr.0-6)
        #   Stage 6A_Critical (Opt C): 0.00 (TR2 램프 진입 시 Even Keel 목표)
        #   Stage 6C_TotalMassOpt: -96.50 (최대 변위 Sensitivity case)
        #   Stage 6C: -96.50 (Planned final stowage 기준값)
        #   Stage 7: 0.00 (최종 Lightship/Reference)
        # 이 값은 ΔTM_cm_tm 계산 시 사용됨 (R열이 비어있으면 전역 B8 사용)
        target_trim = target_trim_by_stage.get(stage_name)
        ws.cell(row=row, column=18).value = target_trim
        ws.cell(row=row, column=18).number_format = number_format
        ws.cell(row=row, column=18).fill = styles[&#34;input_fill&#34;]
        ws.cell(row=row, column=18).font = styles[&#34;normal_font&#34;]
        # S (19): FWD_DeckElev_CD_m - Chart Datum 기준 Deck Elevation (Tide 포함)
        # P = column 16 (Dfwd_m)
        ws.cell(row=row, column=19).value = (
            f&#39;=IF(P{row_str}=&#34;&#34;, &#34;&#34;, $B$11 - P{row_str} + $B$7)&#39;
        )
        ws.cell(row=row, column=19).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=19).number_format = number_format
        # T (20): AFT_DeckElev_CD_m - Chart Datum 기준 Deck Elevation (Tide 포함)
        # Q = column 17 (Daft_m)
        ws.cell(row=row, column=20).value = (
            f&#39;=IF(Q{row_str}=&#34;&#34;, &#34;&#34;, $B$11 - Q{row_str} + $B$7)&#39;
        )
        ws.cell(row=row, column=20).font = styles[&#34;normal_font&#34;]
        ws.cell(row=row, column=20).number_format = number_format

        # T (20): Notes - 제거됨 (G4-G15로 이동)
        # Notes는 더 이상 T(20) 컬럼에 배치하지 않음

        # U-AE 컬럼은 extend_roro_captain_req()에서 작성됨

        # PATCH C-2: New columns for iterative ballast correction (AF-AJ, column 32-36)
        # AF (32): Trim_gate_cm - Required trim to satisfy FWD limit (from B2 calculation)
        trim_gate_cm = target_trim_by_stage.get(stage_name, 0.0)
        ws.cell(row=row, column=32).value = trim_gate_cm
        ws.cell(row=row, column=32).number_format = number_format
        ws.cell(row=row, column=32).font = styles[&#34;normal_font&#34;]

        # AG (33): Gate_Ballast_net_t - Final ballast after iteration
        # AH (34): Dfwd_gate_m - Final forward draft after ballast correction
        # AI (35): Gate_iter_n - Number of iterations used
        # AJ (36): Gate_Flag - OK/LIMIT flag

        # Perform iterative ballast correction if stage has results
        if stage_name in stage_results:
            res = stage_results[stage_name]

            # Get loads for this stage (includes preballast if applicable)
            stage_loads = build_stage_loads(stage_name, preballast_opt, params)

            # Extract current ballast from loads as initial estimate
            # Look for PreBallast LoadItem in the loads
            initial_ballast = 0.0
            for load in stage_loads:
                if load.name == &#34;PreBallast&#34;:
                    initial_ballast = load.weight_t
                    break

            # If no PreBallast found, use Ballast_t_calc from stage results as fallback
            if abs(initial_ballast) &lt; 0.01:
                initial_ballast = float(
                    res.get(&#34;Ballast_t_calc&#34;, res.get(&#34;Ballast_t&#34;, 0.0)) or 0.0
                )

            # Perform iterative correction to find ballast needed for Dfwd = 2.70m
            correction_result = iterative_ballast_correction(
                base_disp_t=base_disp_t,
                base_tmean_m=base_tmean_m,
                loads=stage_loads,
                initial_ballast_t=initial_ballast,
                fwd_limit_m=2.70,
                max_iterations=3,
                tolerance_m=0.01,
                **params,
            )

            # AG (33): Gate_Ballast_net_t
            ws.cell(row=row, column=33).value = correction_result[&#34;ballast_t&#34;]
            ws.cell(row=row, column=33).number_format = number_format
            ws.cell(row=row, column=33).font = styles[&#34;normal_font&#34;]

            # AH (34): Dfwd_gate_m
            ws.cell(row=row, column=34).value = correction_result[&#34;dfwd_gate_m&#34;]
            ws.cell(row=row, column=34).number_format = number_format
            ws.cell(row=row, column=34).font = styles[&#34;normal_font&#34;]

            # AI (35): Gate_iter_n
            ws.cell(row=row, column=35).value = correction_result[&#34;iterations&#34;]
            ws.cell(row=row, column=35).number_format = &#34;0&#34;
            ws.cell(row=row, column=35).font = styles[&#34;normal_font&#34;]

            # AJ (36): Gate_Flag
            flag = correction_result[&#34;flag&#34;]
            ws.cell(row=row, column=36).value = flag
            ws.cell(row=row, column=36).font = styles[&#34;normal_font&#34;]
            if flag == &#34;OK&#34;:
                ws.cell(row=row, column=36).fill = styles[&#34;ok_fill&#34;]
            else:
                ws.cell(row=row, column=36).fill = styles[&#34;ng_fill&#34;]
        else:
            # No stage results, leave columns empty
            for col in [33, 34, 35, 36]:
                ws.cell(row=row, column=col).value = &#34;&#34;
                ws.cell(row=row, column=col).font = styles[&#34;normal_font&#34;]

    # ===============================================================
    # REMOVED: Old logic that manually added &#34;Stage 6C_TotalMassOpt&#34; row
    # Stage 6C_TotalMassOpt is now included in stages list
    # and is handled in the main stage loop above (lines 4582-4700)
    # ===============================================================

    from openpyxl.workbook.defined_name import DefinedName

    wb.defined_names[&#34;MTC&#34;] = DefinedName(
        &#34;MTC&#34;, attr_text=&#34;&#39;RORO_Stage_Scenarios&#39;!$B$9&#34;
    )
    wb.defined_names[&#34;LCF&#34;] = DefinedName(
        &#34;LCF&#34;, attr_text=&#34;&#39;RORO_Stage_Scenarios&#39;!$B$10&#34;
    )
    wb.defined_names[&#34;PumpRate&#34;] = DefinedName(
        &#34;PumpRate&#34;, attr_text=&#34;&#39;RORO_Stage_Scenarios&#39;!$B$13&#34;
    )
    wb.defined_names[&#34;X_Ballast&#34;] = DefinedName(
        &#34;X_Ballast&#34;, attr_text=&#34;&#39;RORO_Stage_Scenarios&#39;!$B$14&#34;
    )

    if trim5_row is not None:
        wb.defined_names[&#34;TRIM5_CM&#34;] = DefinedName(
            &#34;TRIM5_CM&#34;, attr_text=f&#34;&#39;RORO_Stage_Scenarios&#39;!$E${trim5_row}&#34;
        )

    widths = {
        &#34;A&#34;: 18,
        &#34;B&#34;: 11,
        &#34;C&#34;: 11,
        &#34;D&#34;: 13,
        &#34;E&#34;: 10,
        &#34;F&#34;: 9,
        &#34;G&#34;: 13,
        &#34;H&#34;: 12,
        &#34;I&#34;: 11,
        &#34;J&#34;: 13,
        &#34;K&#34;: 15,
        &#34;L&#34;: 11,
        &#34;M&#34;: 15,
        &#34;N&#34;: 13,
        &#34;O&#34;: 10,
        &#34;P&#34;: 10,
        &#34;Q&#34;: 13,
        &#34;R&#34;: 13,
        &#34;S&#34;: 40,
    }
    for col_letter, width in widths.items():
        ws.column_dimensions[col_letter].width = width
    ws.freeze_panes = &#34;G2&#34;  # 기존 파일과 동일하게 G2

    # Opt C Stage 정보 출력 (DAS Method v4.3 Final Optimized)
    opt_c_data = build_opt_c_stage(preballast_opt)
    print(
        f&#34;  [INFO] Opt C Updated (DAS Method v4.3 Final): W={opt_c_data[&#39;weight_t&#39;]:.1f}t (Cargo 560t + Ballast {preballast_opt:.1f}t), LCG={opt_c_data[&#39;x_from_mid_m&#39;]:.2f}m (Even Keel 근접)&#34;
    )

    print(&#34;  [OK] RORO_Stage_Scenarios sheet created&#34;)

    # 전체 행 수 계산 (모든 Stage 포함)
    total_rows = len(stages)

    # 7) ΔTM &amp; Lever_arm Python 재계산 리포트 시트 생성
    #    - Stage별 Trim / Trim_target / MTC / X_ballast / LCF / Lpp 기반
    #    - RORO_Stage_Scenarios Stage 테이블(엑셀 수식)과 숫자 비교용
    create_roro_delta_lever_report_sheet(
        wb=wb,
        stage_results=stage_results,
        trim_target_map=TRIM_TARGET_MAP,
    )

    # 8) Draft / Freeboard Margin 체크 시트
    create_roro_draft_margin_check_sheet(
        wb=wb,
        stage_results=stage_results,
        roro_sheet_name=&#34;RORO_Stage_Scenarios&#34;,
        fwd_limit_m=2.70,
        linkspan_min_freeboard_m=0.28,
    )

    # 9) Stability GM 체크 시트
    create_roro_stability_gm_check_sheet(
        wb=wb,
        stage_results=stage_results,
        hydro_sheet_name=&#34;Hydro_Table&#34;,
        gm_target_m=1.50,
    )

    # 10) 옵션 1/2/3 시나리오 자동 Summary → 비교 시트
    scenario_stage_map = {
        # ⚠️ 여기 Stage 이름은 실제 RORO_Stage_Scenarios의 Stage 값에 맞게 조정 필요
        &#34;Option 1 – Pre-ballast Only&#34;: [&#34;Stage 5_PreBallast&#34;],
        &#34;Option 2 – D-Day Dynamic&#34;: [&#34;Stage 6A_Critical (Opt C)&#34;],
        &#34;Option 3 – Split Stage&#34;: [&#34;Stage 6A_Critical (Opt C)&#34;, &#34;Stage 6C&#34;],
    }
    pump_rate_effective = 100.0  # t/h (Calc 시트 값과 동일하게 맞추면 됨)

    scenario_summary = build_ballast_scenarios_from_stage_results(
        stage_results=stage_results,
        scenario_stage_map=scenario_stage_map,
        pump_rate_tph=pump_rate_effective,
        fwd_limit_m=2.70,
        linkspan_min_freeboard_m=0.28,
    )

    create_ballast_scenario_comparison_sheet(
        wb=wb,
        scenarios=scenario_summary,
        sheet_name=&#34;Ballast_Scenario_Comparison&#34;,
    )

    # ============================================================
    # Option B+ add-ons: IS Code / Acceptance / Structural / CSM
    # ============================================================
    try:
        enrich_stage_results_bplus(stage_results=stage_results, env=params.get(&#34;env&#34;))
        csm_trace = build_csm_trace(stage_results=stage_results)

        create_iscode_check_sheet(wb, stage_results, sheet_name=&#34;RORO_ISCODE_Check&#34;)
        create_acceptance_criteria_sheet(
            wb, stage_results, sheet_name=&#34;MWS_Acceptance_Criteria&#34;
        )
        create_structural_gate_sheet(
            wb, stage_results, sheet_name=&#34;RORO_Structural_Gate&#34;
        )
        create_csm_trace_sheet(wb, csm_trace, sheet_name=&#34;CSM_Trace&#34;)
        create_mws_pack_index_sheet(wb, sheet_name=&#34;MWS_Pack_Index&#34;)
    except Exception as e:
        logging.warning(f&#34;[BPLUS] Optional add-on sheets skipped: {e}&#34;)

    return stages_list, first_data_row, len(stages_list)</code></pre>
</details>
<div class="desc"><p>RORO_Stage_Scenarios 생성 (build_stage_loads + solve_stage 기반)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_stability_gm_check_sheet"><code class="name flex">
<span>def <span class="ident">create_roro_stability_gm_check_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>stage_results: Dict[str, Dict[str, float]],<br>hydro_sheet_name: str = 'Hydro_Table',<br>gm_target_m: float = 1.5) ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_roro_stability_gm_check_sheet(
    wb: Workbook,
    stage_results: Dict[str, Dict[str, float]],
    hydro_sheet_name: str = &#34;Hydro_Table&#34;,
    gm_target_m: float = 1.50,
) -&gt; Worksheet:
    &#34;&#34;&#34;
    Hydro_Table 기반 Stage별 GM 계산 / 체크 시트.

    가정:
    - Hydro_Table 시트:
      A열: Disp_t
      B열: GM_m
    - stage_results[stage][&#39;Disp_t&#39;] 값이 존재한다고 가정 (없으면 해당 Stage skip)
    &#34;&#34;&#34;
    styles = get_styles()
    number_format = &#34;#,##0.000&#34;

    if hydro_sheet_name not in wb.sheetnames:
        print(f&#34;[WARN] &#39;{hydro_sheet_name}&#39; 시트 없음. GM 체크 생략.&#34;)
        return wb.create_sheet(&#34;RORO_Stability_Check&#34;)

    ws_h = wb[hydro_sheet_name]

    # Hydro table 로드
    disp_list = []
    gm_list = []
    for row in range(2, ws_h.max_row + 1):
        d = ws_h[f&#34;A{row}&#34;].value
        g = ws_h[f&#34;B{row}&#34;].value
        try:
            d = float(d)
            g = float(g)
        except (TypeError, ValueError):
            continue
        disp_list.append(d)
        gm_list.append(g)

    if not disp_list:
        print(&#34;[WARN] Hydro_Table에 유효한 Δ-GM 데이터 없음.&#34;)
        return wb.create_sheet(&#34;RORO_Stability_Check&#34;)

    # 정렬
    paired = sorted(zip(disp_list, gm_list), key=lambda x: x[0])
    disp_list = [p[0] for p in paired]
    gm_list = [p[1] for p in paired]

    def interp_gm(disp: float) -&gt; float:
        if disp &lt;= disp_list[0]:
            return gm_list[0]
        if disp &gt;= disp_list[-1]:
            return gm_list[-1]
        for i in range(1, len(disp_list)):
            if disp_list[i] &gt;= disp:
                x0, y0 = disp_list[i - 1], gm_list[i - 1]
                x1, y1 = disp_list[i], gm_list[i]
                if x1 == x0:
                    return y0
                ratio = (disp - x0) / (x1 - x0)
                return y0 + (y1 - y0) * ratio
        return gm_list[-1]

    ws = wb.create_sheet(&#34;RORO_Stability_Check&#34;)

    title = ws[&#34;A1&#34;]
    title.value = f&#34;RORO Stage Stability Check (GM Target={gm_target_m:.2f} m)&#34;
    title.font = styles[&#34;title_font&#34;]

    header_row = 3
    headers = [
        &#34;Stage&#34;,
        &#34;Disp_t&#34;,
        &#34;GM_Calc_m&#34;,
        &#34;GM_Target_m&#34;,
        &#34;GM_Margin_m&#34;,
        &#34;GM_Check (OK/CHECK)&#34;,
    ]
    for col, h in enumerate(headers, start=1):
        c = ws.cell(row=header_row, column=col, value=h)
        c.font = styles[&#34;header_font&#34;]
        c.fill = styles[&#34;header_fill&#34;]

    current_row = header_row + 1
    for stage_name, res in stage_results.items():
        disp = res.get(&#34;Disp_t&#34;)
        try:
            disp = float(disp) if disp is not None else None
        except (TypeError, ValueError):
            disp = None

        if disp is None or disp &lt;= 0.0:
            continue

        gm_calc = interp_gm(disp)
        gm_margin = gm_calc - gm_target_m
        gm_flag = &#34;OK&#34; if gm_calc &gt;= gm_target_m else &#34;CHECK&#34;

        ws.cell(row=current_row, column=1, value=stage_name).font = styles[
            &#34;normal_font&#34;
        ]

        def _num(col_idx: int, v: float):
            c = ws.cell(row=current_row, column=col_idx, value=round(v, 3))
            c.font = styles[&#34;normal_font&#34;]
            c.number_format = number_format

        _num(2, disp)
        _num(3, gm_calc)
        _num(4, gm_target_m)
        _num(5, gm_margin)
        ws.cell(row=current_row, column=6, value=gm_flag).font = styles[&#34;normal_font&#34;]

        current_row += 1

    for col in range(1, len(headers) + 1):
        ws.column_dimensions[get_column_letter(col)].width = 22

    print(&#34;  [OK] RORO_Stability_Check sheet created&#34;)
    return ws</code></pre>
</details>
<div class="desc"><p>Hydro_Table 기반 Stage별 GM 계산 / 체크 시트.</p>
<p>가정:
- Hydro_Table 시트:
A열: Disp_t
B열: GM_m
- stage_results[stage]['Disp_t'] 값이 존재한다고 가정 (없으면 해당 Stage skip)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_structural_gate_sheet"><code class="name flex">
<span>def <span class="ident">create_structural_gate_sheet</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>stage_results: dict,<br>sheet_name: str = 'RORO_Structural_Gate') ‑> openpyxl.worksheet.worksheet.Worksheet</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_structural_gate_sheet(
    wb: Workbook, stage_results: dict, sheet_name: str = &#34;RORO_Structural_Gate&#34;
) -&gt; Worksheet:
    ws = (
        wb.create_sheet(sheet_name)
        if sheet_name not in wb.sheetnames
        else wb[sheet_name]
    )
    styles = get_styles()
    ws[&#34;A1&#34;] = &#34;Structural Gate – Deck / Ramp / Point Load (data-driven)&#34;
    ws[&#34;A1&#34;].font = styles[&#34;title_font&#34;]

    headers = [&#34;Stage&#34;, &#34;Available&#34;, &#34;PASS&#34;, &#34;Missing&#34;, &#34;Checks (key: value op limit)&#34;]
    for c, h in enumerate(headers, start=1):
        cell = ws.cell(row=3, column=c, value=h)
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]

    r = 4
    for stage_id, res in stage_results.items():
        stc = (res.get(&#34;BPLUS&#34;) or {}).get(&#34;Structural&#34;) or {}
        avail = bool(stc.get(&#34;available&#34;))
        passed = bool(stc.get(&#34;pass&#34;)) if avail else False
        ws.cell(r, 1, stage_id)
        ws.cell(r, 2, &#34;Y&#34; if avail else &#34;N&#34;)
        ws.cell(r, 3, &#34;PASS&#34; if passed else &#34;FAIL&#34;)
        ws.cell(r, 4, stc.get(&#34;missing&#34;, &#34;&#34;))
        checks = stc.get(&#34;checks&#34;) or {}
        parts = []
        for k, v in checks.items():
            if not isinstance(v, dict):
                continue
            parts.append(f&#34;{k}:{v.get(&#39;value&#39;)} {v.get(&#39;op&#39;)} {v.get(&#39;limit&#39;)}&#34;)
        ws.cell(r, 5, &#34;; &#34;.join(parts))
        r += 1

    ws.freeze_panes = &#34;A4&#34;
    ws.column_dimensions[&#34;A&#34;].width = 26
    ws.column_dimensions[&#34;E&#34;].width = 80
    return ws</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_tide_sheet"><code class="name flex">
<span>def <span class="ident">create_tide_sheet</span></span>(<span>wb)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tide_sheet(wb):
    &#34;&#34;&#34;December_Tide_2025 시트 생성&#34;&#34;&#34;
    ws = wb.create_sheet(&#34;December_Tide_2025&#34;)
    styles = get_styles()

    headers = [&#34;datetime_gst&#34;, &#34;tide_m               (Chart Datum)&#34;]
    for col_idx, header in enumerate(headers, start=1):
        cell = ws.cell(row=1, column=col_idx)
        cell.value = header
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]
        cell.border = Border(
            left=styles[&#34;thin_border&#34;],
            right=styles[&#34;thin_border&#34;],
            top=styles[&#34;thin_border&#34;],
            bottom=styles[&#34;thin_border&#34;],
        )

    # JSON 파일 로드 (상대 경로 사용)
    tide_data = _load_json(&#34;data/gateab_v3_tide_data.json&#34;)

    if tide_data:
        try:
            for idx, entry in enumerate(tide_data, start=0):
                row = 2 + idx
                if row &gt; 745:
                    break

                cell_a = ws.cell(row=row, column=1)
                cell_a.value = entry.get(&#34;datetime&#34;, &#34;&#34;)
                cell_a.font = styles[&#34;normal_font&#34;]

                cell_b = ws.cell(row=row, column=2)
                cell_b.value = entry.get(&#34;tide_m&#34;, 0.0)
                cell_b.font = styles[&#34;normal_font&#34;]
                cell_b.number_format = &#34;0.00&#34;
            print(f&#34;  [OK] December_Tide_2025 sheet created with {len(tide_data)} rows&#34;)
        except Exception as e:
            print(f&#34;  [WARNING] Error processing tide data: {e}. Creating empty sheet.&#34;)
            tide_data = None

    if not tide_data:
        print(
            f&#34;  [WARNING] JSON file not found. Creating empty December_Tide_2025 sheet.&#34;
        )
        for row in range(2, 746):
            ws.cell(row=row, column=1).font = styles[&#34;normal_font&#34;]
            ws.cell(row=row, column=2).font = styles[&#34;normal_font&#34;]
            ws.cell(row=row, column=2).number_format = &#34;0.00&#34;

    ws.column_dimensions[&#34;A&#34;].width = 20
    ws.column_dimensions[&#34;B&#34;].width = 15</code></pre>
</details>
<div class="desc"><p>December_Tide_2025 시트 생성</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_workbook_from_scratch"><code class="name flex">
<span>def <span class="ident">create_workbook_from_scratch</span></span>(<span>const_csv_path: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_workbook_from_scratch(const_csv_path: str = None):
    &#34;&#34;&#34;워크북을 처음부터 생성 (BACKUP PLAN integrated + Option B-2 CSV support)

    Args:
        const_csv_path: CONST_TANKS CSV 파일 경로 (Option B-2, 선택 사항)
    &#34;&#34;&#34;
    print(&#34;=&#34; * 80)
    print(&#34;LCT_BUSHRA_AGI_TR.xlsx Creation from Scratch (BACKUP PLAN enabled)&#34;)
    if const_csv_path:
        print(f&#34;Option B-2: Using CSV for CONST_TANKS: {const_csv_path}&#34;)
    print(&#34;=&#34; * 80)

    # Option B+ (Engineering-grade) input gate: auto-search ./bplus_inputs and stop if missing
    _bplus_preflight_or_zero(strict=True)

    # BACKUP PLAN: Pre-flight check
    print(&#34;\n[PRE-FLIGHT CHECK]&#34;)
    issues = preflight_check()

    # PHASE 0: Tank JSON auto-generation
    try:
        from src.tank_data_manager import ensure_tank_jsons

        logging.info(&#34;[PRE-FLIGHT] Checking tank data files&#34;)
        success, msg = ensure_tank_jsons(&#34;Tank Capacity_Plan.xlsx&#34;, &#34;data/&#34;)
        if success:
            logging.info(f&#34;[TANK] {msg}&#34;)
            print(f&#34;  [OK] {msg}&#34;)
        else:
            issues.append(f&#34;WARNING: {msg}&#34;)
            print(f&#34;  [WARNING] {msg}&#34;)
    except ImportError:
        issues.append(&#34;INFO: Tank auto-generation module not available&#34;)
        print(&#34;  [INFO] Tank auto-generation module not available&#34;)
    except Exception as e:
        issues.append(f&#34;WARNING: Tank JSON generation failed: {e}&#34;)
        print(f&#34;  [WARNING] Tank JSON generation failed: {e}&#34;)

    for issue in issues:
        print(f&#34;  {issue}&#34;)
    if any(&#34;ERROR&#34; in i for i in issues):
        print(&#34;\n[ABORT] Critical issues found. Exiting.&#34;)
        sys.exit(1)

    output_dir = os.path.dirname(OUTPUT_FILE)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
        print(f&#34;[OK] Created output directory: {output_dir}&#34;)

    final_output_file = OUTPUT_FILE
    if os.path.exists(OUTPUT_FILE):
        try:
            with open(OUTPUT_FILE, &#34;r+b&#34;):
                pass
        except PermissionError:
            timestamp = datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;)
            base_name = os.path.splitext(OUTPUT_FILE)[0]
            final_output_file = f&#34;{base_name}_{timestamp}.xlsx&#34;
            print(f&#34;[WARNING] Original file is open. Saving as: {final_output_file}&#34;)

    # BACKUP PLAN: Setup logging
    print(f&#34;\n[1/9] Setting up logging and workbook&#34;)
    log_file = setup_logging(final_output_file)
    logging.info(&#34;[1/9] Workbook creation started&#34;)

    wb = Workbook()
    wb.remove(wb.active)
    # Force Excel to recalculate formulas on open
    try:
        wb.calculation.calcMode = &#34;auto&#34;
        wb.calculation.fullCalcOnLoad = True
        wb.calculation.calcOnSave = True
    except Exception:
        pass

    # BACKUP PLAN: Safe sheet creation with error recovery
    print(f&#34;\n[2/9] Creating sheets (with error recovery):&#34;)
    logging.info(&#34;[2/9] Sheet creation phase started&#34;)

    safe_sheet_creation(wb, create_calc_sheet, &#34;Calc&#34;)
    safe_sheet_creation(wb, create_tide_sheet, &#34;December_Tide_2025&#34;)
    safe_sheet_creation(wb, create_hourly_sheet, &#34;Hourly_FWD_AFT_Heights&#34;)

    result = safe_sheet_creation(wb, create_roro_sheet, &#34;RORO_Stage_Scenarios&#34;)
    if result:
        if len(result) == 3:
            stages, first_data_row, total_rows = result
        else:
            # 이전 버전 호환성
            stages, first_data_row = result
            total_rows = len(stages)
    else:
        # BACKUP: Provide fallback values if RORO sheet creation fails
        logging.warning(&#34;[BACKUP] RORO sheet failed, using defaults&#34;)
        stages = []
        first_data_row = 19
        total_rows = 0

    safe_sheet_creation(wb, create_ballast_tanks_sheet, &#34;Ballast_Tanks&#34;)

    # Patch Option B-2: CONST_TANKS with CSV support
    const_rows, const_meta = load_const_tanks_snapshot(const_csv_path)
    safe_sheet_creation(
        wb, create_const_tanks_sheet, &#34;CONST_TANKS&#34;, const_rows, const_meta
    )

    safe_sheet_creation(wb, create_hydro_table_sheet, &#34;Hydro_Table&#34;)
    safe_sheet_creation(wb, create_frame_table_sheet, &#34;Frame_to_x_Table&#34;)

    if &#34;RORO_Stage_Scenarios&#34; in wb.sheetnames and stages:
        roro_ws = wb[&#34;RORO_Stage_Scenarios&#34;]
        logging.info(&#34;[3/9] Extending RORO sheet with additional columns&#34;)
        print(f&#34;\n[3/9] Extending RORO sheet&#34;)

        try:
            # 일반 Stage만 처리 (Optional Tuning Stages는 자체 수식 보유)
            extend_roro_captain_req(roro_ws, first_data_row, total_rows)
            extend_roro_structural_opt1(roro_ws, first_data_row, total_rows)
            extend_precision_columns(roro_ws, first_data_row, total_rows)

            # BC-BR 범위 추가 (Post-Solver Results &amp; Gate Verification)
            # pipeline_stage_QA.csv에서 데이터 로드
            from pathlib import Path
            stage_qa_path = None
            for pattern in [&#39;ssot/pipeline_stage_QA.csv&#39;, &#39;pipeline_out_*/ssot/pipeline_stage_QA.csv&#39;]:
                matches = list(Path(&#39;.&#39;).glob(pattern))
                if matches:
                    stage_qa_path = matches[-1]
                    break
            extend_roro_bc_br_range(roro_ws, first_data_row, total_rows, stage_qa_path)
        except Exception as e:
            logging.error(f&#34;[BACKUP] RORO extension failed: {e}&#34;)
            print(f&#34;  [BACKUP] Warning: RORO extension failed: {e}&#34;)

        # Create Excel Table after all columns are added
        from openpyxl.worksheet.table import Table, TableStyleInfo

        header_row = 18
        last_col = 70  # BC-BR 범위 추가로 70까지 확장
        last_col_letter = get_column_letter(last_col)

        # Verify all headers are strings before creating table
        for col in range(1, last_col + 1):
            cell = roro_ws.cell(row=header_row, column=col)
            if cell.value is not None and not isinstance(cell.value, str):
                cell.value = str(cell.value)
            elif cell.value is None or cell.value == &#34;&#34;:
                cell.value = f&#34;Unused_{col}&#34;

        try:
            table = Table(
                displayName=&#34;Stages&#34;,
                ref=f&#34;A{header_row}:{last_col_letter}{first_data_row + total_rows - 1}&#34;,
            )
            style = TableStyleInfo(
                name=&#34;TableStyleMedium9&#34;,
                showFirstColumn=False,
                showLastColumn=False,
                showRowStripes=True,
                showColumnStripes=False,
            )
            table.tableStyleInfo = style
            roro_ws.add_table(table)
            logging.info(&#34;[OK] Excel Table created&#34;)
            print(&#34;  [OK] Excel Table created successfully&#34;)
        except Exception as e:
            logging.warning(f&#34;[BACKUP] Excel Table creation failed: {e}&#34;)
            print(f&#34;  [BACKUP] Warning: Could not create Excel Table: {e}&#34;)

    # Create OPERATION SUMMARY sheet
    if stages:
        logging.info(&#34;[4/9] Creating OPERATION SUMMARY sheet&#34;)
        print(f&#34;\n[4/9] Creating OPERATION SUMMARY&#34;)
        safe_sheet_creation(
            wb, create_captain_report_sheet, &#34;OPERATION SUMMARY&#34;, stages, first_data_row
        )

    # Save workbook
    logging.info(f&#34;[5/9] Saving workbook: {final_output_file}&#34;)
    print(f&#34;\n[5/9] Saving workbook: {final_output_file}&#34;)

    # PATCH: Ensure calculation mode is set before saving
    try:
        wb.calculation.calcMode = &#34;auto&#34;
        wb.calculation.fullCalcOnLoad = True
        wb.calculation.calcOnSave = True
        print(
            &#34;  [PATCH] Excel calculation mode: AUTO (fullCalcOnLoad=True, calcOnSave=True)&#34;
        )
    except Exception as e:
        print(f&#34;  [WARN] Failed to set calculation mode: {e}&#34;)

    # PATCH: Verify G24, H24 values and formulas for Row 24, 25 before saving
    if &#34;RORO_Stage_Scenarios&#34; in wb.sheetnames:
        roro_ws = wb[&#34;RORO_Stage_Scenarios&#34;]
        print(&#34;  [VERIFY] Checking Row 24, 25 values and formulas:&#34;)
        for check_row in [24, 25]:
            stage_name = roro_ws.cell(row=check_row, column=1).value  # A column
            g_val = roro_ws.cell(
                row=check_row, column=7
            ).value  # G column (FWD_precise_m)
            h_val = roro_ws.cell(
                row=check_row, column=8
            ).value  # H column (AFT_precise_m)
            p_val = roro_ws.cell(
                row=check_row, column=16
            ).value  # P column (Dfwd_m formula)
            q_val = roro_ws.cell(
                row=check_row, column=17
            ).value  # Q column (Daft_m formula)
            u_val = roro_ws.cell(
                row=check_row, column=21
            ).value  # U column (GM formula)
            ab_val = roro_ws.cell(
                row=check_row, column=28
            ).value  # AB column (GM_calc formula)
            ac_val = roro_ws.cell(
                row=check_row, column=29
            ).value  # AC column (GM_Check formula)

            print(f&#34;    Row {check_row} ({stage_name}):&#34;)
            print(f&#34;      G7={g_val}, H8={h_val}&#34;)
            print(f&#34;      P16={p_val}, Q17={q_val}&#34;)
            print(f&#34;      U21={u_val}, AB28={ab_val}, AC29={ac_val}&#34;)

            # Check if G24/H24 have values (not None/empty)
            if g_val is None or (isinstance(g_val, str) and g_val.strip() == &#34;&#34;):
                print(f&#34;      [WARN] Row {check_row} G7 (FWD_precise_m) is empty!&#34;)
            if h_val is None or (isinstance(h_val, str) and h_val.strip() == &#34;&#34;):
                print(f&#34;      [WARN] Row {check_row} H8 (AFT_precise_m) is empty!&#34;)

    try:
        wb.save(final_output_file)
        logging.info(&#34;[OK] File saved successfully&#34;)
        print(f&#34;  [OK] File saved successfully&#34;)
    except Exception as e:
        logging.error(f&#34;[ERROR] Failed to save: {e}&#34;)
        print(f&#34;  [ERROR] Failed to save: {e}&#34;)
        sys.exit(1)

    # CSV Export (워크북 저장 후, 닫기 전)
    if &#34;RORO_Delta_Lever_Report&#34; in wb.sheetnames:
        try:
            csv_output_path = os.path.join(
                os.path.dirname(final_output_file), &#34;RORO_Delta_Lever_Report.csv&#34;
            )
            export_roro_delta_lever_report_to_csv(
                wb,
                sheet_name=&#34;RORO_Delta_Lever_Report&#34;,
                csv_path=csv_output_path,
            )
            logging.info(f&#34;[OK] CSV exported: {csv_output_path}&#34;)
        except Exception as e:
            logging.warning(f&#34;[WARNING] CSV export failed: {e}&#34;)
            print(f&#34;  [WARNING] CSV export failed: {e}&#34;)

    # WhatsApp Summary PNG Export (워크북 저장 후, 닫기 전)
    try:
        png_output_path = os.path.join(
            os.path.dirname(final_output_file), &#34;RORO_Summary.png&#34;
        )
        png_path = export_whatsapp_summary_png(
            wb,
            png_path=png_output_path,
            max_stage_lines=6,
        )
        if png_path:
            logging.info(f&#34;[OK] PNG exported: {png_path}&#34;)
    except Exception as e:
        logging.warning(f&#34;[WARNING] PNG export failed: {e}&#34;)
        print(f&#34;  [WARNING] PNG export failed: {e}&#34;)

    wb.close()

    # Optional: Excel COM full recalc to cache formula results (requires Excel + pywin32)
    if os.environ.get(&#34;EXCEL_COM_RECALC&#34;, &#34;&#34;).strip().lower() in (&#34;1&#34;, &#34;true&#34;, &#34;yes&#34;, &#34;y&#34;):
        try:
            com_script = Path(__file__).parent / &#34;excel_com_recalc_save.py&#34;
            out_path = os.environ.get(&#34;EXCEL_COM_RECALC_OUT&#34;, &#34;&#34;).strip()
            cmd = [sys.executable, str(com_script), &#34;--in&#34;, str(final_output_file)]
            if out_path:
                cmd += [&#34;--out&#34;, out_path]
            subprocess.run(cmd, check=False)
        except Exception as e:
            print(f&#34;  [WARN] Excel COM recalc skipped: {e}&#34;)

    # BACKUP PLAN: Create backup after successful save
    print(f&#34;\n[6/9] Creating backup&#34;)
    logging.info(&#34;[6/9] Creating backup file&#34;)
    backup_path = create_backup_file(final_output_file)

    # Verification
    logging.info(&#34;[7/9] Verification&#34;)
    print(f&#34;\n[7/9] Verification:&#34;)
    if os.path.exists(final_output_file):
        file_size = os.path.getsize(final_output_file) / 1024
        logging.info(f&#34;File created: {final_output_file}, Size: {file_size:.2f} KB&#34;)
        print(f&#34;  [OK] File created: {final_output_file}&#34;)
        print(f&#34;  [OK] File size: {file_size:.2f} KB&#34;)
        print(f&#34;  [OK] Sheets: {len(wb.sheetnames)}&#34;)
        if backup_path:
            print(f&#34;  [OK] Backup: {os.path.basename(backup_path)}&#34;)
        print(f&#34;  [OK] Log: {os.path.basename(log_file)}&#34;)
    else:
        logging.error(&#34;[ERROR] Output file was not created&#34;)
        print(f&#34;  [ERROR] Output file was not created&#34;)
        sys.exit(1)

    print(&#34;\n&#34; + &#34;=&#34; * 80)
    print(&#34;[SUCCESS] Workbook creation complete! (BACKUP PLAN active)&#34;)
    print(&#34;=&#34; * 80)
    logging.info(&#34;[SUCCESS] Workbook creation complete&#34;)</code></pre>
</details>
<div class="desc"><p>워크북을 처음부터 생성 (BACKUP PLAN integrated + Option B-2 CSV support)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>const_csv_path</code></strong></dt>
<dd>CONST_TANKS CSV 파일 경로 (Option B-2, 선택 사항)</dd>
</dl></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.debug_frame_mapping"><code class="name flex">
<span>def <span class="ident">debug_frame_mapping</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_frame_mapping():
    &#34;&#34;&#34;
    Frame_x_from_mid_m.json 기반으로 현재 SLOPE/OFFSET과
    주요 기준 Frame들의 x_from_mid_m를 출력하는 디버그 함수.
    &#34;&#34;&#34;
    print(&#34;=&#34; * 60)
    print(&#34;LCT BUSHRA Frame ↔ x Debug (757 TCP aligned)&#34;)
    print(&#34;=&#34; * 60)
    print(f&#34;_FRAME_SLOPE  = {_FRAME_SLOPE:.6f}&#34;)
    print(f&#34;_FRAME_OFFSET = {_FRAME_OFFSET:.3f}&#34;)
    test = {
        &#34;AP approx&#34;: 0.0,
        &#34;Midship (Lpp/2)&#34;: 30.151,
        &#34;FP approx&#34;: 60.30,
        &#34;FWB1/2 center 55&#34;: 55.0,
    }
    for label, fr in test.items():
        x = fr_to_x(fr)
        print(
            f&#34;{label:25}  Fr={fr:6.2f}  →  x={x:8.3f} m  ({&#39;FWD&#39; if x &lt; 0 else &#39;AFT&#39;})&#34;
        )
    print(&#34;=&#34; * 60)
    sys.exit(0)</code></pre>
</details>
<div class="desc"><p>Frame_x_from_mid_m.json 기반으로 현재 SLOPE/OFFSET과
주요 기준 Frame들의 x_from_mid_m를 출력하는 디버그 함수.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.debug_tank_lcg_check"><code class="name flex">
<span>def <span class="ident">debug_tank_lcg_check</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_tank_lcg_check():
    &#34;&#34;&#34;
    757 TCP LCG(AP) → midship x → Frame 역산 self-check.
    설계 검증용으로만 사용.
    &#34;&#34;&#34;
    MIDSHIP_LCG_FROM_AP = 30.151
    tank_lcg_ap = {
        &#34;FWB1&#34;: 57.519,
        &#34;FWB2&#34;: 50.038,
        &#34;FWCARGO1&#34;: 42.750,
        &#34;FWCARGO2&#34;: 35.250,
    }

    print(&#34;[DEBUG] Tank LCG(AP) → x_from_mid → Frame&#34;)
    for name, lcg_ap in tank_lcg_ap.items():
        x_from_mid = MIDSHIP_LCG_FROM_AP - lcg_ap
        fr_est = x_to_fr(x_from_mid)
        print(
            f&#34;  {name:8}  LCG(AP)={lcg_ap:7.3f}  x_mid={x_from_mid:8.3f}  → Fr_est={fr_est:6.2f}&#34;
        )</code></pre>
</details>
<div class="desc"><p>757 TCP LCG(AP) → midship x → Frame 역산 self-check.
설계 검증용으로만 사용.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.draft_from_trim"><code class="name flex">
<span>def <span class="ident">draft_from_trim</span></span>(<span>trim_cm: float, params: dict | None = None) ‑> tuple[float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draft_from_trim(trim_cm: float, params: dict | None = None) -&gt; tuple[float, float]:
    &#34;&#34;&#34;
    Return (FWD, AFT) draft [m].

    Excel Stage 시트 로직과 동일:
        Tmean_baseline_m 은 모든 Stage에서 동일하다고 가정.
        부호 규칙:
            Trim_cm &lt; 0  → 선수침 (FWD 깊어짐)
            Trim_cm &gt; 0  → 선미침 (AFT 깊어짐)

        Fwd = Tmean + Trim_cm / 200
        Aft = Tmean - Trim_cm / 200
    &#34;&#34;&#34;
    if params is None:
        params = DEFAULT_PARAMS
    tmean = params.get(&#34;Tmean_baseline_m&#34;, 2.00)
    trim_m = trim_cm / 100.0
    fwd = tmean + trim_m / 2.0
    aft = tmean - trim_m / 2.0
    # Excel과 맞추기 위해 2자리 반올림
    return round(fwd, 2), round(aft, 2)</code></pre>
</details>
<div class="desc"><p>Return (FWD, AFT) draft [m].</p>
<p>Excel Stage 시트 로직과 동일:
Tmean_baseline_m 은 모든 Stage에서 동일하다고 가정.
부호 규칙:
Trim_cm &lt; 0
→ 선수침 (FWD 깊어짐)
Trim_cm &gt; 0
→ 선미침 (AFT 깊어짐)</p>
<pre><code>Fwd = Tmean + Trim_cm / 200
Aft = Tmean - Trim_cm / 200
</code></pre></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.enrich_stage_results_bplus"><code class="name flex">
<span>def <span class="ident">enrich_stage_results_bplus</span></span>(<span>stage_results: dict, env: dict | None = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enrich_stage_results_bplus(stage_results: dict, env: dict | None = None) -&gt; None:
    &#34;&#34;&#34;
    Enrich stage_results in-place with BPLUS checks.
    Adds: stage_results[stage][&#34;BPLUS&#34;] = {ISCODE, Acceptance, Structural}
    &#34;&#34;&#34;
    for stage_id, res in stage_results.items():
        try:
            res[&#34;BPLUS&#34;] = res.get(&#34;BPLUS&#34;, {})
            res[&#34;BPLUS&#34;][&#34;ISCODE&#34;] = iscode_general_check(
                stage_id, gm0_m=_as_float(res.get(&#34;GM_m&#34;))
            )
            res[&#34;BPLUS&#34;][&#34;Acceptance&#34;] = evaluate_acceptance(res, env=env)
            res[&#34;BPLUS&#34;][&#34;Structural&#34;] = evaluate_structural_gate(res)
        except Exception as e:
            logging.warning(f&#34;[BPLUS] Stage {stage_id} enrichment skipped: {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Enrich stage_results in-place with BPLUS checks.
Adds: stage_results[stage]["BPLUS"] = {ISCODE, Acceptance, Structural}</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.evaluate_acceptance"><code class="name flex">
<span>def <span class="ident">evaluate_acceptance</span></span>(<span>stage_res: dict, env: dict | None = None) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_acceptance(stage_res: dict, env: dict | None = None) -&gt; dict:
    &#34;&#34;&#34;
    Evaluate acceptance criteria if env/limits are provided.
    If not enough data, marks unavailable.
    &#34;&#34;&#34;
    criteria = _load_acceptance_criteria()
    if not criteria:
        return {
            &#34;available&#34;: False,
            &#34;pass&#34;: False,
            &#34;missing&#34;: &#34;Acceptance_Criteria.json&#34;,
            &#34;criteria&#34;: {},
        }

    env = env or stage_res.get(&#34;env&#34;) or {}

    # helper to read numeric
    def _num(d, k):
        v = d.get(k)
        vv = _as_float(v)
        return float(vv) if vv is not None else None

    checks = {}
    missing = []

    def _add_check(name: str, value: float | None, limit: float | None, op: str):
        if value is None or limit is None:
            missing.append(name)
            return
        if op == &#34;&lt;=&#34;:
            ok = value &lt;= limit
        elif op == &#34;&gt;=&#34;:
            ok = value &gt;= limit
        else:
            ok = False
        checks[name] = {
            &#34;ok&#34;: bool(ok),
            &#34;value&#34;: float(value),
            &#34;limit&#34;: float(limit),
            &#34;op&#34;: op,
        }

    # Common keys
    _add_check(
        &#34;WindMax&#34;, _num(env, &#34;wind_kt&#34;), _as_float(criteria.get(&#34;wind_max_kt&#34;)), &#34;&lt;=&#34;
    )
    _add_check(&#34;HsMax&#34;, _num(env, &#34;hs_m&#34;), _as_float(criteria.get(&#34;hs_max_m&#34;)), &#34;&lt;=&#34;)
    _add_check(
        &#34;CurrentMax&#34;,
        _num(env, &#34;current_kt&#34;),
        _as_float(criteria.get(&#34;current_max_kt&#34;)),
        &#34;&lt;=&#34;,
    )
    _add_check(&#34;UKCMin&#34;, _num(env, &#34;ukc_m&#34;), _as_float(criteria.get(&#34;ukc_min_m&#34;)), &#34;&gt;=&#34;)
    _add_check(
        &#34;RampAngleMax&#34;,
        _num(env, &#34;ramp_angle_deg&#34;),
        _as_float(criteria.get(&#34;ramp_angle_max_deg&#34;)),
        &#34;&lt;=&#34;,
    )

    # Draft limits can use stage results
    _add_check(
        &#34;FwdDraftMax&#34;,
        _as_float(stage_res.get(&#34;Dfwd_m&#34;)),
        _as_float(criteria.get(&#34;fwd_draft_max_m&#34;)),
        &#34;&lt;=&#34;,
    )
    _add_check(
        &#34;AftDraftMax&#34;,
        _as_float(stage_res.get(&#34;Daft_m&#34;)),
        _as_float(criteria.get(&#34;aft_draft_max_m&#34;)),
        &#34;&lt;=&#34;,
    )

    available = len(checks) &gt; 0 and len(missing) == 0
    passed = all(c[&#34;ok&#34;] for c in checks.values()) if checks else False

    return {
        &#34;available&#34;: bool(available),
        &#34;pass&#34;: bool(passed) if available else False,
        &#34;checks&#34;: checks,
        &#34;missing&#34;: &#34;, &#34;.join(missing) if missing else &#34;&#34;,
        &#34;criteria&#34;: criteria,
    }</code></pre>
</details>
<div class="desc"><p>Evaluate acceptance criteria if env/limits are provided.
If not enough data, marks unavailable.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.evaluate_stages"><code class="name flex">
<span>def <span class="ident">evaluate_stages</span></span>(<span>stages: List[Dict[str, Any]],<br>gm_grid: Dict[float, Dict[float, float]],<br>lcf_m: float = 30.91,<br>lbp_m: float = 60.302) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_stages(
    stages: List[StageDict],
    gm_grid: GMGrid,
    lcf_m: float = LCF_M,
    lbp_m: float = LBP_M,
) -&gt; List[StageDict]:
    &#34;&#34;&#34;
    각 Stage에 대해:
      - Dfwd_precise_m / Daft_precise_m (LCF 기반 Draft)
      - GM_calc_m (Δ–Trim 2D 보간)
      - Heel_deg / GM_eff_m / Heel_OK / GM_OK
      - Share_Load_dyn_t / Pin_Stress_dyn_MPa
    필드를 추가해서 반환.
    &#34;&#34;&#34;

    result: List[StageDict] = []

    for stage in stages:
        # ---- 1) LCF 기반 정밀 Draft ----
        tmean_m = float(stage.get(&#34;Tmean_m&#34;, 0.0))
        trim_cm = float(stage.get(&#34;Trim_cm&#34;, 0.0))

        dfwd_m, daft_m = calc_draft_with_lcf(
            tmean_m=tmean_m,
            trim_cm=trim_cm,
            lcf_m=lcf_m,
            lbp_m=lbp_m,
        )
        stage[&#34;Dfwd_precise_m&#34;] = round(dfwd_m, 3)
        stage[&#34;Daft_precise_m&#34;] = round(daft_m, 3)

        # ---- 2) Δ–Trim 2D GM 보간 ----
        disp_t = float(stage.get(&#34;Disp_t&#34;, 0.0))
        trim_m = trim_cm / 100.0

        gm_m = get_gm_bilinear(
            disp_t=disp_t,
            trim_m=trim_m,
            gm_grid=gm_grid,
        )
        stage[&#34;GM_calc_m&#34;] = round(gm_m, 3)

        # ---- 3) Heel + FSE 반영 GM_eff ----
        weight_t = float(stage.get(&#34;W_stage_t&#34;, 0.0))
        y_offset_m = float(stage.get(&#34;Y_offset_m&#34;, 0.0))
        fse_t_m = float(stage.get(&#34;FSE_t_m&#34;, 0.0))

        heel_deg, gm_eff, heel_ok, gm_ok = heel_and_gm_check(
            weight_t=weight_t,
            y_offset_m=y_offset_m,
            disp_t=disp_t,
            gm_m=gm_m,
            fse_t_m=fse_t_m,
            heel_limit_deg=3.0,
            gm_min_m=1.50,
        )
        stage[&#34;Heel_deg&#34;] = round(heel_deg, 3)
        stage[&#34;GM_eff_m&#34;] = round(gm_eff, 3)
        stage[&#34;Heel_OK&#34;] = heel_ok
        stage[&#34;GM_OK&#34;] = gm_ok

        # ---- 4) 동적 / 제동 Load Case ----
        share_static = float(stage.get(&#34;Share_Load_t&#34;, 0.0))
        pin_static = float(stage.get(&#34;Pin_Stress_MPa&#34;, 0.0))

        # LoadCase 문자열 → Enum 매핑
        lc_raw = str(stage.get(&#34;LoadCase&#34;, &#34;A&#34;)).upper()
        if lc_raw in (&#34;A&#34;, &#34;STATIC&#34;):
            lc = LoadCase.STATIC
        elif lc_raw in (&#34;B&#34;, &#34;DYNAMIC&#34;):
            lc = LoadCase.DYNAMIC
        elif lc_raw in (&#34;C&#34;, &#34;BRAKE&#34;, &#34;BRAKING&#34;):
            lc = LoadCase.BRAKING
        else:
            lc = LoadCase.STATIC

        share_dyn, pin_dyn = apply_dynamic_loads(
            share_load_t=share_static,
            pin_stress_mpa=pin_static,
            load_case=lc,
        )
        stage[&#34;Share_Load_dyn_t&#34;] = round(share_dyn, 2)
        stage[&#34;Pin_Stress_dyn_MPa&#34;] = round(pin_dyn, 2)
        stage[&#34;LoadCase_used&#34;] = lc.name  # &#34;STATIC&#34; / &#34;DYNAMIC&#34; / &#34;BRAKING&#34;

        result.append(stage)

    return result</code></pre>
</details>
<div class="desc"><p>각 Stage에 대해:
- Dfwd_precise_m / Daft_precise_m (LCF 기반 Draft)
- GM_calc_m (Δ–Trim 2D 보간)
- Heel_deg / GM_eff_m / Heel_OK / GM_OK
- Share_Load_dyn_t / Pin_Stress_dyn_MPa
필드를 추가해서 반환.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.evaluate_structural_gate"><code class="name flex">
<span>def <span class="ident">evaluate_structural_gate</span></span>(<span>stage_res: dict) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_structural_gate(stage_res: dict) -&gt; dict:
    &#34;&#34;&#34;
    Structural gate evaluation.
    Requires data in stage_res (or external) such as:
      - max_deck_pressure_t_per_m2
      - max_point_load_t
      - ramp_plate_t_per_m2
    Without data → unavailable.
    &#34;&#34;&#34;
    limits = _load_structural_limits()
    if not limits:
        return {
            &#34;available&#34;: False,
            &#34;pass&#34;: False,
            &#34;missing&#34;: &#34;Structural_Limits.json&#34;,
            &#34;limits&#34;: {},
        }

    # read observed values (if present)
    obs = {
        &#34;max_deck_pressure_t_per_m2&#34;: _as_float(
            stage_res.get(&#34;max_deck_pressure_t_per_m2&#34;)
        ),
        &#34;max_point_load_t&#34;: _as_float(stage_res.get(&#34;max_point_load_t&#34;)),
        &#34;ramp_plate_t_per_m2&#34;: _as_float(stage_res.get(&#34;ramp_plate_t_per_m2&#34;)),
    }

    checks = {}
    missing = []

    def _check(name, obs_val, lim_key, op):
        lim = _as_float(limits.get(lim_key))
        if obs_val is None or lim is None:
            missing.append(name)
            return
        if op == &#34;&lt;=&#34;:
            ok = float(obs_val) &lt;= float(lim)
        elif op == &#34;&gt;=&#34;:
            ok = float(obs_val) &gt;= float(lim)
        else:
            ok = False
        checks[name] = {
            &#34;ok&#34;: bool(ok),
            &#34;value&#34;: float(obs_val),
            &#34;limit&#34;: float(lim),
            &#34;op&#34;: op,
        }

    _check(
        &#34;DeckPressure&#34;,
        obs[&#34;max_deck_pressure_t_per_m2&#34;],
        &#34;deck_pressure_max_t_per_m2&#34;,
        &#34;&lt;=&#34;,
    )
    _check(&#34;PointLoad&#34;, obs[&#34;max_point_load_t&#34;], &#34;point_load_max_t&#34;, &#34;&lt;=&#34;)
    _check(&#34;RampPlate&#34;, obs[&#34;ramp_plate_t_per_m2&#34;], &#34;ramp_plate_min_t_per_m2&#34;, &#34;&gt;=&#34;)

    available = len(checks) &gt; 0 and len(missing) == 0
    passed = all(c[&#34;ok&#34;] for c in checks.values()) if checks else False

    return {
        &#34;available&#34;: bool(available),
        &#34;pass&#34;: bool(passed) if available else False,
        &#34;checks&#34;: checks,
        &#34;missing&#34;: &#34;, &#34;.join(missing) if missing else &#34;&#34;,
        &#34;limits&#34;: limits,
    }</code></pre>
</details>
<div class="desc"><p>Structural gate evaluation.
Requires data in stage_res (or external) such as:
- max_deck_pressure_t_per_m2
- max_point_load_t
- ramp_plate_t_per_m2
Without data → unavailable.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.export_roro_delta_lever_report_to_csv"><code class="name flex">
<span>def <span class="ident">export_roro_delta_lever_report_to_csv</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>sheet_name: str = 'RORO_Delta_Lever_Report',<br>csv_path: str = 'RORO_Delta_Lever_Report.csv') ‑> pathlib.Path</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_roro_delta_lever_report_to_csv(
    wb: Workbook,
    sheet_name: str = &#34;RORO_Delta_Lever_Report&#34;,
    csv_path: str = &#34;RORO_Delta_Lever_Report.csv&#34;,
) -&gt; Path:
    &#34;&#34;&#34;
    RORO_Delta_Lever_Report 시트를 CSV로 export.
    - 메일 첨부 / WhatsApp 공유용.
    &#34;&#34;&#34;
    if sheet_name not in wb.sheetnames:
        raise ValueError(f&#34;Sheet &#39;{sheet_name}&#39; not found in workbook.&#34;)

    ws = wb[sheet_name]
    out_path = Path(csv_path)

    with out_path.open(&#34;w&#34;, newline=&#34;&#34;, encoding=&#34;utf-8-sig&#34;) as f:
        writer = csv.writer(f)
        for row in ws.iter_rows(values_only=True):
            writer.writerow(list(row))

    print(f&#34;[OK] RORO_Delta_Lever_Report exported to {out_path}&#34;)
    return out_path</code></pre>
</details>
<div class="desc"><p>RORO_Delta_Lever_Report 시트를 CSV로 export.
- 메일 첨부 / WhatsApp 공유용.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.export_stages_to_csv"><code class="name flex">
<span>def <span class="ident">export_stages_to_csv</span></span>(<span>output_path: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_stages_to_csv(output_path: str = None):
    &#34;&#34;&#34;
    Stage별 계산 결과를 CSV로 Export.

    Python → CSV → 엑셀에서 자동 가져오기 플로우:
    1. Python이 JSON 3개를 읽는다 (Frame_x_from_mid_m.json, hydro_table.json, LCT_BUSHRA_GM_2D_Grid.json)
    2. find_preballast_opt()가 Stage 5_Pre / Stage 6A에 대해 최소 Pre-ballast를 찾는다
    3. 찾은 Pre-ballast를 고정시켜서 Stage 1~7에 대해 solve_stage()로 계산
    4. 결과를 stage_results.csv로 저장
    → 엑셀 RORO_Stage_Scenarios 시트에서 B열/W, D열/x, Trim, Dfwd, GM 등을 이 CSV를 VLOOKUP/INDEX로 끌어다 쓴다

    Args:
        output_path: 출력 CSV 파일 경로 (None이면 기본값: stage_results.csv)
    &#34;&#34;&#34;
    if output_path is None:
        output_path = os.path.join(SCRIPT_DIR, &#34;stage_results.csv&#34;)

    # Hydro table 로드
    hydro_table_data = _load_hydro_table()
    if not hydro_table_data:
        print(&#34;[WARNING] hydro_table.json not found. Using empty table.&#34;)
        hydro_table_data = []

    # -------------------------------
    # CONFIG (가정 값 – 필요 시 조정)
    # -------------------------------
    # ⚠ 일부 Stage별 위치/중량은 지금 파일에 명시가 없어서 가정 값으로 묶어두고,
    #    맨 위 CONFIG에서 네가 직접 튜닝할 수 있게 했다.
    cfg = {
        # TR+SPMT 등가 중량 (t)
        &#34;W_TR&#34;: 271.20,  # 가정: PL 기준; 필요 시 수정
        # TR1 위치 (Frame) - ✅ stage_results.csv 기준 (2024-12-23 패치)
        &#34;FR_TR1_RAMP_START&#34;: 26.15,  # Stage 2: x=+4.0m → Fr=30.151-4.0≈26.15
        &#34;FR_TR1_RAMP_MID&#34;: 26.15,  # Stage 3: x=+4.0m (동일)
        &#34;FR_TR1_STOW&#34;: 25.65,  # Stage 4/5: x=+4.5m → Fr=30.151-4.5≈25.65
        # TR2 위치 (Frame) - ✅ stage_results.csv 기준
        &#34;FR_TR2_RAMP&#34;: 25.04,  # Stage 6A: x=+5.11m → Fr=30.151-5.11≈25.04
        &#34;FR_TR2_STOW&#34;: 29.39,  # Stage 6C: x=+0.76m (LCF, even keel) → Fr=30.151-0.76≈29.39
        # Pre-ballast 중심 (FW2, AFT 쪽) - ✅ stage_results.csv 기준
        &#34;FR_PREBALLAST&#34;: 25.58,  # Stage 5_PreBallast: x=+4.57m → Fr=30.151-4.57≈25.58
    }

    # 선박 고정 파라미터 (Aries/NAPA 값 기준 – 필요 시 수정)
    MTC = 34.00  # t·m/cm
    LCF = 0.76  # m (midship 기준 x)
    LBP = 60.302  # m
    D_vessel = 3.65  # m (Vessel depth)

    # Stage 1 기준 Δ, Tmean (hydro_table.json에서 선택)
    # 가정: Disp 2800t 근처 값 사용
    base_disp_t = 2800.00
    # PATCH B1-Enhanced: remove fixed base_tmean_m=2.00; derive from hydro table (SSOT enforcement)
    hydro_table_data = _load_hydro_table()
    if hydro_table_data:
        base_tmean_m = interpolate_tmean_from_disp(base_disp_t, hydro_table_data)
        print(
            f&#34;[PATCH B1] base_tmean_m from hydro: {base_tmean_m:.3f} m (base_disp_t={base_disp_t:.2f} t)&#34;
        )
    else:
        raise RuntimeError(
            &#34;[PATCH B1-Enhanced] hydro_table_data missing in Export path; cannot compute base_tmean_m. &#34;
            &#34;Provide Hydro_Table_Engineering.json (SSOT). &#34;
            &#34;Location: bplus_inputs/Hydro_Table_Engineering.json&#34;
        )

    # solve_stage에 필요한 params
    params = {
        &#34;MTC&#34;: MTC,
        &#34;LCF&#34;: LCF,
        &#34;LBP&#34;: LBP,
        &#34;D_vessel&#34;: D_vessel,
        &#34;hydro_table&#34;: hydro_table_data,
        &#34;FWD_DRAFT_LIMIT&#34;: 2.70,
        &#34;GM_MIN&#34;: 1.50,
        # Patch Option B: FSM from CONST_TANKS (Fuel + FreshWater)
        &#34;Const_FSM_t_m&#34;: 887.0,  # CONST_TANKS!E5 합계값 (DO.P/S + LRFO.P/S + FW1.P/S + FW2.P/S)
    }
    # build_stage_loads에 필요한 파라미터도 추가
    params.update(cfg)

    # 1) Pre-ballast 탐색
    w_tr = cfg[&#34;W_TR&#34;]

    preballast_result = find_preballast_opt(
        w_tr_unit_t=w_tr,
        base_disp_t=base_disp_t,
        fr_tr1_stow=cfg.get(&#34;FR_TR1_STOW&#34;, FR_TR1_STOW),
        fr_tr2_ramp=cfg.get(&#34;FR_TR2_RAMP&#34;, FR_TR2_RAMP),
        fr_preballast=cfg.get(&#34;FR_PREBALLAST&#34;, FR_PREBALLAST),
        params=params,
        search_min_t=params.get(&#34;PREBALLAST_MIN_T&#34;, 20.0),  # FIX: enforce 20t minimum
        search_max_t=params.get(&#34;PREBALLAST_MAX_T&#34;, 400.0),
        search_step_t=params.get(&#34;PREBALLAST_STEP_T&#34;, 1.0),
    )

    if not preballast_result[&#34;ok&#34;]:
        preballast_opt = params.get(&#34;PREBALLAST_T_TARGET&#34;, 250.0)
        print(
            f&#34;[WARNING] Pre-ballast optimization failed: {preballast_result[&#39;reason&#39;]}&#34;
        )
        print(f&#34;[WARNING] Using fallback pre-ballast value: {preballast_opt:.2f} t&#34;)
        stage5_pb = None
        stage6A_pb = None
    else:
        preballast_opt = preballast_result[&#34;w_preballast_t&#34;]
        print(
            f&#34;[INFO] Optimal Pre-ballast: {preballast_opt:.2f} t (used for all stages)&#34;
        )
        # Pre-ballast 결과에서 Stage 5 / Stage 6A 데이터 추출
        stage5_pb = preballast_result.get(&#34;stage5&#34;)
        stage6A_pb = preballast_result.get(&#34;stage6A&#34;)

    # 2) Stage 리스트
    stages_order = [
        &#34;Stage 1&#34;,
        &#34;Stage 2&#34;,
        &#34;Stage 3&#34;,
        &#34;Stage 4&#34;,
        &#34;Stage 5&#34;,
        &#34;Stage 5_PreBallast&#34;,
        &#34;Stage 6A_Critical (Opt C)&#34;,
        &#34;Stage 6B Tide Window&#34;,
        &#34;Stage 6C&#34;,
        &#34;Stage 7&#34;,
    ]

    # 3) Stage별 계산
    rows = []
    for st in stages_order:
        loads = build_stage_loads(st, preballast_opt, params)
        res = solve_stage(base_disp_t, base_tmean_m, loads, **params)

        # ⭐ Pre-ballast 결과로 Stage 5_PreBallast / Stage 6A 값 override
        if st == &#34;Stage 5_PreBallast&#34; and stage5_pb is not None:
            # Pre-ballast 계산 결과의 FWD/AFT/Trim/TM 값으로 교체
            res[&#34;W_stage_t&#34;] = float(stage5_pb.get(&#34;W_stage_t&#34;, res[&#34;W_stage_t&#34;]))
            res[&#34;x_stage_m&#34;] = float(stage5_pb.get(&#34;x_stage_m&#34;, res[&#34;x_stage_m&#34;]))
            res[&#34;TM_LCF_tm&#34;] = float(stage5_pb.get(&#34;TM_tm&#34;, res[&#34;TM_LCF_tm&#34;]))
            res[&#34;Trim_cm&#34;] = float(stage5_pb.get(&#34;Trim_cm&#34;, res[&#34;Trim_cm&#34;]))
            res[&#34;Dfwd_m&#34;] = float(stage5_pb.get(&#34;FWD_m&#34;, res[&#34;Dfwd_m&#34;]))
            res[&#34;Daft_m&#34;] = float(stage5_pb.get(&#34;AFT_m&#34;, res[&#34;Daft_m&#34;]))
            # FWD_Height_m, AFT_Height_m 재계산
            res[&#34;FWD_Height_m&#34;] = D_vessel - res[&#34;Dfwd_m&#34;]
            res[&#34;AFT_Height_m&#34;] = D_vessel - res[&#34;Daft_m&#34;]
            print(
                f&#34;[INFO] Stage 5_PreBallast: Applied pre-ballast FWD={res[&#39;Dfwd_m&#39;]:.2f}m, AFT={res[&#39;Daft_m&#39;]:.2f}m&#34;
            )

        if st == &#34;Stage 6A_Critical (Opt C)&#34; and stage6A_pb is not None:
            # Pre-ballast 계산 결과의 FWD/AFT/Trim/TM 값으로 교체
            res[&#34;W_stage_t&#34;] = float(stage6A_pb.get(&#34;W_stage_t&#34;, res[&#34;W_stage_t&#34;]))
            res[&#34;x_stage_m&#34;] = float(stage6A_pb.get(&#34;x_stage_m&#34;, res[&#34;x_stage_m&#34;]))
            res[&#34;TM_LCF_tm&#34;] = float(stage6A_pb.get(&#34;TM_tm&#34;, res[&#34;TM_LCF_tm&#34;]))
            res[&#34;Trim_cm&#34;] = float(stage6A_pb.get(&#34;Trim_cm&#34;, res[&#34;Trim_cm&#34;]))
            res[&#34;Dfwd_m&#34;] = float(stage6A_pb.get(&#34;FWD_m&#34;, res[&#34;Dfwd_m&#34;]))
            res[&#34;Daft_m&#34;] = float(stage6A_pb.get(&#34;AFT_m&#34;, res[&#34;Daft_m&#34;]))
            # FWD_Height_m, AFT_Height_m 재계산
            res[&#34;FWD_Height_m&#34;] = D_vessel - res[&#34;Dfwd_m&#34;]
            res[&#34;AFT_Height_m&#34;] = D_vessel - res[&#34;Daft_m&#34;]
            print(
                f&#34;[INFO] Stage 6A_Critical: Applied pre-ballast FWD={res[&#39;Dfwd_m&#39;]:.2f}m, AFT={res[&#39;Daft_m&#39;]:.2f}m&#34;
            )

        # Stage 6B Tide Window: Stage 6A_Critical과 동일한 Draft 값 (Forecast Tide +0.30m는 UKC 계산에만 영향)
        if st == &#34;Stage 6B Tide Window&#34;:
            # Stage 6A_Critical과 동일한 계산값 사용 (Draft는 동일, Tide는 UKC 계산에만 영향)
            stage6a_res = None
            for prev_row in rows:
                if prev_row[&#34;Stage&#34;] == &#34;Stage 6A_Critical (Opt C)&#34;:
                    stage6a_res = prev_row
                    break
            if stage6a_res:
                res[&#34;W_stage_t&#34;] = stage6a_res[&#34;W_stage_t&#34;]
                res[&#34;x_stage_m&#34;] = stage6a_res[&#34;x_stage_m&#34;]
                res[&#34;TM_LCF_tm&#34;] = stage6a_res[&#34;TM_LCF_tm&#34;]
                res[&#34;Trim_cm&#34;] = stage6a_res[&#34;Trim_cm&#34;]
                res[&#34;Dfwd_m&#34;] = stage6a_res[&#34;Dfwd_m&#34;]
                res[&#34;Daft_m&#34;] = stage6a_res[&#34;Daft_m&#34;]
                res[&#34;FWD_Height_m&#34;] = stage6a_res[&#34;FWD_Height_m&#34;]
                res[&#34;AFT_Height_m&#34;] = stage6a_res[&#34;AFT_Height_m&#34;]
                res[&#34;GM_m&#34;] = stage6a_res[&#34;GM(m)&#34;]
                res[&#34;Trim_Check&#34;] = stage6a_res[&#34;Trim_Check&#34;]
                res[&#34;vs_2.70m&#34;] = stage6a_res[&#34;vs_2.70m&#34;]
                res[&#34;GM_Check&#34;] = stage6a_res[&#34;GM_Check&#34;]
                res[&#34;Disp_t&#34;] = stage6a_res[&#34;Disp_t&#34;]
                res[&#34;Tmean_m&#34;] = stage6a_res[&#34;Tmean_m&#34;]
                print(
                    f&#34;[INFO] Stage 6B Tide Window: Using Stage 6A_Critical values (Draft unchanged, Tide affects UKC only)&#34;
                )

        # solve_stage()에서 이미 Trim_Check, vs_2.70m, GM_Check 계산됨
        rows.append(
            {
                &#34;Stage&#34;: st,
                &#34;W_stage_t&#34;: round(res[&#34;W_stage_t&#34;], 2),
                &#34;x_stage_m&#34;: round(res[&#34;x_stage_m&#34;], 2),
                &#34;TM_LCF_tm&#34;: round(res[&#34;TM_LCF_tm&#34;], 2),
                &#34;Trim_cm&#34;: round(res[&#34;Trim_cm&#34;], 2),
                &#34;Dfwd_m&#34;: round(res[&#34;Dfwd_m&#34;], 2),
                &#34;Daft_m&#34;: round(res[&#34;Daft_m&#34;], 2),
                &#34;GM(m)&#34;: round(res[&#34;GM_m&#34;], 2),
                &#34;Fwd Draft(m)&#34;: round(res[&#34;Dfwd_m&#34;], 2),
                &#34;FWD_Height_m&#34;: round(res[&#34;FWD_Height_m&#34;], 2),
                &#34;AFT_Height_m&#34;: round(res[&#34;AFT_Height_m&#34;], 2),
                &#34;Trim_Check&#34;: res[&#34;Trim_Check&#34;],
                &#34;vs_2.70m&#34;: res[&#34;vs_2.70m&#34;],
                &#34;GM_Check&#34;: res[&#34;GM_Check&#34;],
                &#34;Disp_t&#34;: round(res[&#34;Disp_t&#34;], 2),
                &#34;Tmean_m&#34;: round(res[&#34;Tmean_m&#34;], 2),
                &#34;PreBallast_t&#34;: round(preballast_opt, 2),
            }
        )

    # 4) CSV 저장
    fieldnames = [
        &#34;Stage&#34;,
        &#34;W_stage_t&#34;,
        &#34;x_stage_m&#34;,
        &#34;TM_LCF_tm&#34;,
        &#34;Trim_cm&#34;,
        &#34;Dfwd_m&#34;,
        &#34;Daft_m&#34;,
        &#34;GM(m)&#34;,
        &#34;Fwd Draft(m)&#34;,
        &#34;FWD_Height_m&#34;,
        &#34;AFT_Height_m&#34;,
        &#34;Trim_Check&#34;,
        &#34;vs_2.70m&#34;,
        &#34;GM_Check&#34;,
        &#34;Disp_t&#34;,
        &#34;Tmean_m&#34;,
        &#34;PreBallast_t&#34;,
    ]

    try:
        with open(output_path, &#34;w&#34;, newline=&#34;&#34;, encoding=&#34;utf-8&#34;) as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            for r in rows:
                writer.writerow(r)

        print(f&#34;[INFO] Stage results exported to {output_path}&#34;)
        print(f&#34;[INFO] Total stages: {len(rows)}&#34;)
        print(
            f&#34;[INFO] 엑셀에서 이 CSV를 가져와서 RORO_Stage_Scenarios 시트의 B열/W, D열/x, Trim, Dfwd, GM 등을 VLOOKUP/INDEX로 연결하세요.&#34;
        )
    except Exception as e:
        print(f&#34;[ERROR] Failed to export CSV: {e}&#34;)
        raise</code></pre>
</details>
<div class="desc"><p>Stage별 계산 결과를 CSV로 Export.</p>
<p>Python → CSV → 엑셀에서 자동 가져오기 플로우:
1. Python이 JSON 3개를 읽는다 (Frame_x_from_mid_m.json, hydro_table.json, LCT_BUSHRA_GM_2D_Grid.json)
2. find_preballast_opt()가 Stage 5_Pre / Stage 6A에 대해 최소 Pre-ballast를 찾는다
3. 찾은 Pre-ballast를 고정시켜서 Stage 1~7에 대해 solve_stage()로 계산
4. 결과를 stage_results.csv로 저장
→ 엑셀 RORO_Stage_Scenarios 시트에서 B열/W, D열/x, Trim, Dfwd, GM 등을 이 CSV를 VLOOKUP/INDEX로 끌어다 쓴다</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>output_path</code></strong></dt>
<dd>출력 CSV 파일 경로 (None이면 기본값: stage_results.csv)</dd>
</dl></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.export_whatsapp_summary_png"><code class="name flex">
<span>def <span class="ident">export_whatsapp_summary_png</span></span>(<span>wb: openpyxl.workbook.workbook.Workbook,<br>png_path: str = 'RORO_Summary.png',<br>max_stage_lines: int = 6) ‑> pathlib.Path | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_whatsapp_summary_png(
    wb: Workbook,
    png_path: str = &#34;RORO_Summary.png&#34;,
    max_stage_lines: int = 6,
) -&gt; Optional[Path]:
    &#34;&#34;&#34;
    RORO_Delta_Lever_Report + Ballast_Scenario_Comparison 요약을
    텍스트 기반 PNG로 내보내 WhatsApp 공유용으로 사용.
    &#34;&#34;&#34;
    if not MATPLOTLIB_AVAILABLE:
        print(&#34;[WARN] matplotlib not available. PNG export skipped.&#34;)
        return None

    lines: list[str] = []
    # 1) ΔTM Flag 요약
    if &#34;RORO_Delta_Lever_Report&#34; in wb.sheetnames:
        ws = wb[&#34;RORO_Delta_Lever_Report&#34;]
        flag_counts = {&#34;OK&#34;: 0, &#34;CHECK&#34;: 0, &#34;NO_DATA&#34;: 0}
        check_stages: list[str] = []

        for row in range(6, ws.max_row + 1):
            stage = ws[f&#34;A{row}&#34;].value
            flag = ws[f&#34;J{row}&#34;].value  # Flag 컬럼
            if stage is None or flag is None:
                continue
            flag = str(flag).strip()
            flag_counts[flag] = flag_counts.get(flag, 0) + 1
            if flag == &#34;CHECK&#34;:
                check_stages.append(str(stage))

        lines.append(&#34;[ΔTM/Lever Check]&#34;)
        lines.append(
            f&#34;OK: {flag_counts.get(&#39;OK&#39;,0)}, CHECK: {flag_counts.get(&#39;CHECK&#39;,0)}, NO_DATA: {flag_counts.get(&#39;NO_DATA&#39;,0)}&#34;
        )
        if check_stages:
            lines.append(&#34;CHECK stages: &#34; + &#34;, &#34;.join(check_stages[:max_stage_lines]))
        lines.append(&#34;&#34;)

    # 2) Ballast 시나리오 요약
    if &#34;Ballast_Scenario_Comparison&#34; in wb.sheetnames:
        ws2 = wb[&#34;Ballast_Scenario_Comparison&#34;]
        lines.append(&#34;[Ballast Scenarios]&#34;)
        for row in range(6, ws2.max_row + 1):
            name = ws2[f&#34;A{row}&#34;].value
            if not name:
                continue
            try:
                total_ballast = float(ws2[f&#34;B{row}&#34;].value or 0.0)
                time_h = float(ws2[f&#34;C{row}&#34;].value or 0.0)
                fwd_margin = float(ws2[f&#34;D{row}&#34;].value or 0.0)
                link_margin = float(ws2[f&#34;E{row}&#34;].value or 0.0)
                lines.append(
                    f&#34;{name}: Ballast={total_ballast:.1f}t, Time={time_h:.2f}h, &#34;
                    f&#34;FWD_margin={fwd_margin:.2f}m, Linkspan_margin={link_margin:.2f}m&#34;
                )
            except (TypeError, ValueError):
                continue

    if not lines:
        lines = [&#34;No summary data available.&#34;]

    try:
        fig, ax = plt.subplots(figsize=(6, 4))
        ax.axis(&#34;off&#34;)

        y = 0.95
        for line in lines:
            ax.text(0.02, y, line, fontsize=9, transform=ax.transAxes, va=&#34;top&#34;)
            y -= 0.06

        fig.tight_layout()
        out_path = Path(png_path)
        fig.savefig(out_path, dpi=200)
        plt.close(fig)
        print(f&#34;[OK] WhatsApp summary PNG exported: {out_path}&#34;)
        return out_path
    except Exception as e:
        print(f&#34;[WARN] PNG export failed: {e}&#34;)
        return None</code></pre>
</details>
<div class="desc"><p>RORO_Delta_Lever_Report + Ballast_Scenario_Comparison 요약을
텍스트 기반 PNG로 내보내 WhatsApp 공유용으로 사용.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_precision_columns"><code class="name flex">
<span>def <span class="ident">extend_precision_columns</span></span>(<span>ws, first_data_row, num_stages)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_precision_columns(ws, first_data_row, num_stages):
    &#34;&#34;&#34;
    RORO 시트에 정밀 계산 적용 (v4.0)
    - G, H 컬럼을 직접 수정: FWD_precise, AFT_precise (Fr_stage 추가로 컬럼 인덱스 변경)
    - Fr_stage 컬럼 추가로 인한 컬럼 구조:
      - Column 6: Trim_cm (F)
      - Column 7: FWD_precise_m (G)
      - Column 8: AFT_precise_m (H)
    - 순환 참조 방지: Tmean을 Baseline draft ($B$6) 기반으로 계산
    - Pre-ballast Stage는 Python 값이 이미 쓰여있으므로 건너뜀
    &#34;&#34;&#34;
    styles = get_styles()
    # 숫자 포맷 통일: 천단위 구분, 소수점 2자리
    number_format = &#34;#,##0.00&#34;

    # Pre-ballast Stage 목록
    # REMOVED: Old logic that overwrites Python values with Excel formulas
    # All stages now use Python-calculated draft values (LCF-aware)
    # G, H columns are populated in the stage loop above (lines 4639-4700)
    print(&#34;  [OK] G, H columns use Python-calculated draft values (LCF-aware, v4.0)&#34;)</code></pre>
</details>
<div class="desc"><p>RORO 시트에 정밀 계산 적용 (v4.0)
- G, H 컬럼을 직접 수정: FWD_precise, AFT_precise (Fr_stage 추가로 컬럼 인덱스 변경)
- Fr_stage 컬럼 추가로 인한 컬럼 구조:
- Column 6: Trim_cm (F)
- Column 7: FWD_precise_m (G)
- Column 8: AFT_precise_m (H)
- 순환 참조 방지: Tmean을 Baseline draft ($B$6) 기반으로 계산
- Pre-ballast Stage는 Python 값이 이미 쓰여있으므로 건너뜀</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_roro_bc_br_range"><code class="name flex">
<span>def <span class="ident">extend_roro_bc_br_range</span></span>(<span>ws, first_data_row, num_stages, stage_qa_path=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_roro_bc_br_range(ws, first_data_row, num_stages, stage_qa_path=None):
    &#34;&#34;&#34;
    RORO_Stage_Scenarios 시트에 BC-BR 컬럼 추가 (Post-Solver Results &amp; Gate Verification)

    BC-BR 컬럼 (55-70):
    - BC: Draft_FWD_m_solver
    - BD: Draft_AFT_m_solver
    - BE: Draft_Source
    - BF: Gate_AFT_MIN_2p70_PASS
    - BG: AFT_Margin_2p70_m
    - BH: Gate_B_Applies
    - BI: Gate_FWD_MAX_2p70_critical_only
    - BJ: FWD_Margin_2p70_m
    - BK: Gate_Freeboard_ND
    - BL: Freeboard_Req_ND_m
    - BM: Freeboard_ND_Margin_m
    - BN: D_vessel_m
    - BO: Draft_Max_raw_m
    - BP: Draft_Max_solver_m
    - BQ: Draft_Clipped_raw
    - BR: Draft_Clipped_solver

    데이터 소스: pipeline_stage_QA.csv (solver 결과 반영)
    &#34;&#34;&#34;
    from pathlib import Path
    import csv

    styles = get_styles()
    number_format = &#34;#,##0.00&#34;

    # BC-BR 컬럼 헤더 정의
    bc_br_cols = [
        (&#34;BC&#34;, 55, &#34;Draft_FWD_m_solver&#34;),
        (&#34;BD&#34;, 56, &#34;Draft_AFT_m_solver&#34;),
        (&#34;BE&#34;, 57, &#34;Draft_Source&#34;),
        (&#34;BF&#34;, 58, &#34;Gate_AFT_MIN_2p70_PASS&#34;),
        (&#34;BG&#34;, 59, &#34;AFT_Margin_2p70_m&#34;),
        (&#34;BH&#34;, 60, &#34;Gate_B_Applies&#34;),
        (&#34;BI&#34;, 61, &#34;Gate_FWD_MAX_2p70_critical_only&#34;),
        (&#34;BJ&#34;, 62, &#34;FWD_Margin_2p70_m&#34;),
        (&#34;BK&#34;, 63, &#34;Gate_Freeboard_ND&#34;),
        (&#34;BL&#34;, 64, &#34;Freeboard_Req_ND_m&#34;),
        (&#34;BM&#34;, 65, &#34;Freeboard_ND_Margin_m&#34;),
        (&#34;BN&#34;, 66, &#34;D_vessel_m&#34;),
        (&#34;BO&#34;, 67, &#34;Draft_Max_raw_m&#34;),
        (&#34;BP&#34;, 68, &#34;Draft_Max_solver_m&#34;),
        (&#34;BQ&#34;, 69, &#34;Draft_Clipped_raw&#34;),
        (&#34;BR&#34;, 70, &#34;Draft_Clipped_solver&#34;),
    ]

    header_row = first_data_row - 1

    # 헤더 생성
    for letter, col, header in bc_br_cols:
        cell = ws.cell(row=header_row, column=col)
        cell.value = header
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]
        ws.column_dimensions[letter].width = 14

    # pipeline_stage_QA.csv에서 데이터 로드
    stage_qa_data = {}
    if stage_qa_path is None:
        # 기본 경로 탐색
        for p in [
            Path(&#34;pipeline_stage_QA.csv&#34;),
            Path(&#34;ssot/pipeline_stage_QA.csv&#34;),
            Path(&#34;pipeline_out_*/ssot/pipeline_stage_QA.csv&#34;),
        ]:
            matches = list(Path(&#34;.&#34;).glob(str(p)))
            if matches:
                stage_qa_path = matches[-1]  # 최신 파일 사용
                break

    if stage_qa_path and Path(stage_qa_path).exists():
        print(f&#34;  [INFO] Loading QA data from: {stage_qa_path}&#34;)
        with open(stage_qa_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            reader = csv.DictReader(f)
            for row in reader:
                stage_name = row.get(&#39;Stage&#39;, &#39;&#39;)
                if stage_name:
                    stage_qa_data[stage_name] = row
    else:
        print(f&#34;  [WARN] pipeline_stage_QA.csv not found, using placeholder values&#34;)

    # Stage 행 찾기
    stage_rows = []
    max_row = ws.max_row
    for row in range(first_data_row, max_row + 1):
        cell_value = ws.cell(row=row, column=1).value
        if cell_value and &#34;stage&#34; in str(cell_value).strip().lower():
            stage_rows.append((row, str(cell_value).strip()))

    # 각 Stage 행에 데이터 채우기
    for row, stage_name in stage_rows:
        qa_row = stage_qa_data.get(stage_name, {})

        # BC (55): Draft_FWD_m_solver
        val = qa_row.get(&#39;Draft_FWD_m&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=55).value = float(val)
            ws.cell(row=row, column=55).number_format = number_format

        # BD (56): Draft_AFT_m_solver
        val = qa_row.get(&#39;Draft_AFT_m&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=56).value = float(val)
            ws.cell(row=row, column=56).number_format = number_format

        # BE (57): Draft_Source
        val = qa_row.get(&#39;Draft_Source&#39;, &#39;solver&#39;)
        ws.cell(row=row, column=57).value = val

        # BF (58): Gate_AFT_MIN_2p70_PASS
        val = qa_row.get(&#39;GateA_AFT_MIN_2p70_PASS&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=58).value = 1 if val.lower() in [&#39;true&#39;, &#39;1&#39;, &#39;pass&#39;] else 0

        # BG (59): AFT_Margin_2p70_m
        val = qa_row.get(&#39;GateA_AFT_MIN_2p70_Margin_m&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=59).value = float(val)
            ws.cell(row=row, column=59).number_format = number_format

        # BH (60): Gate_B_Applies
        val = qa_row.get(&#39;GateB_FWD_MAX_2p70_CD_applicable&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=60).value = 1 if val.lower() in [&#39;true&#39;, &#39;1&#39;] else 0

        # BI (61): Gate_FWD_MAX_2p70_critical_only
        val = qa_row.get(&#39;GateB_FWD_MAX_2p70_CD_PASS&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=61).value = val if val != &#39;&#39; else &#39;N/A&#39;

        # BJ (62): FWD_Margin_2p70_m
        val = qa_row.get(&#39;GateB_FWD_MAX_2p70_CD_Margin_m&#39;, &#39;&#39;)
        if val:
            try:
                ws.cell(row=row, column=62).value = float(val)
                ws.cell(row=row, column=62).number_format = number_format
            except:
                ws.cell(row=row, column=62).value = val

        # BK (63): Gate_Freeboard_ND
        val = qa_row.get(&#39;Gate_Freeboard_ND&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=63).value = val

        # BL (64): Freeboard_Req_ND_m
        val = qa_row.get(&#39;Freeboard_Req_ND_m&#39;, &#39;&#39;)
        if val:
            try:
                ws.cell(row=row, column=64).value = float(val)
                ws.cell(row=row, column=64).number_format = number_format
            except:
                pass

        # BM (65): Freeboard_ND_Margin_m
        val = qa_row.get(&#39;Freeboard_ND_Margin_m&#39;, &#39;&#39;)
        if val:
            try:
                ws.cell(row=row, column=65).value = float(val)
                ws.cell(row=row, column=65).number_format = number_format
            except:
                pass

        # BN (66): D_vessel_m
        val = qa_row.get(&#39;D_vessel_m&#39;, &#39;3.65&#39;)
        ws.cell(row=row, column=66).value = float(val)
        ws.cell(row=row, column=66).number_format = number_format

        # BO (67): Draft_Max_raw_m
        val = qa_row.get(&#39;Draft_Max_raw_m&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=67).value = float(val)
            ws.cell(row=row, column=67).number_format = number_format

        # BP (68): Draft_Max_solver_m
        val = qa_row.get(&#39;Draft_Max_solver_m&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=68).value = float(val)
            ws.cell(row=row, column=68).number_format = number_format

        # BQ (69): Draft_Clipped_raw
        val = qa_row.get(&#39;Draft_Clipped_raw&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=69).value = 1 if val.lower() in [&#39;true&#39;, &#39;1&#39;] else 0

        # BR (70): Draft_Clipped_solver
        val = qa_row.get(&#39;Draft_Clipped_solver&#39;, &#39;&#39;)
        if val:
            ws.cell(row=row, column=70).value = 1 if val.lower() in [&#39;true&#39;, &#39;1&#39;] else 0

    print(f&#34;  [OK] BC-BR columns (Post-Solver Results &amp; Gates) added to RORO_Stage_Scenarios sheet ({len(stage_rows)} stages)&#34;)</code></pre>
</details>
<div class="desc"><p>RORO_Stage_Scenarios 시트에 BC-BR 컬럼 추가 (Post-Solver Results &amp; Gate Verification)</p>
<p>BC-BR 컬럼 (55-70):
- BC: Draft_FWD_m_solver
- BD: Draft_AFT_m_solver
- BE: Draft_Source
- BF: Gate_AFT_MIN_2p70_PASS
- BG: AFT_Margin_2p70_m
- BH: Gate_B_Applies
- BI: Gate_FWD_MAX_2p70_critical_only
- BJ: FWD_Margin_2p70_m
- BK: Gate_Freeboard_ND
- BL: Freeboard_Req_ND_m
- BM: Freeboard_ND_Margin_m
- BN: D_vessel_m
- BO: Draft_Max_raw_m
- BP: Draft_Max_solver_m
- BQ: Draft_Clipped_raw
- BR: Draft_Clipped_solver</p>
<p>데이터 소스: pipeline_stage_QA.csv (solver 결과 반영)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_roro_captain_req"><code class="name flex">
<span>def <span class="ident">extend_roro_captain_req</span></span>(<span>ws, first_data_row, num_stages)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_roro_captain_req(ws, first_data_row, num_stages):
    &#34;&#34;&#34;
    RORO_Stage_Scenarios 시트 Captain Requirement 확장 컬럼(U~AE, AR~AT) 생성.

    - U  : GM(m)           (Hydro_Table!B:D 기반 VLOOKUP)
    - V  : Fwd Draft(m)    (Dfwd_m 복사)
    - W  : vs 2.70m        (Fwd ≤ 2.70m 체크)
    - X  : De-ballast Qty  (Ballast_t)
    - Y  : Timing          (수기 입력용)
    - Z  : Phys_Freeboard  (Calc!E19 - Dfwd)
    - AB : GM copy         (=U)
    - AC : GM Check        (GM ≥ GM_target=Calc!E21)
    - AD : Disp_total_t    (950 + Ballast + Cargo)
    - AE : Vent_Time_h     (De-ballast Qty / $B$13 t/h)
    - AR : Heel_deg        (B / (Δ * GM) 기반 근사)
    - AS : GM_eff          (GM * cos(Heel))
    - AT : Ramp_Angle_deg  (Freeboard 기반 ramp 각도)

    ✅ 이 함수가 모든 Stage 행에 수식을 써주므로
       U25 / AB25 / AC25 / AR25 / AS25 수식 에러가 사라집니다.
    &#34;&#34;&#34;
    styles = get_styles()

    # ------------------------------------------------------------------
    # 1) 헤더 생성 (U~AE)
    # ------------------------------------------------------------------
    captain_cols = [
        &#34;GM(m)&#34;,  # U(21)
        &#34;Fwd Draft(m)&#34;,  # V(22)
        &#34;vs 2.70m&#34;,  # W(23)
        &#34;De-ballast Qty(t)&#34;,  # X(24)
        &#34;Timing&#34;,  # Y(25)
        &#34;Phys_Freeboard_m&#34;,  # Z(26)
        &#34;Clearance_Check&#34;,  # AA(27) – 필요시 확장
        &#34;GM_calc&#34;,  # AB(28)
        &#34;GM_Check&#34;,  # AC(29)
        &#34;Disp_total_t&#34;,  # AD(30)
        &#34;Vent_Time_h&#34;,  # AE(31)
    ]

    start_col = 21  # U 열
    header_row = first_data_row - 1

    for i, name in enumerate(captain_cols):
        col = start_col + i
        cell = ws.cell(row=header_row, column=col)
        cell.value = name
        cell.font = styles[&#34;header_font&#34;]
        cell.fill = styles[&#34;header_fill&#34;]
        cell.alignment = styles[&#34;center_align&#34;]
        cell.border = Border(
            left=styles[&#34;thin_border&#34;],
            right=styles[&#34;thin_border&#34;],
            top=styles[&#34;thin_border&#34;],
            bottom=styles[&#34;thin_border&#34;],
        )

    # 기본 컬럼 폭 (필요시 조정)
    ws.column_dimensions[&#34;U&#34;].width = 10
    ws.column_dimensions[&#34;V&#34;].width = 10
    ws.column_dimensions[&#34;W&#34;].width = 10
    ws.column_dimensions[&#34;X&#34;].width = 12
    ws.column_dimensions[&#34;Y&#34;].width = 12
    ws.column_dimensions[&#34;Z&#34;].width = 14
    ws.column_dimensions[&#34;AA&#34;].width = 12
    ws.column_dimensions[&#34;AB&#34;].width = 10
    ws.column_dimensions[&#34;AC&#34;].width = 10
    ws.column_dimensions[&#34;AD&#34;].width = 12
    ws.column_dimensions[&#34;AE&#34;].width = 12

    number_format = &#34;#,##0.00&#34;

    # ------------------------------------------------------------------
    # 2) 각 Stage 행별 수식 삽입
    #    → 특히 row=25(Stage 6A_Critical)에 U/AB/AC/AR/AS가 자동 기입됨
    #    PATCH: num_stages 대신 A열 스캔으로 모든 Stage 행 찾기
    # ------------------------------------------------------------------
    # A열(column=1)을 스캔하여 &#34;Stage&#34;로 시작하는 모든 행 찾기
    stage_rows = []
    max_row = ws.max_row
    for row in range(first_data_row, max_row + 1):
        cell_value = ws.cell(row=row, column=1).value
        if cell_value and &#34;stage&#34; in str(cell_value).strip().lower():
            stage_rows.append(row)

    # num_stages 기반 fallback 범위 추가 (total_rows가 작아도 누락 방지)
    try:
        if num_stages and int(num_stages) &gt; 0:
            for row in range(first_data_row, first_data_row + int(num_stages)):
                if row not in stage_rows:
                    stage_rows.append(row)
    except Exception:
        pass

    # Row 24/25 누락 방지 (A18:BB28 구간)
    for row in (24, 25):
        if row &gt;= first_data_row and row &lt;= max_row and row not in stage_rows:
            stage_rows.append(row)

    stage_rows = sorted(set(stage_rows))
    if stage_rows:
        print(
            f&#34;  [DEBUG] Captain Req stage_rows={stage_rows} &#34;
            f&#34;(first_data_row={first_data_row}, num_stages={num_stages}, max_row={max_row})&#34;
        )

    # 모든 Stage 행에 수식 적용
    for row in stage_rows:
        row_str = str(row)

        # NOTE: &#39;일괄 적용&#39; 원칙
        # - 기존 값/수식이 있어도 모두 덮어써서(Stage 6C_TotalMassOpt 포함) 수식 누락/불일치 방지

        # U(21): GM(m) – Hydro_Table 기반 VLOOKUP(Tmean = AVG(Dfwd,Daft))
        c = ws.cell(row=row, column=21)
        c.value = (
            f&#39;=IF(OR(P{row_str}=&#34;&#34;, Q{row_str}=&#34;&#34;), &#34;&#34;, &#39;
            f&#39;IFERROR(VLOOKUP(AVERAGE(P{row_str},Q{row_str}), Hydro_Table!$B:$D, 3, 1), &#34;&#34;))&#39;
        )
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

        # V(22): Fwd Draft(m) – P열 Dfwd_m 복사
        c = ws.cell(row=row, column=22)
        c.value = f&#34;=P{row_str}&#34;
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

        # W(23): vs 2.70m – Calc!E18(=2.70m 한계)와 비교
        c = ws.cell(row=row, column=23)
        c.value = f&#39;=IF(V{row_str}=&#34;&#34;,&#34;&#34;,IF(V{row_str}&lt;=Calc!$E$18,&#34;OK&#34;,&#34;NG&#34;))&#39;
        c.font = styles[&#34;normal_font&#34;]

        # X(24): De-ballast Qty(t) – K열 Ballast_t 그대로
        c = ws.cell(row=row, column=24)
        c.value = f&#34;=K{row_str}&#34;
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

        # Y(25): Timing – 수기 입력용 (수식 없음, input_fill 적용)
        c = ws.cell(row=row, column=25)
        c.fill = styles[&#34;input_fill&#34;]
        c.font = styles[&#34;normal_font&#34;]

        # Z(26): Phys_Freeboard_m – (D_vessel - Dfwd) adjusted by ramp_door_offset_m
        c = ws.cell(row=row, column=26)
        c.value = f&#39;=IFERROR(IF(P{row_str}=&#34;&#34;,&#34;&#34;,$B$11 - P{row_str} - Calc!$E$19), &#34;&#34;)&#39;
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

        # AA(27): Clearance_Check – Phys_Freeboard_m vs linkspan_freeboard_target_m (Calc!E20)
        c = ws.cell(row=row, column=27)
        c.value = f&#39;=IFERROR(IF(Z{row_str}=&#34;&#34;, &#34;&#34;, IF(Z{row_str}&gt;=Calc!$E$20, &#34;OK&#34;, &#34;&lt;0.28m CHECK&#34;)), &#34;&#34;)&#39;
        c.font = styles[&#34;normal_font&#34;]

        # AB(28): GM_calc – =U
        c = ws.cell(row=row, column=28)
        c.value = f&#39;=IFERROR(U{row_str},&#34;&#34;)&#39;
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

        # AC(29): GM_Check – GM ≥ GM_target(=Calc!E21) 여부
        c = ws.cell(row=row, column=29)
        c.value = (
            f&#39;=IFERROR(IF(AB{row_str}=&#34;&#34;,&#34;&#34;,IF(AB{row_str}&gt;=Calc!$E$21,&#34;OK&#34;,&#34;NG&#34;)),&#34;&#34;)&#39;
        )
        c.font = styles[&#34;normal_font&#34;]

        # AD(30): Disp_total_t – Patch Option B: 실측 Const Tank Total 연동
        c = ws.cell(row=row, column=30)
        c.value = f&#39;=IF(A{row_str}=&#34;&#34;,&#34;&#34;,CONST_TANKS!$C$13+L{row_str}+B{row_str})&#39;
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

        # AE(31): Vent_Time_h – De-ballast qty / effective pump rate ($B$13, t/h)
        c = ws.cell(row=row, column=31)
        c.value = f&#39;=IFERROR(IF(OR(X{row_str}=&#34;&#34;,$B$13=&#34;&#34;,$B$13=0),&#34;&#34;,ROUND(ABS(X{row_str})/$B$13,2)),&#34;&#34;)&#39;
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

        # AR(44): Heel_deg – B / (Δ * GM) 기반 근사식
        c = ws.cell(row=row, column=44)
        c.value = (
            f&#39;=IFERROR(IF(OR($A{row_str}=&#34;&#34;,U{row_str}=&#34;&#34;,AD{row_str}=&#34;&#34;,AD{row_str}=0),&#34;&#34;,&#39;
            f&#39;DEGREES((B{row_str}*Calc!$E$43)/(AD{row_str}*U{row_str}))),&#34;&#34;)&#39;
        )
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

        # AS(45): GM_eff – GM - FSE/Δ (Patch Option B: CONST_TANKS!E13 사용)
        c = ws.cell(row=row, column=45)
        c.value = (
            f&#34;=IFERROR(&#34;
            f&#39;IF(OR($A{row_str}=&#34;&#34;, U{row_str}=&#34;&#34;, AD{row_str}=&#34;&#34;, AD{row_str}=0), &#34;&#34;, &#39;
            f&#34;U{row_str} - CONST_TANKS!$E$13 / AD{row_str}),&#34;
            f&#39;&#34;&#34;&#39;
            f&#34;)&#34;
        )
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

        # AT(46): Ramp_Angle_deg – Freeboard 기반 ramp 각도
        c = ws.cell(row=row, column=46)
        c.value = (
            f&#39;=IF(Z{row_str}=&#34;&#34;,&#34;&#34;,DEGREES(ASIN((Z{row_str}-Calc!$E$35)/Calc!$E$33)))&#39;
        )
        c.number_format = number_format
        c.font = styles[&#34;normal_font&#34;]

    # 수식 적용 후 검증 (U/AB/AC/AR/AS)
    check_cols = {
        21: &#34;U&#34;,
        28: &#34;AB&#34;,
        29: &#34;AC&#34;,
        44: &#34;AR&#34;,
        45: &#34;AS&#34;,
    }
    missing_checks = []
    for row in stage_rows:
        for col_idx, col_name in check_cols.items():
            v = ws.cell(row=row, column=col_idx).value
            if v is None or v == &#34;&#34;:
                missing_checks.append(f&#34;{col_name}{row}&#34;)
    if missing_checks:
        print(f&#34;  [WARN] Captain Req formula missing: {missing_checks}&#34;)

    # Optional: materialize U/AB/AC values (avoid Excel calc dependency)
    def _to_float(v):
        try:
            if v is None or v == &#34;&#34;:
                return None
            return float(v)
        except Exception:
            return None

    def _build_hydro_table(hydro_ws):
        if hydro_ws is None:
            return []
        headers = {}
        for c in range(1, hydro_ws.max_column + 1):
            h = hydro_ws.cell(row=1, column=c).value
            if h:
                headers[str(h).strip()] = c
        tmean_col = headers.get(&#34;Tmean_m&#34;, 2)
        gm_col = headers.get(&#34;GM_m&#34;, 4)
        rows = []
        for r in range(2, hydro_ws.max_row + 1):
            t = _to_float(hydro_ws.cell(row=r, column=tmean_col).value)
            gm = _to_float(hydro_ws.cell(row=r, column=gm_col).value)
            if t is None:
                continue
            rows.append((t, gm))
        rows.sort(key=lambda x: x[0])
        return rows

    def _lookup_gm(rows, tmean):
        if tmean is None or not rows:
            return None
        # clamp to nearest bounds to avoid empty results
        if tmean &lt;= rows[0][0]:
            return rows[0][1]
        gm_val = rows[0][1]
        for t, gm in rows:
            if t &lt;= tmean:
                gm_val = gm
            else:
                break
        return gm_val

    try:
        wb = ws.parent
        hydro_ws = wb[&#34;Hydro_Table&#34;] if &#34;Hydro_Table&#34; in wb.sheetnames else None
        calc_ws = wb[&#34;Calc&#34;] if &#34;Calc&#34; in wb.sheetnames else None
        gm_target = _to_float(calc_ws[&#34;E21&#34;].value) if calc_ws is not None else None
        hydro_rows = _build_hydro_table(hydro_ws)
        if hydro_rows:
            applied = 0
            for row in stage_rows:
                if not ws.cell(row=row, column=1).value:
                    continue
                g = _to_float(ws.cell(row=row, column=7).value)
                h = _to_float(ws.cell(row=row, column=8).value)
                if g is None or h is None:
                    continue
                tmean = (g + h) / 2.0
                gm = _lookup_gm(hydro_rows, tmean)
                if gm is None:
                    continue
                # U (GM)
                c = ws.cell(row=row, column=21, value=gm)
                c.number_format = number_format
                c.font = styles[&#34;normal_font&#34;]
                # AB (GM copy)
                c = ws.cell(row=row, column=28, value=gm)
                c.number_format = number_format
                c.font = styles[&#34;normal_font&#34;]
                # AC (GM check)
                if gm_target is not None:
                    ws.cell(
                        row=row,
                        column=29,
                        value=&#34;OK&#34; if gm &gt;= gm_target else &#34;NG&#34;,
                    ).font = styles[&#34;normal_font&#34;]
                applied += 1
            if applied &gt; 0:
                print(
                    f&#34;  [OK] Captain Req values materialized (U/AB/AC) for {applied} rows&#34;
                )
    except Exception as e:
        print(f&#34;  [WARN] Captain Req value materialization skipped: {e}&#34;)

    print(
        f&#34;  [OK] Captain Req columns added to RORO_Stage_Scenarios sheet (Patched) - Applied to {len(stage_rows)} stage rows&#34;
    )</code></pre>
</details>
<div class="desc"><p>RORO_Stage_Scenarios 시트 Captain Requirement 확장 컬럼(U~AE, AR~AT) 생성.</p>
<ul>
<li>U
: GM(m)
(Hydro_Table!B:D 기반 VLOOKUP)</li>
<li>V
: Fwd Draft(m)
(Dfwd_m 복사)</li>
<li>W
: vs 2.70m
(Fwd ≤ 2.70m 체크)</li>
<li>X
: De-ballast Qty
(Ballast_t)</li>
<li>Y
: Timing
(수기 입력용)</li>
<li>Z
: Phys_Freeboard
(Calc!E19 - Dfwd)</li>
<li>AB : GM copy
(=U)</li>
<li>AC : GM Check
(GM ≥ GM_target=Calc!E21)</li>
<li>AD : Disp_total_t
(950 + Ballast + Cargo)</li>
<li>AE : Vent_Time_h
(De-ballast Qty / $B$13 t/h)</li>
<li>AR : Heel_deg
(B / (Δ * GM) 기반 근사)</li>
<li>AS : GM_eff
(GM * cos(Heel))</li>
<li>AT : Ramp_Angle_deg
(Freeboard 기반 ramp 각도)</li>
</ul>
<p>✅ 이 함수가 모든 Stage 행에 수식을 써주므로
U25 / AB25 / AC25 / AR25 / AS25 수식 에러가 사라집니다.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_roro_structural_opt1"><code class="name flex">
<span>def <span class="ident">extend_roro_structural_opt1</span></span>(<span>ws, first_data_row, num_stages)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_roro_structural_opt1(ws, first_data_row, num_stages):
    &#34;&#34;&#34;RORO 시트에 Structural Strength 및 Option 1 Ballast Fix Check 컬럼 추가 (Col AE-AO)&#34;&#34;&#34;
    styles = get_styles()
    # 숫자 포맷 통일: 천단위 구분, 소수점 2자리
    number_format = &#34;#,##0.00&#34;

    # Structural Strength 컬럼 (AK-AP) - PATCH C 컬럼과 충돌 방지를 위해 AK(37)부터 시작
    structural_cols = [
        &#34;Share_Load_t&#34;,
        &#34;Share_Check&#34;,
        &#34;Hinge_Rx_t&#34;,
        &#34;Rx_Check&#34;,
        &#34;Deck_Press_t/m²&#34;,
        &#34;Press_Check&#34;,
    ]

    # Dynamic Load Case B 컬럼 (AQ) - Load_Case_C_t는 AR(44)와 충돌하므로 제거
    dynamic_load_cols = [
        &#34;Load_Case_B_t&#34;,  # AQ (43): Dynamic factor applied
        # &#34;Load_Case_C_t&#34; 제거 (AR(44) 충돌)
    ]

    # Heel/FSE 컬럼 추가 (AR-AS, column 44-45)
    # ⚠️ CRITICAL WARNING: AR(44), AS(45)는 절대 덮어쓰지 말 것!
    #
    # AR(44): Heel_deg = DEGREES((B * Calc!E43) / (AD * U))
    #   - 경사각 계산 (deg)
    #   - B: 화물 편심 모멘트
    #   - AD: Total Displacement
    #   - U: GM
    #
    # AS(45): GM_eff = U - CONST_TANKS!E13 / AD
    #   - 유효 GM (자유 표면 효과 반영)
    #   - U: GM (Hydro table 기반)
    #   - CONST_TANKS!E13: Total FSM (887.04 t·m)
    #   - AD: Total Displacement
    #
    # 이 두 컬럼은 extend_roro_captain_req()에서만 작성되어야 하며,
    # 다른 함수에서 절대 덮어쓰면 안 됨!
    # 헤더만 추가, 수식은 extend_roro_captain_req()에서 작성됨
    heel_fse_cols = [
        &#34;Heel_deg&#34;,  # AR (44) - extend_roro_captain_req에서 작성됨
        &#34;GM_eff_m&#34;,  # AS (45) - extend_roro_captain_req에서 작성됨
    ]

    # Option 1 Ballast Fix Check 컬럼 (AT-AV)
    opt1_cols = [
        &#34;Ballast_req_t&#34;,  # AT (46) - 기존 유지
        &#34;Ballast_gap_t&#34;,  # AU (47) - 기존 유지
        &#34;Time_Add_h&#34;,  # AV (48) - 기존 유지
        # &#34;ΔTM_needed_cm·tm&#34; 제거 (AS(45) 충돌로 인해 제거됨)
    ]

    # Ramp Angle &amp; Pin Stress 컬럼 (AW-AZ, column 49-52)
    ramp_stress_cols = [
        &#34;Ramp_Angle_deg&#34;,  # AW (49)
        &#34;Ramp_Angle_Check&#34;,  # AX (50)
        &#34;Pin_Stress_N/mm²&#34;,  # AY (51)
        &#34;Von_Mises_Check&#34;,  # AZ (52)
    ]

    # Opt C / High Tide 관련 컬럼 (BA-BB, column 53-54)
    # Opt C / Water level requirement columns (BA-BB)
    # NOTE: &#34;Required_WL_m&#34; is required water level (NOT forecast tide). Compare against Forecast_Tide_m.
    opt_c_tide_cols = [
        &#34;Required_WL_m&#34;,  # BA (53)
        &#34;WL_OK&#34;,  # BB (54)
    ]

    all_cols = (
        structural_cols  # AK-AP (37-42)
        + dynamic_load_cols  # AQ (43)
        + heel_fse_cols  # AR-AS (44-45) - 헤더만 추가, 수식은 extend_roro_captain_req에서
        + opt1_cols  # AT-AV (46-48)
        + ramp_stress_cols  # AW-AZ (49-52)
        + opt_c_tide_cols  # BA-BB (53-54)
    )
    start_col = (
        37  # PATCH C 컬럼 (AF-AJ, column 32-36)과 충돌 방지를 위해 AK(37)부터 시작
    )

    for i, h in enumerate(all_cols):
        col = start_col + i
        header_row = first_data_row - 1  # Row 17 (first_data_row=18이므로)
        cell = ws.cell(row=header_row, column=col)
        cell.value = h
        cell.font = styles[&#34;header_font&#34;]
        cell.alignment = styles[&#34;center_align&#34;]
        cell.border = Border(
            left=styles[&#34;thin_border&#34;],
            right=styles[&#34;thin_border&#34;],
            top=styles[&#34;thin_border&#34;],
            bottom=styles[&#34;thin_border&#34;],
        )
        # Structural 컬럼은 주황색, Dynamic Load는 주황색, Heel/FSE는 주황색, Option 1 컬럼은 보라색, Ramp/Stress 컬럼은 주황색, Opt C Tide 컬럼은 보라색
        if i &lt; len(structural_cols):
            cell.fill = styles[&#34;structure_fill&#34;]
        elif i &lt; len(structural_cols) + len(dynamic_load_cols):
            cell.fill = styles[
                &#34;structure_fill&#34;
            ]  # Dynamic Load Case uses structure fill
        elif i &lt; len(structural_cols) + len(dynamic_load_cols) + len(heel_fse_cols):
            cell.fill = styles[&#34;structure_fill&#34;]  # Heel/FSE columns use structure fill
        elif i &lt; len(structural_cols) + len(dynamic_load_cols) + len(
            heel_fse_cols
        ) + len(opt1_cols):
            cell.fill = styles[&#34;opt1_fill&#34;]  # Option 1 uses opt1 fill
        elif i &lt; len(structural_cols) + len(dynamic_load_cols) + len(
            heel_fse_cols
        ) + len(opt1_cols) + len(ramp_stress_cols):
            cell.fill = styles[
                &#34;structure_fill&#34;
            ]  # Ramp/Stress columns use structure fill
        else:
            cell.fill = styles[&#34;opt1_fill&#34;]  # Opt C Tide columns use opt1 fill

    for row in range(first_data_row, first_data_row + num_stages):
        row_str = str(row)

        # Structural Strength 컬럼 (AK-AP) - PATCH C 컬럼 (AF-AJ)과 충돌 방지를 위해 AK(37)부터 시작
        # AK (37): Share_Load_t - 입력
        ws.cell(row=row, column=37).fill = styles[&#34;input_fill&#34;]
        ws.cell(row=row, column=37).font = styles[&#34;normal_font&#34;]

        # AL (38): Share_Check
        ws.cell(row=row, column=38).value = (
            f&#39;=IF(AK{row_str}=&#34;&#34;, &#34;&#34;, IF(AK{row_str}&lt;=Calc!$E$24, &#34;OK&#34;, &#34;CHECK&#34;))&#39;
        )
        ws.cell(row=row, column=38).font = styles[&#34;normal_font&#34;]

        # AM (39): Hinge_Rx_t
        # 자동 계산 (Ramp 자중 45 t + share 54.5%)
        ws.cell(row=row, column=39).value = (
            f&#39;=IF(AK{row_str}=&#34;&#34;, 45, 45 + AK{row_str} * 0.545)&#39;
        )
        ws.cell(row=row, column=39).number_format = number_format
        ws.cell(row=row, column=39).font = styles[&#34;normal_font&#34;]

        # AN (40): Rx_Check
        ws.cell(row=row, column=40).value = (
            f&#39;=IF(AM{row_str}=&#34;&#34;, &#34;&#34;, IF(AM{row_str}&lt;=Calc!$E$37, &#34;OK&#34;, &#34;NG&#34;))&#39;
        )
        ws.cell(row=row, column=40).font = styles[&#34;normal_font&#34;]

        # AO (41): Deck_Press_t/m²
        ws.cell(row=row, column=41).value = (
            f&#39;=IF(AK{row_str}=&#34;&#34;, &#34;&#34;, AK{row_str}/Calc!$E$26)&#39;
        )
        ws.cell(row=row, column=41).number_format = number_format
        ws.cell(row=row, column=41).font = styles[&#34;normal_font&#34;]

        # AP (42): Press_Check
        ws.cell(row=row, column=42).value = (
            f&#39;=IF(AO{row_str}=&#34;&#34;, &#34;&#34;, IF(AO{row_str}&lt;=Calc!$E$25, &#34;OK&#34;, &#34;CHECK&#34;))&#39;
        )
        ws.cell(row=row, column=42).font = styles[&#34;normal_font&#34;]

        # Dynamic Load Case B/C 컬럼 (AQ-AR) - PATCH C 컬럼과 충돌 방지를 위해 AQ(43)부터 시작
        # AQ (43): Load_Case_B_t - Dynamic factor applied to Share_Load
        ws.cell(row=row, column=43).value = (
            f&#39;=IF(AK{row_str}=&#34;&#34;, &#34;&#34;, AK{row_str} * Calc!$E$42)&#39;
        )
        ws.cell(row=row, column=43).number_format = number_format
        ws.cell(row=row, column=43).font = styles[&#34;normal_font&#34;]

        # ===== PATCH FIX: AR(44), AS(45) 컬럼 충돌 방지 =====
        # AR(44): Heel_deg는 extend_roro_captain_req()에서 작성됨 (라인 6431-6438)
        # AS(45): GM_eff는 extend_roro_captain_req()에서 작성됨 (라인 6440-6450)
        #
        # ⚠️ CRITICAL: 아래 코드는 위 수식을 덮어쓰므로 주석 처리 필수!
        #
        # # AR (44): Load_Case_C_t - REMOVED (충돌)
        # # ws.cell(row=row, column=44).value = (
        # #     f&#39;=IF(AQ{row_str}=&#34;&#34;, &#34;&#34;, AQ{row_str} + 0.2 * B{row_str} * 9.81 / 1000)&#39;
        # # )
        # # ws.cell(row=row, column=44).number_format = number_format
        # # ws.cell(row=row, column=44).font = styles[&#34;normal_font&#34;]
        #
        # # AS (45): ΔTM_needed_cm·tm - REMOVED (충돌, 필요시 다른 컬럼으로 이동)
        # # ws.cell(row=row, column=45).value = f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;,ABS(H{row_str}))&#39;
        # # ws.cell(row=row, column=45).number_format = number_format
        # # ws.cell(row=row, column=45).font = styles[&#34;normal_font&#34;]

        # Option 1 Ballast Fix Check 컬럼은 AT(46)부터 시작 (기존 유지)
        # ⚠️ AR(44) 작성 SKIP (extend_roro_captain_req에서 작성됨)
        # ⚠️ AS(45) 작성 SKIP (extend_roro_captain_req에서 작성됨)

        # AT (46): Ballast_req_t - zzzzz.md 가이드: J열과 같은 개념 (H/I)
        ws.cell(row=row, column=46).value = (
            f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;,&#39;
            f&#39;IF(OR($I{row_str}=&#34;&#34;,$I{row_str}=0),0,ROUND(H{row_str}/$I{row_str},2)))&#39;
        )
        ws.cell(row=row, column=46).number_format = number_format
        ws.cell(row=row, column=46).font = styles[&#34;normal_font&#34;]

        # AU (47): Ballast_gap_t - zzzzz.md 가이드: 필요한 Ballast - 실제 Ballast(L열)
        ws.cell(row=row, column=47).value = (
            f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;,AT{row_str} - $L{row_str})&#39;
        )
        ws.cell(row=row, column=47).number_format = number_format
        ws.cell(row=row, column=47).font = styles[&#34;normal_font&#34;]

        # AV (48): Time_Add_h - zzzzz.md 가이드: AT를 펌프 레이트(B13)로 나눈 추가 시간
        ws.cell(row=row, column=48).value = (
            f&#39;=IF($A{row_str}=&#34;&#34;,&#34;&#34;,&#39; f&#34;IF($B$13=0,0,AU{row_str}/$B$13))&#34;
        )
        ws.cell(row=row, column=48).number_format = number_format
        ws.cell(row=row, column=48).font = styles[&#34;normal_font&#34;]

        # Heel/FSE 컬럼 (AW-AX) - extend_roro_captain_req()에서 이미 작성됨
        # ✅ SKIP: extend_roro_captain_req()에서 이미 AR(44), AS(45) 작성됨
        # 중복 작성 방지를 위해 이 섹션은 주석 처리
        # 주의: extend_roro_captain_req()가 먼저 실행되므로 여기서 재작성 불필요

        # Ramp Angle &amp; Pin Stress 컬럼 (AW-AZ) - PATCH C 컬럼과 충돌 방지를 위해 AW(49)부터 시작
        # AW (49): Ramp_Angle_deg
        # Z{row}: Phys_Freeboard_m - sdsdds.md: Q열 추가로 Y(25) → Z(26)로 이동
        ws.cell(row=row, column=49).value = (
            f&#39;=IF(Z{row_str}=&#34;&#34;,&#34;&#34;,DEGREES(ASIN((Z{row_str}-Calc!$E$35)/Calc!$E$33)))&#39;
        )
        ws.cell(row=row, column=49).number_format = number_format
        ws.cell(row=row, column=49).font = styles[&#34;normal_font&#34;]

        # AX (50): Ramp_Angle_Check
        ws.cell(row=row, column=50).value = (
            f&#39;=IF(AW{row_str}=&#34;&#34;,&#34;&#34;,IF(AW{row_str}&lt;=6,&#34;OK&#34;,&#34;NG&#34;))&#39;
        )
        ws.cell(row=row, column=50).font = styles[&#34;normal_font&#34;]

        # AY (51): Pin_Stress_N_mm2
        ws.cell(row=row, column=51).value = (
            f&#39;=IF(AM{row_str}=&#34;&#34;,&#34;&#34;,(AM{row_str}/4)/Calc!$E$36*9.81/1000)&#39;
        )
        ws.cell(row=row, column=51).number_format = number_format
        ws.cell(row=row, column=51).font = styles[&#34;normal_font&#34;]

        # AZ (52): Von_Mises_Check
        ws.cell(row=row, column=52).value = (
            f&#39;=IF(AY{row_str}=&#34;&#34;,&#34;&#34;,IF(AY{row_str}&lt;=188,&#34;OK&#34;,&#34;NG&#34;))&#39;
        )
        ws.cell(row=row, column=52).font = styles[&#34;normal_font&#34;]

        # BA (53): Required_WL_m (NOT forecast tide)
        # Required_Tide_m = IF(Phys_Freeboard_m&gt;=0, 0, ABS(Phys_Freeboard_m) + 0.30)
        # Z{row}: Phys_Freeboard_m (column 26)
        ws.cell(row=row, column=53).value = (
            f&#39;=IF(Z{row_str}=&#34;&#34;, &#34;&#34;, IF(Z{row_str}&gt;=0, 0, ABS(Z{row_str})+0.30))&#39;
        )
        ws.cell(row=row, column=53).number_format = number_format
        ws.cell(row=row, column=53).font = styles[&#34;normal_font&#34;]

        # BB (54): Tide_OK
        # WL_OK = IF(Forecast_Tide_m &gt;= Required_WL_m, &#34;OK&#34;, &#34;CHECK&#34;)
        # Forecast_Tide_m is at RORO_Stage_Scenarios!B7
        ws.cell(row=row, column=54).value = (
            f&#39;=IF(BA{row_str}=&#34;&#34;, &#34;&#34;, IF($B$7&gt;=BA{row_str}, &#34;OK&#34;, &#34;CHECK&#34;))&#39;
        )
        ws.cell(row=row, column=54).font = styles[&#34;normal_font&#34;]

    # 컬럼 너비 설정 - PATCH C 컬럼 추가로 범위 조정
    for col in range(32, 55):  # AF(32) ~ BB(54) - PATCH C (AF-AJ) + Structural (AK-BB)
        col_letter = get_column_letter(col)
        ws.column_dimensions[col_letter].width = 11
    # Heel_deg(AR) / GM_eff(AS)는 extend_roro_captain_req에서 이미 처리됨
    ws.column_dimensions[&#34;AW&#34;].width = 15  # Ramp_Angle_deg (AW, column 49)
    ws.column_dimensions[&#34;AY&#34;].width = 15  # Pin_Stress_N/mm² (AY, column 51)
    ws.column_dimensions[&#34;BA&#34;].width = 15  # Required_WL_m
    ws.column_dimensions[&#34;BB&#34;].width = 12  # WL_OK

    print(
        &#34;  [OK] Structural Strength &amp; Option 1 Ballast Fix Check columns added to RORO_Stage_Scenarios sheet&#34;
    )
    print(&#34;  [OK] Hinge Rx 자동 계산 적용&#34;)
    print(
        &#34;  [OK] Dynamic Load Case B/C (AL-AM), Option 1 moved (AN-AQ), Heel/FSE (AR-AS), Ramp/Stress moved (AT-AW) (sdsdds.md: Q열 추가)&#34;
    )</code></pre>
</details>
<div class="desc"><p>RORO 시트에 Structural Strength 및 Option 1 Ballast Fix Check 컬럼 추가 (Col AE-AO)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.find_preballast_opt"><code class="name flex">
<span>def <span class="ident">find_preballast_opt</span></span>(<span>w_tr_unit_t: float = 271.2,<br>base_disp_t: float | None = None,<br>fr_tr1_stow: float = 42.0,<br>fr_tr2_ramp: float = 17.95,<br>fr_preballast: float = 3.0,<br>params: dict | None = None,<br>search_min_t: float = 20.0,<br>search_max_t: float = 400.0,<br>search_step_t: float = 1.0) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_preballast_opt(
    w_tr_unit_t: float = 271.20,
    base_disp_t: float | None = None,
    fr_tr1_stow: float = FR_TR1_STOW,
    fr_tr2_ramp: float = FR_TR2_RAMP,
    fr_preballast: float = FR_PREBALLAST,
    params: dict | None = None,
    search_min_t: float = 20.0,  # PATCH FIX #3: 최소 탐색량 설정 (0.00t 방지용)
    search_max_t: float = 400.0,
    search_step_t: float = 1.0,
) -&gt; dict:
    &#34;&#34;&#34;Stage 5_PreBallast ~ 6A_Critical(Opt C) 자동 최적화 루프.

    STRATEGY UPDATE (2025-11-24):
    - Pre-ballast location: FW2 Stern tank (Fr.0-6, AFT)
    - Target: Stage 6A FWD as close to 2.70m as possible
    - Validated solution: ~37.65t achieves FWD≈2.09m at Stage 6A

    목적:
      1) Stage 5_PreBallast, Stage 6A 모두에서
         - min_fwd_draft_m ≤ FWD ≤ max_fwd_draft_ops_m
         - |Trim_cm| ≤ trim_limit_abs_cm
      2) 위 조건을 만족하는 해 중에서
         - Stage 6A의 FWD가 max_fwd_draft_ops_m에 가장 가깝도록 (worst-case margin 최소)
         - 동률일 경우 pre-ballast 중량이 더 작은 해 선호

    알고리즘:
      - Iterative optimization (최대 380회 반복, search_step_t=1.0 기준)
      - 탐색 범위: search_min_t ~ search_max_t (기본값: 20.0t ~ 400.0t)
      - 각 후보 pre-ballast 중량에 대해 Stage 5, 6A 계산 수행
      - 수렴 조건: Stage 5 및 6A 모두 FWD ≤ max_fwd_draft_ops_m (2.70m)

    최적화 전략:
      - Stern pre-ballast (FW2 tank, Fr.0-6 위치) 사용
      - 전부 Draft 제어 목표
      - Even keel 근접 목표

    검증 게이트:
      1. Draft limits: min_fwd ≤ FWD ≤ max_fwd (1.50m ~ 2.70m)
      2. Trim envelope: |Trim| ≤ trim_limit (240cm)
      3. Objective: Stage 6A FWD를 2.70m에 최대한 근접

    Args:
        w_tr_unit_t: Transformer 단위 중량 (t)
        base_disp_t: Stage 1 baseline displacement (t)
        fr_tr1_stow: TR1 최종 stow Frame 번호
        fr_tr2_ramp: TR2 ramp Frame 번호
        fr_preballast: Pre-ballast Frame 번호 (FW2, Fr.0-6)
        params: 파라미터 딕셔너리 (DEFAULT_PARAMS 사용 가능)
        search_min_t: 최소 탐색량 (t), 기본값 20.0
        search_max_t: 최대 탐색량 (t), 기본값 400.0
        search_step_t: 탐색 간격 (t), 기본값 1.0

    Returns:
        dict: {
            &#34;ok&#34;: bool,                # 최적화 성공 여부
            &#34;reason&#34;: str,             # 성공/실패 이유
            &#34;w_preballast_t&#34;: float | None,  # 최적 ballast 중량 (t)
            &#34;stage5&#34;: dict | None,     # Stage 5 계산 결과
            &#34;stage6A&#34;: dict | None     # Stage 6A 계산 결과
        }

    OBSOLETE SCENARIOS (DO NOT USE):
    - Bow Ballast 471t (FWB1+FWB2+FWCARGO1): FWD 2.99m → EXCEEDS LIMIT
    - Forward ballast strategies: All superseded by Stern strategy

    See Also:
        - DATA_SOURCE_DOCUMENTATION.md Section 4.2
        - build_stage_loads() for stage load composition
        - solve_stage() for individual stage calculation
    &#34;&#34;&#34;

    # Option B+ input gate: ensure submission-grade inputs exist
    _bplus_preflight_or_zero(strict=True)
    if params is None:
        params = DEFAULT_PARAMS
    if base_disp_t is None:
        base_disp_t = _as_float(
            params.get(&#34;base_disp_t&#34;), _as_float(params.get(&#34;BASE_DISP_T&#34;), 0.0)
        )
    if base_disp_t &lt;= 0:
        print(&#34;[WARN] base_disp_t not set; W_stage_t will exclude base displacement.&#34;)

    min_fwd = params.get(&#34;min_fwd_draft_m&#34;, 1.50)
    max_fwd = params.get(&#34;max_fwd_draft_ops_m&#34;, 2.70)
    trim_limit = params.get(&#34;trim_limit_abs_cm&#34;, 240.00)
    # NOTE: CHECK_STAGE5=True enforces FWD≤2.70m for Stage 5_PreBallast
    # Set to False to allow intentional bow-down trim exploration
    # CURRENT DESIGN: True (strict enforcement for Harbor Master approval)
    check_stage5 = params.get(&#34;CHECK_STAGE5&#34;, True)

    if search_step_t &lt;= 0:
        raise ValueError(&#34;search_step_t must be positive.&#34;)

    best: dict | None = None
    best_metric: float | None = None

    w = search_min_t
    while w &lt;= search_max_t + 1e-9:
        result = _stage_moment_and_drafts_for_preballast(
            w_tr_unit_t=w_tr_unit_t,
            w_preballast_t=w,
            fr_tr1_stow=fr_tr1_stow,
            fr_tr2_ramp=fr_tr2_ramp,
            fr_preballast=fr_preballast,
            base_disp_t=base_disp_t,
            params=params,
        )

        st5 = result[&#34;stage5&#34;]
        st6 = result[&#34;stage6A&#34;]

        fwd5 = st5[&#34;FWD_m&#34;]
        fwd6 = st6[&#34;FWD_m&#34;]
        trim5 = abs(st5[&#34;Trim_cm&#34;])
        trim6 = abs(st6[&#34;Trim_cm&#34;])

        # Gate 1: Draft limits
        # Stage 5도 CHECK_STAGE5=True인 경우 FWD≤max_fwd_draft_ops_m를 강제 (Harbor Master 제출용)
        if check_stage5 and not (min_fwd &lt;= fwd5 &lt;= max_fwd):
            w += search_step_t
            continue
        if not (min_fwd &lt;= fwd6 &lt;= max_fwd):
            w += search_step_t
            continue

        # Gate 2: Trim envelope
        # Stage 5 체크는 선택적 (Stage 5_PreBallast는 의도적 bow trim 240cm 목표)
        if check_stage5 and trim5 &gt; trim_limit:
            w += search_step_t
            continue
        if trim6 &gt; trim_limit:
            w += search_step_t
            continue

        # Objective: Stage 6A FWD as close as possible to ops limit (max_fwd)
        # PATCH FIX #4: Stage 5도 고려하여 페널티 추가
        margin5 = max_fwd - fwd5  # Stage 5 마진
        margin6 = max_fwd - fwd6  # Stage 6A 마진
        # 목표: Stage 6A margin 최소이면서 Stage 5도 margin 양호
        metric = abs(margin6) + 0.1 * abs(margin5)  # Stage 5 페널티 10%

        if best_metric is None or metric &lt; best_metric - 1e-9:
            best_metric = metric
            best = result
        elif best is not None and abs(metric - best_metric) &lt; 1e-9:
            # tie-breaker: smaller ballast preferred
            if w &lt; best[&#34;w_preballast_t&#34;]:
                best_metric = metric
                best = result

        w += search_step_t

    if best is None:
        return {
            &#34;ok&#34;: False,
            &#34;reason&#34;: &#34;No feasible pre-ballast found within search range.&#34;,
            &#34;w_preballast_t&#34;: None,
            &#34;stage5&#34;: None,
            &#34;stage6A&#34;: None,
        }

    return {
        &#34;ok&#34;: True,
        &#34;reason&#34;: &#34;Feasible pre-ballast found.&#34;,
        &#34;w_preballast_t&#34;: best[&#34;w_preballast_t&#34;],
        &#34;stage5&#34;: best[&#34;stage5&#34;],
        &#34;stage6A&#34;: best[&#34;stage6A&#34;],
    }</code></pre>
</details>
<div class="desc"><p>Stage 5_PreBallast ~ 6A_Critical(Opt C) 자동 최적화 루프.</p>
<p>STRATEGY UPDATE (2025-11-24):
- Pre-ballast location: FW2 Stern tank (Fr.0-6, AFT)
- Target: Stage 6A FWD as close to 2.70m as possible
- Validated solution: ~37.65t achieves FWD≈2.09m at Stage 6A</p>
<p>목적:
1) Stage 5_PreBallast, Stage 6A 모두에서
- min_fwd_draft_m ≤ FWD ≤ max_fwd_draft_ops_m
- |Trim_cm| ≤ trim_limit_abs_cm
2) 위 조건을 만족하는 해 중에서
- Stage 6A의 FWD가 max_fwd_draft_ops_m에 가장 가깝도록 (worst-case margin 최소)
- 동률일 경우 pre-ballast 중량이 더 작은 해 선호</p>
<p>알고리즘:
- Iterative optimization (최대 380회 반복, search_step_t=1.0 기준)
- 탐색 범위: search_min_t ~ search_max_t (기본값: 20.0t ~ 400.0t)
- 각 후보 pre-ballast 중량에 대해 Stage 5, 6A 계산 수행
- 수렴 조건: Stage 5 및 6A 모두 FWD ≤ max_fwd_draft_ops_m (2.70m)</p>
<p>최적화 전략:
- Stern pre-ballast (FW2 tank, Fr.0-6 위치) 사용
- 전부 Draft 제어 목표
- Even keel 근접 목표</p>
<p>검증 게이트:
1. Draft limits: min_fwd ≤ FWD ≤ max_fwd (1.50m ~ 2.70m)
2. Trim envelope: |Trim| ≤ trim_limit (240cm)
3. Objective: Stage 6A FWD를 2.70m에 최대한 근접</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>w_tr_unit_t</code></strong></dt>
<dd>Transformer 단위 중량 (t)</dd>
<dt><strong><code>base_disp_t</code></strong></dt>
<dd>Stage 1 baseline displacement (t)</dd>
<dt><strong><code>fr_tr1_stow</code></strong></dt>
<dd>TR1 최종 stow Frame 번호</dd>
<dt><strong><code>fr_tr2_ramp</code></strong></dt>
<dd>TR2 ramp Frame 번호</dd>
<dt><strong><code>fr_preballast</code></strong></dt>
<dd>Pre-ballast Frame 번호 (FW2, Fr.0-6)</dd>
<dt><strong><code>params</code></strong></dt>
<dd>파라미터 딕셔너리 (DEFAULT_PARAMS 사용 가능)</dd>
<dt><strong><code>search_min_t</code></strong></dt>
<dd>최소 탐색량 (t), 기본값 20.0</dd>
<dt><strong><code>search_max_t</code></strong></dt>
<dd>최대 탐색량 (t), 기본값 400.0</dd>
<dt><strong><code>search_step_t</code></strong></dt>
<dd>탐색 간격 (t), 기본값 1.0</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>{
"ok": bool,
# 최적화 성공 여부
"reason": str,
# 성공/실패 이유
"w_preballast_t": float | None,
# 최적 ballast 중량 (t)
"stage5": dict | None,
# Stage 5 계산 결과
"stage6A": dict | None
# Stage 6A 계산 결과</dd>
</dl>
<p>}
OBSOLETE SCENARIOS (DO NOT USE):
- Bow Ballast 471t (FWB1+FWB2+FWCARGO1): FWD 2.99m → EXCEEDS LIMIT
- Forward ballast strategies: All superseded by Stern strategy</p>
<p>See Also:
- DATA_SOURCE_DOCUMENTATION.md Section 4.2
- build_stage_loads() for stage load composition
- solve_stage() for individual stage calculation</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.fr_to_x"><code class="name flex">
<span>def <span class="ident">fr_to_x</span></span>(<span>fr: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fr_to_x(fr: float) -&gt; float:
    &#34;&#34;&#34;
    Convert Frame number to x [m from midship].

    BUSHRA 757 TCP 기준:
    - Frame 증가 = FWD 방향
    - Frame 30.151 = Midship → x = 0.0
    - Frame &lt; 30.151 (AFT) → x &gt; 0 (AFT)
    - Frame &gt; 30.151 (FWD) → x &lt; 0 (FWD)

    공식: x = _FRAME_SLOPE * (fr - _FRAME_OFFSET)
    &#34;&#34;&#34;
    x = _FRAME_SLOPE * (float(fr) - _FRAME_OFFSET)
    # Validation: Ensure convention is maintained
    # - fr &lt; offset (AFT) =&gt; x &gt; 0
    # - fr &gt; offset (FWD) =&gt; x &lt; 0
    if fr &lt; _FRAME_OFFSET and x &lt;= 0:
        logging.warning(
            f&#34;[TrimRef] x-coordinate convention violation: Fr={fr}, x={x:.3f} (expected x&gt;0 for AFT)&#34;
        )
    elif fr &gt; _FRAME_OFFSET and x &gt;= 0:
        logging.warning(
            f&#34;[TrimRef] x-coordinate convention violation: Fr={fr}, x={x:.3f} (expected x&lt;0 for FWD)&#34;
        )
    return x</code></pre>
</details>
<div class="desc"><p>Convert Frame number to x [m from midship].</p>
<p>BUSHRA 757 TCP 기준:
- Frame 증가 = FWD 방향
- Frame 30.151 = Midship → x = 0.0
- Frame &lt; 30.151 (AFT) → x &gt; 0 (AFT)
- Frame &gt; 30.151 (FWD) → x &lt; 0 (FWD)</p>
<p>공식: x = _FRAME_SLOPE * (fr - _FRAME_OFFSET)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.get_fixed_tank_data"><code class="name flex">
<span>def <span class="ident">get_fixed_tank_data</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fixed_tank_data():
    &#34;&#34;&#34;
    Forward fresh water ballast tanks (FWB1/2) - 757 TCP Tank Plan Verified LCGs.

    Coordinate System (Python Script Internal):
    - Midship (0.0) is at 30.151m from AP.
    - FWD is NEGATIVE (-), AFT is POSITIVE (+).
    - Formula: x_from_mid = Midship_LCG (30.151) - Tank_LCG_from_AP

    Reference: tank.md (Tank Plan 757 TCP)
    - FWB1 LCG: 57.519 m from AP
    - FWB2 LCG: 50.038 m from AP
    &#34;&#34;&#34;
    MIDSHIP_LCG_FROM_AP = 30.151

    # LCG to Script X conversion (Midship - LCG)
    # FWD tanks will result in negative values (Correct for this script)
    x_fwb1 = MIDSHIP_LCG_FROM_AP - 57.519  # 30.151 - 57.519 = -27.368 m
    x_fwb2 = MIDSHIP_LCG_FROM_AP - 50.038  # 30.151 - 50.038 = -19.887 m
    x_fwcargo1 = MIDSHIP_LCG_FROM_AP - 42.750  # 30.151 - 42.750 = -12.599 m
    x_fwcargo2 = MIDSHIP_LCG_FROM_AP - 35.250  # 30.151 - 35.250 = -5.099 m

    return {
        # FWB1 (Bow Ballast) - Fr 56-FE
        &#34;FWB1.P&#34;: {
            &#34;x&#34;: x_fwb1,
            &#34;max_t&#34;: 50.57,
            &#34;SG&#34;: 1.000,  # Fixed: Fresh Water SG 1.000
            &#34;note&#34;: &#34;Bow Port (LCG 57.519m)&#34;,
        },
        &#34;FWB1.S&#34;: {
            &#34;x&#34;: x_fwb1,
            &#34;max_t&#34;: 50.57,
            &#34;SG&#34;: 1.000,  # Fixed: Fresh Water SG 1.000
            &#34;note&#34;: &#34;Bow Stbd (LCG 57.519m)&#34;,
        },
        # FWB2 (Forward Ballast) - Fr 48-53
        &#34;FWB2.P&#34;: {
            &#34;x&#34;: x_fwb2,
            &#34;max_t&#34;: 109.98,
            &#34;SG&#34;: 1.000,  # Fixed: Fresh Water SG 1.000
            &#34;note&#34;: &#34;Fwd Port (LCG 50.038m)&#34;,
        },
        &#34;FWB2.S&#34;: {
            &#34;x&#34;: x_fwb2,
            &#34;max_t&#34;: 109.98,
            &#34;SG&#34;: 1.000,  # Fixed: Fresh Water SG 1.000
            &#34;note&#34;: &#34;Fwd Stbd (LCG 50.038m)&#34;,
        },
        # FWCARGO1 (Mid-Fwd) - Fr 43-48
        &#34;FWCARGO1.P&#34;: {
            &#34;x&#34;: x_fwcargo1,
            &#34;max_t&#34;: 148.35,
            &#34;SG&#34;: 1.000,
            &#34;note&#34;: &#34;Mid-Fwd Cargo (LCG 42.750m)&#34;,
        },
        &#34;FWCARGO1.S&#34;: {
            &#34;x&#34;: x_fwcargo1,
            &#34;max_t&#34;: 148.35,
            &#34;SG&#34;: 1.000,
            &#34;note&#34;: &#34;Mid-Fwd Cargo (LCG 42.750m)&#34;,
        },
        # FWCARGO2 (Mid) - Fr 38-43
        &#34;FWCARGO2.P&#34;: {
            &#34;x&#34;: x_fwcargo2,
            &#34;max_t&#34;: 148.36,
            &#34;SG&#34;: 1.000,
            &#34;note&#34;: &#34;Mid Cargo (LCG 35.250m)&#34;,
        },
        &#34;FWCARGO2.S&#34;: {
            &#34;x&#34;: x_fwcargo2,
            &#34;max_t&#34;: 148.36,
            &#34;SG&#34;: 1.000,
            &#34;note&#34;: &#34;Mid Cargo (LCG 35.250m)&#34;,
        },
    }</code></pre>
</details>
<div class="desc"><p>Forward fresh water ballast tanks (FWB1/2) - 757 TCP Tank Plan Verified LCGs.</p>
<p>Coordinate System (Python Script Internal):
- Midship (0.0) is at 30.151m from AP.
- FWD is NEGATIVE (-), AFT is POSITIVE (+).
- Formula: x_from_mid = Midship_LCG (30.151) - Tank_LCG_from_AP</p>
<p>Reference: tank.md (Tank Plan 757 TCP)
- FWB1 LCG: 57.519 m from AP
- FWB2 LCG: 50.038 m from AP</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.get_gm_bilinear"><code class="name flex">
<span>def <span class="ident">get_gm_bilinear</span></span>(<span>disp_t: float, trim_m: float, gm_grid: Dict[float, Dict[float, float]]) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gm_bilinear(disp_t: float, trim_m: float, gm_grid: GMGrid) -&gt; float:
    &#34;&#34;&#34;
    Δ(ton), Trim(m)에 대해 GM(m) 2D 보간 (bilinear).

    gm_grid 형식:
        {disp: {trim: GM, ...}, ...}
    &#34;&#34;&#34;
    if not gm_grid:
        raise ValueError(&#34;gm_grid is empty&#34;)

    disp_axis = sorted(gm_grid.keys())
    disp1, disp2 = _nearest_two(disp_axis, disp_t)

    trim_axis = sorted(next(iter(gm_grid.values())).keys())
    trim1, trim2 = _nearest_two(trim_axis, trim_m)

    # 경계선(한 방향 값만 존재)에서는 단순 선형 보간/직접 값 사용
    def gm_at(d: float, tr: float) -&gt; float:
        return gm_grid[d][tr]

    # 네 모서리 값
    q11 = gm_at(disp1, trim1)
    q21 = gm_at(disp2, trim1)
    q12 = gm_at(disp1, trim2)
    q22 = gm_at(disp2, trim2)

    # 축이 collapse 된 경우 처리
    if disp1 == disp2 and trim1 == trim2:
        return q11
    if disp1 == disp2:  # Trim 방향만 보간
        t = (trim_m - trim1) / (trim2 - trim1) if trim2 != trim1 else 0.0
        return q11 + t * (q12 - q11)
    if trim1 == trim2:  # Δ 방향만 보간
        t = (disp_t - disp1) / (disp2 - disp1) if disp2 != disp1 else 0.0
        return q11 + t * (q21 - q11)

    # Bilinear interpolation
    # 참조: 표준 bilinear 공식
    xd = (disp_t - disp1) / (disp2 - disp1)
    yd = (trim_m - trim1) / (trim2 - trim1)

    gm_interp = (
        q11 * (1 - xd) * (1 - yd)
        + q21 * xd * (1 - yd)
        + q12 * (1 - xd) * yd
        + q22 * xd * yd
    )
    return gm_interp</code></pre>
</details>
<div class="desc"><p>Δ(ton), Trim(m)에 대해 GM(m) 2D 보간 (bilinear).</p>
<p>gm_grid 형식:
{disp: {trim: GM, &hellip;}, &hellip;}</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.get_styles"><code class="name flex">
<span>def <span class="ident">get_styles</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_styles():
    &#34;&#34;&#34;공통 스타일 정의&#34;&#34;&#34;
    return {
        &#34;title_font&#34;: Font(name=&#34;Calibri&#34;, size=18, bold=True),
        &#34;header_font&#34;: Font(name=&#34;Calibri&#34;, size=11, bold=True, color=&#34;FFFFFF&#34;),
        &#34;normal_font&#34;: Font(name=&#34;Calibri&#34;, size=11),
        &#34;header_fill&#34;: PatternFill(&#34;solid&#34;, fgColor=&#34;1F4E78&#34;),
        &#34;input_fill&#34;: PatternFill(&#34;solid&#34;, fgColor=&#34;FFF2CC&#34;),
        &#34;ok_fill&#34;: PatternFill(&#34;solid&#34;, fgColor=&#34;C6E0B4&#34;),
        &#34;ng_fill&#34;: PatternFill(&#34;solid&#34;, fgColor=&#34;F8CBAD&#34;),
        &#34;structure_fill&#34;: PatternFill(
            &#34;solid&#34;, fgColor=&#34;C65911&#34;
        ),  # Orange for Structure
        &#34;opt1_fill&#34;: PatternFill(
            &#34;solid&#34;, fgColor=&#34;7030A0&#34;
        ),  # Purple for Option 1 (Ballast Fix)
        &#34;thin_border&#34;: Side(border_style=&#34;thin&#34;, color=&#34;C0C0C0&#34;),
        &#34;center_align&#34;: Alignment(
            horizontal=&#34;center&#34;, vertical=&#34;center&#34;, wrap_text=True
        ),
        &#34;left_align&#34;: Alignment(horizontal=&#34;left&#34;, vertical=&#34;center&#34;, wrap_text=True),
    }</code></pre>
</details>
<div class="desc"><p>공통 스타일 정의</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.gm_2d_bilinear"><code class="name flex">
<span>def <span class="ident">gm_2d_bilinear</span></span>(<span>disp_t: float, trim_m: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gm_2d_bilinear(disp_t: float, trim_m: float) -&gt; float:
    &#34;&#34;&#34;
    Bilinear interpolation on (disp, trim) → GM 2D grid.
    Uses LCT_BUSHRA_GM_2D_Grid.json with 7x7 grid (7 displacement × 7 trim values).

    Args:
        disp_t: Displacement (tons)
        trim_m: Trim in meters (bow down + / stern down - 등 프로젝트 convention에 맞게 사용)

    Returns:
        GM value (meters) or 1.50m fallback if data not available
    &#34;&#34;&#34;
    # 전역 변수 사용 (모듈 로드 시 초기화됨)
    global DISP_GRID, TRIM_GRID, GM_GRID

    # Fallback: Grid가 비어있으면 안전한 최소값 반환
    if not DISP_GRID or not TRIM_GRID or not GM_GRID:
        print(f&#34;[BACKUP] GM 2D Grid unavailable → using fallback GM=1.50m&#34;)
        return 1.50  # Safe minimum GM requirement

    try:
        ds = DISP_GRID
        ts = TRIM_GRID
        g = GM_GRID

        # --- 1) disp index 찾기 (clamp + 양구간 인덱스) ---
        if disp_t &lt;= ds[0]:
            i0 = i1 = 0
        elif disp_t &gt;= ds[-1]:
            i0 = i1 = len(ds) - 1
        else:
            k = bisect_left(ds, disp_t) - 1
            if k &lt; 0:
                k = 0
            i0, i1 = k, k + 1

        # --- 2) trim index 찾기 (clamp + 양구간 인덱스) ---
        if trim_m &lt;= ts[0]:
            j0 = j1 = 0
        elif trim_m &gt;= ts[-1]:
            j0 = j1 = len(ts) - 1
        else:
            k = bisect_left(ts, trim_m) - 1
            if k &lt; 0:
                k = 0
            j0, j1 = k, k + 1

        d0, d1 = ds[i0], ds[i1]
        t0, t1 = ts[j0], ts[j1]

        # --- 3) 보간 비율 (0~1) ---
        if d1 != d0:
            td = (disp_t - d0) / (d1 - d0)
        else:
            td = 0.0

        if t1 != t0:
            tt = (trim_m - t0) / (t1 - t0)
        else:
            tt = 0.0

        # --- 4) 모서리 GM 값 ---
        g00 = g[i0][j0]  # (d0, t0)
        g10 = g[i1][j0]  # (d1, t0)
        g01 = g[i0][j1]  # (d0, t1)
        g11 = g[i1][j1]  # (d1, t1)

        # --- 5) bilinear interpolation ---
        gm = (
            (1 - td) * (1 - tt) * g00
            + td * (1 - tt) * g10
            + (1 - td) * tt * g01
            + td * tt * g11
        )

        # Sanity check for unrealistic GM values
        if gm &lt; 0 or gm &gt; 5.0:
            print(f&#34;[BACKUP] GM={gm:.2f}m unrealistic → fallback GM=1.50m&#34;)
            return 1.50

        return float(gm)
    except Exception as e:
        print(f&#34;[BACKUP] GM calculation error: {e} → fallback GM=1.50m&#34;)
        return 1.50</code></pre>
</details>
<div class="desc"><p>Bilinear interpolation on (disp, trim) → GM 2D grid.
Uses LCT_BUSHRA_GM_2D_Grid.json with 7x7 grid (7 displacement × 7 trim values).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>disp_t</code></strong></dt>
<dd>Displacement (tons)</dd>
<dt><strong><code>trim_m</code></strong></dt>
<dd>Trim in meters (bow down + / stern down - 등 프로젝트 convention에 맞게 사용)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>GM value (meters) or 1.50m fallback if data not available</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.gm_min_from_curve"><code class="name flex">
<span>def <span class="ident">gm_min_from_curve</span></span>(<span>disp_t: float, tmean_m: float, gm_curve: list[dict] | None) ‑> tuple[float | None, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gm_min_from_curve(
    disp_t: float, tmean_m: float, gm_curve: list[dict] | None
) -&gt; tuple[float | None, str]:
    &#34;&#34;&#34;
    Return (gm_min_m, basis).
    Priority:
      1) gm_curve param (if provided)
      2) auto-loaded GM min curve json
      3) None
    &#34;&#34;&#34;
    curve = (
        gm_curve
        if (isinstance(gm_curve, list) and len(gm_curve) &gt; 0)
        else _load_gm_min_curve()
    )
    if not curve:
        return None, &#34;none&#34;

    keys = list(curve[0].keys())
    k_gm = _detect_key(keys, [&#34;GM_min_m&#34;, &#34;GMmin_m&#34;, &#34;GM_MIN_m&#34;, &#34;MinGM_m&#34;])
    if not k_gm:
        return None, &#34;invalid_curve&#34;

    # choose axis
    k_tmean = _detect_key(keys, [&#34;Tmean_m&#34;, &#34;Tmean&#34;, &#34;MeanDraft_m&#34;, &#34;DraftMean_m&#34;])
    k_disp = _detect_key(keys, [&#34;Disp_t&#34;, &#34;Displacement_t&#34;, &#34;disp&#34;])
    if k_tmean:
        xs, ys = [], []
        for r in curve:
            x = _as_float(r.get(k_tmean))
            y = _as_float(r.get(k_gm))
            if x is None or y is None:
                continue
            xs.append(float(x))
            ys.append(float(y))
        if len(xs) &lt; 2:
            return None, &#34;curve_insufficient&#34;
        pairs = sorted(zip(xs, ys), key=lambda t: t[0])
        xs = [p[0] for p in pairs]
        ys = [p[1] for p in pairs]
        return float(_linear_interp(xs, ys, float(tmean_m))), &#34;curve:Tmean_m&#34;
    elif k_disp:
        xs, ys = [], []
        for r in curve:
            x = _as_float(r.get(k_disp))
            y = _as_float(r.get(k_gm))
            if x is None or y is None:
                continue
            xs.append(float(x))
            ys.append(float(y))
        if len(xs) &lt; 2:
            return None, &#34;curve_insufficient&#34;
        pairs = sorted(zip(xs, ys), key=lambda t: t[0])
        xs = [p[0] for p in pairs]
        ys = [p[1] for p in pairs]
        return float(_linear_interp(xs, ys, float(disp_t))), &#34;curve:Disp_t&#34;
    else:
        return None, &#34;invalid_curve_axis&#34;</code></pre>
</details>
<div class="desc"><p>Return (gm_min_m, basis).</p>
<h2 id="priority">Priority</h2>
<p>1) gm_curve param (if provided)
2) auto-loaded GM min curve json
3) None</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.heel_and_gm_check"><code class="name flex">
<span>def <span class="ident">heel_and_gm_check</span></span>(<span>weight_t: float,<br>y_offset_m: float,<br>disp_t: float,<br>gm_m: float,<br>fse_t_m: float,<br>heel_limit_deg: float = 3.0,<br>gm_min_m: float = 1.5) ‑> tuple[float, float, bool, bool]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heel_and_gm_check(
    weight_t: float,
    y_offset_m: float,
    disp_t: float,
    gm_m: float,
    fse_t_m: float,
    heel_limit_deg: float = 3.0,
    gm_min_m: float = 1.50,
) -&gt; tuple[float, float, bool, bool]:
    &#34;&#34;&#34;
    Heel 각도 + GM_eff 계산 및 체크 결과.

    Returns
    -------
    heel_deg  : 계산된 heel (deg)
    gm_eff    : FSE 반영 후 GM (m)
    heel_ok   : |heel| ≤ heel_limit_deg 여부
    gm_ok     : gm_eff ≥ gm_min_m 여부
    &#34;&#34;&#34;
    heel_deg = calc_heel_from_offset(weight_t, y_offset_m, disp_t, gm_m)
    gm_eff = calc_gm_effective(disp_t, gm_m, fse_t_m)

    heel_ok = abs(heel_deg) &lt;= heel_limit_deg
    gm_ok = gm_eff &gt;= gm_min_m

    return heel_deg, gm_eff, heel_ok, gm_ok</code></pre>
</details>
<div class="desc"><p>Heel 각도 + GM_eff 계산 및 체크 결과.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>heel_deg
: 계산된 heel (deg)</code></dt>
<dd>&nbsp;</dd>
<dt><code>gm_eff
: FSE 반영 후 GM (m)</code></dt>
<dd>&nbsp;</dd>
<dt><code>heel_ok
: |heel| ≤ heel_limit_deg 여부</code></dt>
<dd>&nbsp;</dd>
<dt><code>gm_ok
: gm_eff ≥ gm_min_m 여부</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.interpolate_hydro_by_tmean"><code class="name flex">
<span>def <span class="ident">interpolate_hydro_by_tmean</span></span>(<span>tmean_m: float, hydro_table: list[dict]) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_hydro_by_tmean(tmean_m: float, hydro_table: list[dict]) -&gt; dict:
    &#34;&#34;&#34;
    Interpolate hydrostatic fields by mean draft (Tmean_m).

    Expected (preferred) columns in hydro_table rows:
      - Tmean_m
      - LCF_m_from_midship   (x_from_mid_m, aft+)
      - MCTC_t_m_per_cm      (or MTC_t_m_per_cm)
      - TPC_t_per_cm
      - GM_min_m             (optional; minimum GM curve point)

    Returns:
      dict with any available interpolated fields (missing fields omitted).
    &#34;&#34;&#34;
    if not hydro_table:
        return {}

    row0 = hydro_table[0]
    keys = list(row0.keys())

    k_tmean = _detect_key(keys, [&#34;Tmean_m&#34;, &#34;Tmean&#34;, &#34;MeanDraft_m&#34;, &#34;DraftMean_m&#34;])
    if not k_tmean:
        return {}

    # candidate keys (synonyms supported)
    k_lcf = _detect_key(keys, [&#34;LCF_m_from_midship&#34;, &#34;LCF_from_mid_m&#34;, &#34;LCF_m&#34;, &#34;LCF&#34;])
    k_mctc = _detect_key(keys, [&#34;MCTC_t_m_per_cm&#34;, &#34;MTC_t_m_per_cm&#34;, &#34;MCTC&#34;, &#34;MTC&#34;])
    k_tpc = _detect_key(keys, [&#34;TPC_t_per_cm&#34;, &#34;TPC&#34;, &#34;TPC_t_cm&#34;, &#34;TPC_t_per_cm&#34;])
    k_gmmin = _detect_key(keys, [&#34;GM_min_m&#34;, &#34;GMmin_m&#34;, &#34;GM_MIN_m&#34;, &#34;MinGM_m&#34;])

    # build x axis
    xs = []
    rows_valid = []
    for r in hydro_table:
        xm = _as_float(r.get(k_tmean))
        if xm is None:
            continue
        xs.append(float(xm))
        rows_valid.append(r)

    if not xs:
        return {}

    # sort by tmean
    pairs = sorted(zip(xs, rows_valid), key=lambda t: t[0])
    xs = [p[0] for p in pairs]
    rows_valid = [p[1] for p in pairs]

    out = {&#34;Tmean_m&#34;: float(tmean_m)}

    def interp_field(k):
        ys = []
        x_ok = []
        for x, r in zip(xs, rows_valid):
            y = _as_float(r.get(k))
            if y is None:
                continue
            x_ok.append(x)
            ys.append(float(y))
        if len(x_ok) &lt; 2:
            return None
        # ensure sorted
        pairs2 = sorted(zip(x_ok, ys), key=lambda t: t[0])
        x_ok = [p[0] for p in pairs2]
        ys = [p[1] for p in pairs2]
        return float(_linear_interp(x_ok, ys, float(tmean_m)))

    if k_lcf:
        v = interp_field(k_lcf)
        if v is not None:
            out[&#34;LCF_m_from_midship&#34;] = v

    if k_mctc:
        v = interp_field(k_mctc)
        if v is not None:
            out[&#34;MCTC_t_m_per_cm&#34;] = v

    if k_tpc:
        v = interp_field(k_tpc)
        if v is not None:
            out[&#34;TPC_t_per_cm&#34;] = v

    if k_gmmin:
        v = interp_field(k_gmmin)
        if v is not None:
            out[&#34;GM_min_m&#34;] = v

    return out</code></pre>
</details>
<div class="desc"><p>Interpolate hydrostatic fields by mean draft (Tmean_m).</p>
<p>Expected (preferred) columns in hydro_table rows:
- Tmean_m
- LCF_m_from_midship
(x_from_mid_m, aft+)
- MCTC_t_m_per_cm
(or MTC_t_m_per_cm)
- TPC_t_per_cm
- GM_min_m
(optional; minimum GM curve point)</p>
<h2 id="returns">Returns</h2>
<p>dict with any available interpolated fields (missing fields omitted).</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.interpolate_tmean_from_disp"><code class="name flex">
<span>def <span class="ident">interpolate_tmean_from_disp</span></span>(<span>disp_t: float, hydro_table: list[dict]) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_tmean_from_disp(disp_t: float, hydro_table: list[dict]) -&gt; float:
    &#34;&#34;&#34;
    Δdisp → Tmean 보간

    Args:
        disp_t: 배수량 (ton)
        hydro_table: Hydro table 데이터 (list of dict)
            각 dict는 &#34;Displacement_t&#34; 또는 &#34;Disp_t&#34;와 &#34;Tmean_m&#34; 키를 가져야 함

    Returns:
        Tmean (m) - 선형 보간된 평균 흘수
    &#34;&#34;&#34;
    if not hydro_table or len(hydro_table) == 0:
        print(&#34;[WARNING] Hydro table is empty → using fallback Tmean=2.00m&#34;)
        return 2.00  # Fallback

    try:
        # 키 이름 확인 (다양한 형식 지원)
        disp_key = None
        tmean_key = None

        for key in hydro_table[0].keys():
            if &#34;disp&#34; in key.lower() or &#34;displacement&#34; in key.lower():
                disp_key = key
            if &#34;tmean&#34; in key.lower() or &#34;mean&#34; in key.lower():
                tmean_key = key

        if not disp_key or not tmean_key:
            print(
                &#34;[WARNING] Hydro table format not recognized → using fallback Tmean=2.00m&#34;
            )
            return 2.00

        # Displacement 및 Tmean 배열 추출
        disps = [float(row[disp_key]) for row in hydro_table]
        tmeans = [float(row[tmean_key]) for row in hydro_table]

        # 정렬 확인 (필요시 정렬)
        if disps != sorted(disps):
            # 정렬 필요
            sorted_pairs = sorted(zip(disps, tmeans))
            disps, tmeans = zip(*sorted_pairs)
            disps = list(disps)
            tmeans = list(tmeans)

        # Clamp 및 보간
        if disp_t &lt;= disps[0]:
            return tmeans[0]
        elif disp_t &gt;= disps[-1]:
            return tmeans[-1]

        # 선형 보간
        i = bisect_left(disps, disp_t)
        if i &lt;= 0:
            return tmeans[0]
        elif i &gt;= len(disps):
            return tmeans[-1]

        x0, x1 = disps[i - 1], disps[i]
        y0, y1 = tmeans[i - 1], tmeans[i]

        if x1 == x0:
            return y0

        tmean = y0 + (y1 - y0) * (disp_t - x0) / (x1 - x0)
        return float(tmean)
    except Exception as e:
        print(f&#34;[WARNING] Tmean interpolation error: {e} → using fallback Tmean=2.00m&#34;)
        return 2.00</code></pre>
</details>
<div class="desc"><p>Δdisp → Tmean 보간</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>disp_t</code></strong></dt>
<dd>배수량 (ton)</dd>
<dt><strong><code>hydro_table</code></strong></dt>
<dd>Hydro table 데이터 (list of dict)
각 dict는 "Displacement_t" 또는 "Disp_t"와 "Tmean_m" 키를 가져야 함</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tmean (m) - 선형 보간된 평균 흘수</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.iscode_general_check"><code class="name flex">
<span>def <span class="ident">iscode_general_check</span></span>(<span>stage_id: str, gm0_m: float | None = None) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iscode_general_check(stage_id: str, gm0_m: float | None = None) -&gt; dict:
    &#34;&#34;&#34;
    IS Code general criteria check based on a provided GZ curve.
    Returns a dict with {available, pass, metrics..., checks..., basis, missing}.
    &#34;&#34;&#34;
    criteria = _load_iscode_criteria()
    pts_raw, basis = _load_gz_curve(stage_id)
    pts = _normalize_gz_points(pts_raw)

    if len(pts) &lt; 3:
        return {
            &#34;available&#34;: False,
            &#34;pass&#34;: False,
            &#34;basis&#34;: basis,
            &#34;missing&#34;: &#34;GZ curve points (provide data/GZ/&lt;stage&gt;.json or data/GZ_Curves.json)&#34;,
        }

    # metrics
    try:
        area_0_30 = _integrate_gz_area_mrad(pts, 0.0, 30.0)
        area_0_40 = _integrate_gz_area_mrad(pts, 0.0, 40.0)
        area_30_40 = _integrate_gz_area_mrad(pts, 30.0, 40.0)
    except Exception as e:
        return {
            &#34;available&#34;: False,
            &#34;pass&#34;: False,
            &#34;basis&#34;: basis,
            &#34;missing&#34;: f&#34;GZ integration failed: {e}&#34;,
        }

    # max GZ
    gz_max = max(pts, key=lambda t: t[1])
    gz_max_angle = float(gz_max[0])
    gz_max_m = float(gz_max[1])

    # range of positive stability (last angle where gz&gt;0)
    positive = [a for a, g in pts if g &gt; 0.0]
    stable_range = float(max(positive)) if positive else 0.0

    # checks (only if criteria keys exist)
    checks = {}

    def _chk(key: str, ok: bool, val: float, limit: float):
        checks[key] = {&#34;ok&#34;: bool(ok), &#34;value&#34;: float(val), &#34;limit&#34;: float(limit)}

    # areas
    if &#34;area_0_30_mrad_min&#34; in criteria:
        lim = float(criteria[&#34;area_0_30_mrad_min&#34;])
        _chk(&#34;A0_30&#34;, area_0_30 &gt;= lim, area_0_30, lim)
    if &#34;area_0_40_mrad_min&#34; in criteria:
        lim = float(criteria[&#34;area_0_40_mrad_min&#34;])
        _chk(&#34;A0_40&#34;, area_0_40 &gt;= lim, area_0_40, lim)
    if &#34;area_30_40_mrad_min&#34; in criteria:
        lim = float(criteria[&#34;area_30_40_mrad_min&#34;])
        _chk(&#34;A30_40&#34;, area_30_40 &gt;= lim, area_30_40, lim)

    # GZmax
    if &#34;gz_max_m_min&#34; in criteria:
        lim = float(criteria[&#34;gz_max_m_min&#34;])
        _chk(&#34;GZmax&#34;, gz_max_m &gt;= lim, gz_max_m, lim)

    # angle range
    if &#34;gz_max_angle_deg_min&#34; in criteria:
        lim = float(criteria[&#34;gz_max_angle_deg_min&#34;])
        _chk(&#34;Ang_GZmax_min&#34;, gz_max_angle &gt;= lim, gz_max_angle, lim)
    if &#34;gz_max_angle_deg_max&#34; in criteria:
        lim = float(criteria[&#34;gz_max_angle_deg_max&#34;])
        _chk(&#34;Ang_GZmax_max&#34;, gz_max_angle &lt;= lim, gz_max_angle, lim)

    # GM0 (if provided)
    if &#34;gm0_min_m&#34; in criteria and gm0_m is not None:
        lim = float(criteria[&#34;gm0_min_m&#34;])
        _chk(&#34;GM0&#34;, float(gm0_m) &gt;= lim, float(gm0_m), lim)

    # overall pass
    overall = all(v[&#34;ok&#34;] for v in checks.values()) if checks else False

    return {
        &#34;available&#34;: True,
        &#34;pass&#34;: bool(overall),
        &#34;basis&#34;: basis,
        &#34;area_0_30_mrad&#34;: float(area_0_30),
        &#34;area_0_40_mrad&#34;: float(area_0_40),
        &#34;area_30_40_mrad&#34;: float(area_30_40),
        &#34;gz_max_m&#34;: float(gz_max_m),
        &#34;gz_max_angle_deg&#34;: float(gz_max_angle),
        &#34;stable_range_deg&#34;: float(stable_range),
        &#34;checks&#34;: checks,
        &#34;criteria&#34;: criteria,
    }</code></pre>
</details>
<div class="desc"><p>IS Code general criteria check based on a provided GZ curve.
Returns a dict with {available, pass, metrics&hellip;, checks&hellip;, basis, missing}.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.iterative_ballast_correction"><code class="name flex">
<span>def <span class="ident">iterative_ballast_correction</span></span>(<span>base_disp_t: float,<br>base_tmean_m: float,<br>loads: List[Any],<br>initial_ballast_t: float,<br>fwd_limit_m: float = 2.7,<br>max_iterations: int = 3,<br>tolerance_m: float = 0.01,<br>d_vessel_m: float = 3.65,<br>freeboard_min_m: float = 0.28,<br>**params) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterative_ballast_correction(
    base_disp_t: float,
    base_tmean_m: float,
    loads: List[Any],
    initial_ballast_t: float,
    fwd_limit_m: float = 2.70,
    max_iterations: int = 3,
    tolerance_m: float = 0.01,
    d_vessel_m: float = 3.65,
    freeboard_min_m: float = 0.28,
    **params,
) -&gt; dict:
    &#34;&#34;&#34;
    PATCH C: Iterative ballast correction using Secant method to achieve target Dfwd.

    Algorithm:
    1. Start with initial ballast estimate (from B2 calculation)
    2. Apply ballast and recalculate Dfwd using solve_stage()
    3. Use Secant method to iteratively adjust ballast until Dfwd ≈ fwd_limit_m
    4. Maximum 1-3 iterations for practical convergence

    Args:
        base_disp_t: Base displacement (t)
        base_tmean_m: Base mean draft (m)
        loads: List of LoadItem objects
        initial_ballast_t: Initial ballast estimate (t) from B2 calculation
        fwd_limit_m: Target forward draft limit (m), default 2.70
        max_iterations: Maximum iterations, default 3
        tolerance_m: Convergence tolerance (m), default 0.01 (1cm)
        d_vessel_m: Vessel molded depth (m) for freeboard check
        freeboard_min_m: Minimum freeboard (m) required
        **params: Additional parameters for solve_stage()

    Returns:
        dict with keys:
            - ballast_t: Final ballast tonnage (t)
            - dfwd_gate_m: Final forward draft (m)
            - iterations: Number of iterations used
            - converged: Whether convergence was achieved
            - flag: &#34;OK&#34; if Dfwd &lt;= fwd_limit_m and freeboard OK, &#34;LIMIT&#34; otherwise
            - freeboard_ok: True if freeboard constraint met
            - freeboard_min_m: Minimum freeboard achieved (m)
    &#34;&#34;&#34;
    from copy import deepcopy

    # Initial ballast estimates (Secant method needs 2 points)
    b0 = float(initial_ballast_t or 0.0)
    # Secant 2점 보장 (b0==0 정체 방지)
    delta = max(5.0, abs(b0) * 0.10)
    sign = 1.0 if b0 &gt;= 0 else -1.0
    b1 = b0 + sign * delta

    # Get ballast position from params (FW2, Fr 0-6, AFT)
    fr_pb = params.get(&#34;FR_PREBALLAST&#34;, params.get(&#34;FR_PB&#34;, 3.0))
    ballast_x = fr_to_x(fr_pb)  # Convert frame to x position (m from midship)

    # Evaluate Dfwd for initial points
    def eval_dfwd(ballast_t: float) -&gt; tuple[float, float, bool]:
        &#34;&#34;&#34;Evaluate drafts and freeboard for given ballast tonnage.

        PATCH C: Properly applies ballast as LoadItem and recalculates using solve_stage().
        The solve_stage() function will:
        1. Calculate total displacement = base_disp_t + sum(loads)
        2. Interpolate Tmean from displacement
        3. Calculate trim and drafts
        &#34;&#34;&#34;
        # Create modified loads with ballast applied
        modified_loads = deepcopy(loads)

        # Remove existing PreBallast LoadItem if present (to replace with new value)
        modified_loads = [load for load in modified_loads if load.name != &#34;PreBallast&#34;]

        # Add ballast as LoadItem (ballast_t can be negative for de-ballast)
        if abs(ballast_t) &gt; 0.01:  # Only add if significant
            modified_loads.append(
                LoadItem(&#34;PreBallast&#34;, ballast_t, ballast_x, &#34;BALLAST&#34;)
            )

        # Solve stage with modified loads - solve_stage will calculate:
        # - Total displacement = base_disp_t + sum(modified_loads)
        # - Tmean from displacement interpolation
        # - Trim and drafts
        res = solve_stage(base_disp_t, base_tmean_m, modified_loads, **params)
        fwd_draft = res.get(&#34;Dfwd_m&#34;, fwd_limit_m)
        aft_draft = res.get(&#34;Daft_m&#34;, 0.0)
        fb_fwd = d_vessel_m - fwd_draft
        fb_aft = d_vessel_m - aft_draft
        fb_min = min(fb_fwd, fb_aft)
        freeboard_ok = fb_min &gt;= freeboard_min_m
        return fwd_draft, aft_draft, freeboard_ok

    def penalize_dfwd(dfwd: float, freeboard_ok: bool) -&gt; float:
        return dfwd if freeboard_ok else dfwd + 10.0

    dfwd0, daft0, fb_ok0 = eval_dfwd(b0)
    dfwd1, daft1, fb_ok1 = eval_dfwd(b1)
    dfwd0_p = penalize_dfwd(dfwd0, fb_ok0)
    dfwd1_p = penalize_dfwd(dfwd1, fb_ok1)

    # Target: Dfwd = fwd_limit_m
    target = fwd_limit_m
    error0 = dfwd0_p - target
    error1 = dfwd1_p - target

    iterations = 0
    converged = False
    final_ballast = b0
    final_dfwd = dfwd0
    final_daft = daft0
    final_fb_ok = fb_ok0

    # Secant method iteration
    for i in range(max_iterations):
        iterations = i + 1

        # Check convergence
        if abs(error0) &lt;= tolerance_m:
            converged = True
            final_ballast = b0
            final_dfwd = dfwd0
            final_daft = daft0
            final_fb_ok = fb_ok0
            break

        # Secant method: b_new = b0 - error0 * (b1 - b0) / (error1 - error0)
        if abs(error1 - error0) &lt; 1e-6:  # Avoid division by zero
            # Use bisection if secant fails
            b_new = (b0 + b1) / 2.0
        else:
            b_new = b0 - error0 * (b1 - b0) / (error1 - error0)

        # Clamp ballast to reasonable range to prevent divergence
        max_ballast_t = float(params.get(&#34;max_aft_ballast_cap_t&#34;, params.get(&#34;MAX_TANK_CAPACITY_T&#34;, 400.0)) or 400.0)
        min_ballast_t = -max_ballast_t  # Allow de-ballast up to same limit
        b_new = max(min_ballast_t, min(max_ballast_t, b_new))

        # Prevent excessive jumps (limit step size to 50% of range)
        max_step = max_ballast_t * 0.5
        if abs(b_new - b0) &gt; max_step:
            b_new = b0 + max_step if b_new &gt; b0 else b0 - max_step

        # Evaluate new point
        dfwd_new, daft_new, fb_ok_new = eval_dfwd(b_new)
        dfwd_new_p = penalize_dfwd(dfwd_new, fb_ok_new)
        error_new = dfwd_new_p - target

        # Update for next iteration
        b0, dfwd0, daft0, fb_ok0, error0 = (
            b1,
            dfwd1,
            daft1,
            fb_ok1,
            error1,
        )
        b1, dfwd1, daft1, fb_ok1, error1 = (
            b_new,
            dfwd_new,
            daft_new,
            fb_ok_new,
            error_new,
        )

        final_ballast = b_new
        final_dfwd = dfwd_new
        final_daft = daft_new
        final_fb_ok = fb_ok_new

    # Determine flag
    final_fb_min = min(d_vessel_m - final_dfwd, d_vessel_m - final_daft)
    final_fb_ok = final_fb_min &gt;= freeboard_min_m

    # Validate final results - if abnormal, use initial values
    max_ballast_t = float(params.get(&#34;max_aft_ballast_cap_t&#34;, params.get(&#34;MAX_TANK_CAPACITY_T&#34;, 400.0)) or 400.0)
    if abs(final_ballast) &gt; max_ballast_t * 1.5 or final_dfwd &lt; 0 or final_dfwd &gt; 10 or final_daft &lt; 0 or final_daft &gt; 10:
        # Abnormal result - use initial values as fallback
        final_ballast = float(initial_ballast_t or 0.0)
        final_dfwd, final_daft, final_fb_ok = eval_dfwd(final_ballast)
        final_fb_min = min(d_vessel_m - final_dfwd, d_vessel_m - final_daft)
        final_fb_ok = final_fb_min &gt;= freeboard_min_m
        converged = False
        iterations = 0

    flag = (
        &#34;OK&#34; if final_dfwd &lt;= fwd_limit_m and final_fb_ok else &#34;LIMIT&#34;
    )

    # PATCH C-Enhanced: Add operational columns (PATCH1111.MD)
    # Calculate ballast per side for operational planning
    ballast_per_side = abs(final_ballast) / 2.0

    # Generate ballast allocation string (tank-based allocation)
    # For now, assume simple FW2.P/FW2.S split, can be enhanced with tank catalog
    if abs(final_ballast) &gt; 0.01:
        if final_ballast &gt; 0:
            ballast_alloc = (
                f&#34;FW2.P: {ballast_per_side:.1f}t, FW2.S: {ballast_per_side:.1f}t (Fill)&#34;
            )
        else:
            ballast_alloc = f&#34;FW2.P: {ballast_per_side:.1f}t, FW2.S: {ballast_per_side:.1f}t (Empty)&#34;
    else:
        ballast_alloc = &#34;None&#34;

    # Estimate pump time (assume 50 t/h pump rate, can be configured)
    pump_rate_t_h = float(
        params.get(&#34;PUMP_RATE_T_H&#34;)
        or params.get(&#34;pump_rate_effective_tph&#34;)
        or params.get(&#34;pump_rate_tph&#34;)
        or 10.0
    )
    pump_time_h = abs(final_ballast) / pump_rate_t_h if pump_rate_t_h &gt; 0 else 0.0

    # Lineup check (simple: OK if ballast &lt; 100t, can be enhanced with tank capacity)
    max_tank_capacity = float(
        params.get(&#34;MAX_TANK_CAPACITY_T&#34;)
        or params.get(&#34;max_aft_ballast_cap_t&#34;)
        or 100.0
    )
    lineup_ok = (
        &#34;Yes&#34; if ballast_per_side &lt;= max_tank_capacity else &#34;No (Exceeds capacity)&#34;
    )

    return {
        &#34;ballast_t&#34;: final_ballast,
        &#34;dfwd_gate_m&#34;: final_dfwd,
        &#34;iterations&#34;: iterations,
        &#34;converged&#34;: converged,
        &#34;flag&#34;: flag,
        &#34;freeboard_ok&#34;: final_fb_ok,
        &#34;freeboard_min_m&#34;: final_fb_min,
        # PATCH C-Enhanced: Operational columns
        &#34;ballast_alloc&#34;: ballast_alloc,
        &#34;pump_time_h&#34;: round(pump_time_h, 2),
        &#34;lineup_ok&#34;: lineup_ok,
    }</code></pre>
</details>
<div class="desc"><p>PATCH C: Iterative ballast correction using Secant method to achieve target Dfwd.</p>
<p>Algorithm:
1. Start with initial ballast estimate (from B2 calculation)
2. Apply ballast and recalculate Dfwd using solve_stage()
3. Use Secant method to iteratively adjust ballast until Dfwd ≈ fwd_limit_m
4. Maximum 1-3 iterations for practical convergence</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_disp_t</code></strong></dt>
<dd>Base displacement (t)</dd>
<dt><strong><code>base_tmean_m</code></strong></dt>
<dd>Base mean draft (m)</dd>
<dt><strong><code>loads</code></strong></dt>
<dd>List of LoadItem objects</dd>
<dt><strong><code>initial_ballast_t</code></strong></dt>
<dd>Initial ballast estimate (t) from B2 calculation</dd>
<dt><strong><code>fwd_limit_m</code></strong></dt>
<dd>Target forward draft limit (m), default 2.70</dd>
<dt><strong><code>max_iterations</code></strong></dt>
<dd>Maximum iterations, default 3</dd>
<dt><strong><code>tolerance_m</code></strong></dt>
<dd>Convergence tolerance (m), default 0.01 (1cm)</dd>
<dt><strong><code>d_vessel_m</code></strong></dt>
<dd>Vessel molded depth (m) for freeboard check</dd>
<dt><strong><code>freeboard_min_m</code></strong></dt>
<dd>Minimum freeboard (m) required</dd>
<dt><strong><code>**params</code></strong></dt>
<dd>Additional parameters for solve_stage()</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dict with keys:
- ballast_t: Final ballast tonnage (t)
- dfwd_gate_m: Final forward draft (m)
- iterations: Number of iterations used
- converged: Whether convergence was achieved
- flag: "OK" if Dfwd &lt;= fwd_limit_m and freeboard OK, "LIMIT" otherwise
- freeboard_ok: True if freeboard constraint met
- freeboard_min_m: Minimum freeboard achieved (m)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.load_const_tanks_snapshot"><code class="name flex">
<span>def <span class="ident">load_const_tanks_snapshot</span></span>(<span>const_csv_path: str = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_const_tanks_snapshot(const_csv_path: str = None):
    &#34;&#34;&#34;
    CSV에서 실측 Const Tank 데이터 로딩 (Option B-2)

    지원 컬럼 (대소문자/공백 무시):
      - tank/tank_id: 탱크 이름
      - weight/weight_t: 실측 중량 (t)
      - fsm/fsm_mt_m: 실측 FSM (t·m)
      - lcg/lcg_m: LCG (m from AP) - 선택 사항

    CSV가 없거나 파싱 실패 시 기본값(하드코딩 값 사용) 반환

    Args:
        const_csv_path: CSV 파일 경로 (None이면 기본 하드코딩 값 사용)

    Returns:
        tuple: (rows, meta)
            - rows: 탱크 데이터 리스트 (dict)
            - meta: 로딩 메타데이터 (dict)

    Examples:
        &gt;&gt;&gt; rows, meta = load_const_tanks_snapshot()
        &gt;&gt;&gt; len(rows)
        8
        &gt;&gt;&gt; rows[0][&#39;tank&#39;]
        &#39;DO.P&#39;
    &#34;&#34;&#34;
    # 기본 하드코딩 데이터로 초기화 (CONST_TANK_SPECS 기반)
    rows = []
    for t, ty, mw, lcg, fsmx in CONST_TANK_SPECS:
        rows.append(
            {
                &#34;tank&#34;: t,
                &#34;type&#34;: ty,
                &#34;weight_t&#34;: mw,  # 기본값: 최대 용량 사용 (실측값 없을 경우)
                &#34;lcg_m&#34;: lcg,
                &#34;fsm_mt_m&#34;: fsmx,  # 기본값: 최대 FSM 사용
                &#34;max_weight_t&#34;: mw,
                &#34;fsm_max_mt_m&#34;: fsmx,
                &#34;src&#34;: &#34;default&#34;,
            }
        )

    meta = {&#34;used_csv&#34;: False, &#34;const_csv_path&#34;: const_csv_path}

    # CSV 파일이 없으면 기본값 반환
    if not const_csv_path or not os.path.exists(const_csv_path):
        if const_csv_path:
            print(f&#34;[INFO] CSV file not found: {const_csv_path}, using default values&#34;)
        return rows, meta

    # CSV 파일 로딩 시도
    try:
        import csv

        print(f&#34;[INFO] Loading CONST_TANKS data from CSV: {const_csv_path}&#34;)

        with open(const_csv_path, &#34;r&#34;, encoding=&#34;utf-8-sig&#34;) as f:
            reader = csv.DictReader(f)
            # 탱크명을 키로 하는 딕셔너리 생성 (정규화된 키 사용)
            csv_data = {}
            for row in reader:
                tank_name = row.get(&#34;tank&#34;, row.get(&#34;tank_id&#34;, &#34;&#34;))
                if tank_name:
                    csv_data[normalize_key(tank_name)] = row

        # CSV 데이터로 기본값 업데이트
        matched = 0
        for row in rows:
            tank_key = normalize_key(row[&#34;tank&#34;])
            if tank_key in csv_data:
                csv_row = csv_data[tank_key]

                # weight_t 업데이트
                weight_str = csv_row.get(&#34;weight&#34;, csv_row.get(&#34;weight_t&#34;, &#34;&#34;))
                if weight_str:
                    try:
                        row[&#34;weight_t&#34;] = float(weight_str)
                    except (ValueError, TypeError):
                        print(
                            f&#34;[WARNING] Invalid weight for {row[&#39;tank&#39;]}: {weight_str}&#34;
                        )

                # fsm_mt_m 업데이트
                fsm_str = csv_row.get(&#34;fsm&#34;, csv_row.get(&#34;fsm_mt_m&#34;, &#34;&#34;))
                if fsm_str:
                    try:
                        row[&#34;fsm_mt_m&#34;] = float(fsm_str)
                    except (ValueError, TypeError):
                        print(f&#34;[WARNING] Invalid FSM for {row[&#39;tank&#39;]}: {fsm_str}&#34;)

                # lcg_m 업데이트 (선택 사항)
                lcg_str = csv_row.get(&#34;lcg&#34;, csv_row.get(&#34;lcg_m&#34;, &#34;&#34;))
                if lcg_str:
                    try:
                        row[&#34;lcg_m&#34;] = float(lcg_str)
                    except (ValueError, TypeError):
                        pass  # LCG는 선택 사항이므로 경고 출력 안 함

                row[&#34;src&#34;] = &#34;csv&#34;
                matched += 1

        meta[&#34;used_csv&#34;] = True
        meta[&#34;matched_count&#34;] = matched
        meta[&#34;total_tanks&#34;] = len(rows)
        print(f&#34;[INFO] CSV loaded successfully: {matched}/{len(rows)} tanks matched&#34;)

        if matched &lt; len(rows):
            print(
                f&#34;[WARNING] {len(rows) - matched} tanks not found in CSV, using default values&#34;
            )

    except Exception as e:
        print(f&#34;[WARNING] CSV loading failed: {e}&#34;)
        print(f&#34;[INFO] Using default hardcoded values for all tanks&#34;)
        meta[&#34;error&#34;] = str(e)

    return rows, meta</code></pre>
</details>
<div class="desc"><p>CSV에서 실측 Const Tank 데이터 로딩 (Option B-2)</p>
<p>지원 컬럼 (대소문자/공백 무시):
- tank/tank_id: 탱크 이름
- weight/weight_t: 실측 중량 (t)
- fsm/fsm_mt_m: 실측 FSM (t·m)
- lcg/lcg_m: LCG (m from AP) - 선택 사항</p>
<p>CSV가 없거나 파싱 실패 시 기본값(하드코딩 값 사용) 반환</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>const_csv_path</code></strong></dt>
<dd>CSV 파일 경로 (None이면 기본 하드코딩 값 사용)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(rows, meta)
- rows: 탱크 데이터 리스트 (dict)
- meta: 로딩 메타데이터 (dict)</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; rows, meta = load_const_tanks_snapshot()
&gt;&gt;&gt; len(rows)
8
&gt;&gt;&gt; rows[0]['tank']
'DO.P'
</code></pre></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.normalize_key"><code class="name flex">
<span>def <span class="ident">normalize_key</span></span>(<span>s: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_key(s: str) -&gt; str:
    &#34;&#34;&#34;
    탱크명 정규화 함수 (대소문자, 공백, 특수문자 제거)

    Args:
        s: 정규화할 문자열 (탱크 이름)

    Returns:
        str: 알파벳과 숫자만 남긴 소문자 문자열

    Examples:
        &gt;&gt;&gt; normalize_key(&#34;DO.P&#34;)
        &#39;dop&#39;
        &gt;&gt;&gt; normalize_key(&#34;LRFO-P&#34;)
        &#39;lrfop&#39;
        &gt;&gt;&gt; normalize_key(&#34;FW 1.P&#34;)
        &#39;fw1p&#39;
    &#34;&#34;&#34;
    return &#34;&#34;.join(c.lower() for c in str(s) if c.isalnum())</code></pre>
</details>
<div class="desc"><p>탱크명 정규화 함수 (대소문자, 공백, 특수문자 제거)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong></dt>
<dd>정규화할 문자열 (탱크 이름)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>알파벳과 숫자만 남긴 소문자 문자열</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; normalize_key(&quot;DO.P&quot;)
'dop'
&gt;&gt;&gt; normalize_key(&quot;LRFO-P&quot;)
'lrfop'
&gt;&gt;&gt; normalize_key(&quot;FW 1.P&quot;)
'fw1p'
</code></pre></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.preflight_check"><code class="name flex">
<span>def <span class="ident">preflight_check</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preflight_check():
    &#34;&#34;&#34;
    BACKUP PLAN: 생성 전 환경 검증
    Returns: List of issue messages
    &#34;&#34;&#34;
    issues = []

    # 1. 필수 디렉토리 확인
    if not os.path.exists(&#34;data&#34;):
        issues.append(&#34;WARNING: data/ directory not found (fallback will be used)&#34;)

    # 2. 필수 JSON 파일 확인
    optional_jsons = [
        &#34;data/Hydro_Table_2D.json&#34;,
        &#34;data/gateab_v3_tide_data.json&#34;,
        &#34;data/tank_coordinates.json&#34;,
        &#34;data/tank_data.json&#34;,
        &#34;data/Frame_x_from_mid_m.json&#34;,
        &#34;data/hydro_table.json&#34;,
    ]
    for json_file in optional_jsons:
        if not os.path.exists(json_file):
            issues.append(f&#34;INFO: {json_file} missing (fallback will be used)&#34;)

    # 3. 디스크 공간 확인 (Windows용)
    try:
        import ctypes

        free_bytes = ctypes.c_ulonglong(0)
        ctypes.windll.kernel32.GetDiskFreeSpaceExW(
            ctypes.c_wchar_p(&#34;.&#34;), None, None, ctypes.pointer(free_bytes)
        )
        free_mb = free_bytes.value / (1024 * 1024)
        if free_mb &lt; 10:
            issues.append(f&#34;ERROR: Low disk space ({free_mb:.1f}MB)&#34;)
    except Exception:
        # Unix-like systems
        try:
            statvfs = os.statvfs(&#34;.&#34;)
            free_mb = (statvfs.f_frsize * statvfs.f_bavail) / (1024 * 1024)
            if free_mb &lt; 10:
                issues.append(f&#34;ERROR: Low disk space ({free_mb:.1f}MB)&#34;)
        except Exception:
            pass  # Skip disk check if not supported

    return issues</code></pre>
</details>
<div class="desc"><p>BACKUP PLAN: 생성 전 환경 검증
Returns: List of issue messages</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.safe_sheet_creation"><code class="name flex">
<span>def <span class="ident">safe_sheet_creation</span></span>(<span>wb, sheet_func, sheet_name, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def safe_sheet_creation(wb, sheet_func, sheet_name, *args, **kwargs):
    &#34;&#34;&#34;
    BACKUP PLAN: 시트 생성 wrapper with error recovery
    시트 생성 실패 시에도 계속 진행
    &#34;&#34;&#34;
    try:
        logging.info(f&#34;Creating sheet: {sheet_name}&#34;)
        result = sheet_func(wb, *args, **kwargs)
        logging.info(f&#34;[OK] {sheet_name} created successfully&#34;)
        return result
    except Exception as e:
        logging.error(f&#34;[ERROR] {sheet_name} creation failed: {e}&#34;)
        logging.warning(f&#34;[BACKUP] Skipping {sheet_name}, continuing...&#34;)
        print(f&#34;  [BACKUP] Warning: {sheet_name} creation failed, continuing...&#34;)
        return None</code></pre>
</details>
<div class="desc"><p>BACKUP PLAN: 시트 생성 wrapper with error recovery
시트 생성 실패 시에도 계속 진행</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.setup_logging"><code class="name flex">
<span>def <span class="ident">setup_logging</span></span>(<span>output_file)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_logging(output_file):
    &#34;&#34;&#34;
    BACKUP PLAN: 실행 로그 설정
    logs/ 폴더에 타임스탬프 로그 파일 생성
    &#34;&#34;&#34;
    log_dir = os.path.join(os.path.dirname(output_file), &#34;logs&#34;)
    os.makedirs(log_dir, exist_ok=True)

    log_file = os.path.join(
        log_dir, f&#34;agi_tr_{datetime.now().strftime(&#39;%Y%m%d_%H%M%S&#39;)}.log&#34;
    )

    logging.basicConfig(
        level=logging.INFO,
        format=&#34;%(asctime)s [%(levelname)s] %(message)s&#34;,
        handlers=[
            logging.FileHandler(log_file, encoding=&#34;utf-8&#34;),
            logging.StreamHandler(),
        ],
        force=True,  # Override any existing configuration
    )

    logging.info(&#34;=&#34; * 60)
    logging.info(&#34;LCT BUSHRA AGI TR Excel Generation&#34;)
    logging.info(f&#34;Output: {output_file}&#34;)
    logging.info(f&#34;Log: {log_file}&#34;)
    logging.info(&#34;=&#34; * 60)

    return log_file</code></pre>
</details>
<div class="desc"><p>BACKUP PLAN: 실행 로그 설정
logs/ 폴더에 타임스탬프 로그 파일 생성</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.simulate_stage"><code class="name flex">
<span>def <span class="ident">simulate_stage</span></span>(<span>stage_name: str, w_stage_t: float, x_stage_m: float, params: dict | None = None) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_stage(
    stage_name: str,
    w_stage_t: float,
    x_stage_m: float,
    params: dict | None = None,
) -&gt; dict:
    &#34;&#34;&#34;
    간단 Stage 계산:
    - 입력: Stage명, Stage 중량, Stage LCG(x)
    - 출력: Trim, FWD/AFT draft, Target 대비 OK/EXCESSIVE
    &#34;&#34;&#34;
    if params is None:
        params = DEFAULT_PARAMS

    tm = w_stage_t * x_stage_m  # t·m
    trim_cm = calc_trim(tm, params)
    fwd, aft = draft_from_trim(trim_cm, params)

    target = TRIM_TARGET_MAP.get(stage_name, 240.00)
    trim_check = &#34;OK&#34; if abs(trim_cm) &lt;= abs(target) else &#34;EXCESSIVE&#34;

    return {
        &#34;Stage&#34;: stage_name,
        &#34;W_stage_t&#34;: round(w_stage_t, 2),
        &#34;x_stage_m&#34;: round(x_stage_m, 2),
        &#34;TM_tm&#34;: round(tm, 2),
        &#34;Trim_cm&#34;: trim_cm,
        &#34;FWD_m&#34;: fwd,
        &#34;AFT_m&#34;: aft,
        &#34;Trim_target_cm&#34;: target,
        &#34;Trim_Check&#34;: trim_check,
    }</code></pre>
</details>
<div class="desc"><p>간단 Stage 계산:
- 입력: Stage명, Stage 중량, Stage LCG(x)
- 출력: Trim, FWD/AFT draft, Target 대비 OK/EXCESSIVE</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.solve_stage"><code class="name flex">
<span>def <span class="ident">solve_stage</span></span>(<span>base_disp_t: float,<br>base_tmean_m: float,<br>loads: List[01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem],<br>**params) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_stage(
    base_disp_t: float, base_tmean_m: float, loads: List[LoadItem], **params
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Engineering-grade Stage Solver (Option B).

    Key upgrades vs baseline:
      - Uses draft-dependent hydro interpolation (by Tmean_m) if available:
          * LCF_m_from_midship (aft+)
          * MCTC_t_m_per_cm (or MTC_t_m_per_cm)
          * TPC_t_per_cm
      - GM check uses GM minimum curve if provided (GM_min_m in hydro table or GM_Min_Curve.json)
      - Falls back to constants when approved booklet/NAPA hydro data is missing.

    Conventions (LOCKED)
      - x_from_mid_m: midship 기준, AFT=+, FWD=-
      - trim_cm = (Daft - Dfwd) * 100  (+ stern down / - bow down)

    Args:
        base_disp_t: Stage 1 baseline displacement (t)
        base_tmean_m: Stage 1 baseline mean draft (m) (kept for compatibility)
        loads: LoadItem list for current stage
        **params:
            - MTC or MTC_t_m_per_cm: fallback MCTC constant (t·m/cm)
            - LCF or LCF_m_from_midship: fallback LCF constant (m, aft+)
            - TPC or TPC_t_per_cm: fallback TPC constant (t/cm)
            - LBP: length used for trim slope (m)
            - D_vessel: molded depth (m)
            - hydro_table: list[dict] hydro points (recommended: includes Tmean_m + LCF/MCTC/TPC)
            - gm_curve: optional GM minimum curve list[dict]
            - max_fwd_draft_ops_m: forward draft operational limit (m)
            - trim_limit_cm: |trim| limit (cm)

    Returns:
        dict with stage results and basis metadata.
    &#34;&#34;&#34;
    # -----------------------
    # Fallback constants
    # -----------------------
    MTC_const = _as_float(
        params.get(&#34;MTC&#34;), _as_float(params.get(&#34;MTC_t_m_per_cm&#34;), 34.00)
    )
    LCF_const = _as_float(
        params.get(&#34;LCF&#34;), _as_float(params.get(&#34;LCF_m_from_midship&#34;), 0.76)
    )
    TPC_const = _as_float(
        params.get(&#34;TPC&#34;), _as_float(params.get(&#34;TPC_t_per_cm&#34;), 8.00)
    )
    LBP = _as_float(params.get(&#34;LBP&#34;), _as_float(params.get(&#34;Lpp_m&#34;), 60.302))
    D_vessel = _as_float(
        params.get(&#34;D_vessel&#34;), _as_float(params.get(&#34;D_vessel_m&#34;), 3.65)
    )

    hydro_table = params.get(&#34;hydro_table&#34;, []) or []
    gm_curve = params.get(&#34;gm_curve&#34;, None)

    max_fwd_draft_ops_m = _as_float(params.get(&#34;max_fwd_draft_ops_m&#34;), 2.70)
    trim_limit_cm = _as_float(params.get(&#34;trim_limit_cm&#34;), 240.0)

    # -----------------------
    # 1) Weight &amp; displacement
    # -----------------------
    delta_w = sum(ld.weight_t for ld in loads)
    disp_stage = base_disp_t + delta_w

    # LCG about midship (for reporting)
    if abs(delta_w) &lt; 1e-9:
        x_lcg = 0.0
    else:
        x_lcg = sum(ld.weight_t * ld.x_from_mid_m for ld in loads) / delta_w

    # Mean draft from displacement table (still valid even without TPC)
    tmean_stage = interpolate_tmean_from_disp(disp_stage, hydro_table)

    # -----------------------
    # 2) Draft-dependent hydro interpolation (Option B)
    # -----------------------
    hydro_i = interpolate_hydro_by_tmean(tmean_stage, hydro_table)
    lcf_used = _as_float(hydro_i.get(&#34;LCF_m_from_midship&#34;), LCF_const)
    mctc_used = _as_float(hydro_i.get(&#34;MCTC_t_m_per_cm&#34;), MTC_const)
    tpc_used = _as_float(hydro_i.get(&#34;TPC_t_per_cm&#34;), TPC_const)

    hydro_flags = {
        &#34;LCF_basis&#34;: &#34;hydro&#34; if &#34;LCF_m_from_midship&#34; in hydro_i else &#34;fallback&#34;,
        &#34;MCTC_basis&#34;: &#34;hydro&#34; if &#34;MCTC_t_m_per_cm&#34; in hydro_i else &#34;fallback&#34;,
        &#34;TPC_basis&#34;: &#34;hydro&#34; if &#34;TPC_t_per_cm&#34; in hydro_i else &#34;fallback&#34;,
    }

    # -----------------------
    # 3) Trimming moment about LCF and trim
    # -----------------------
    tm = sum(ld.weight_t * (ld.x_from_mid_m - lcf_used) for ld in loads)
    trim_cm = (tm / mctc_used) if (mctc_used and mctc_used &gt; 1e-9) else 0.0
    trim_m = trim_cm / 100.0

    # -----------------------
    # 4) End drafts (single convention)
    # -----------------------
    dfwd_m, daft_m = calc_draft_with_lcf(tmean_stage, trim_cm, lcf_used, LBP)

    # Validate trim definition (Daft - Dfwd)
    trim_verify_cm = (daft_m - dfwd_m) * 100.0
    if abs(trim_verify_cm - trim_cm) &gt; 0.01:
        logging.warning(
            f&#34;[TrimRef] Trim mismatch in solve_stage: trim_cm={trim_cm:.2f}, &#34;
            f&#34;verified_cm={trim_verify_cm:.2f} (Tmean={tmean_stage:.3f}, LBP={LBP:.3f})&#34;
        )

    # -----------------------
    # 5) GM and GM minimum curve
    # -----------------------
    gm_m = gm_2d_bilinear(disp_stage, trim_m)

    gm_min_m = _as_float(hydro_i.get(&#34;GM_min_m&#34;), None)
    gm_basis = &#34;hydro:GM_min_m&#34; if gm_min_m is not None else &#34;none&#34;

    if gm_min_m is None:
        gm_min_m, gm_basis = gm_min_from_curve(disp_stage, tmean_stage, gm_curve)

    if gm_min_m is None:
        gm_min_m = _as_float(params.get(&#34;gm_target_m&#34;), 1.50)
        gm_basis = &#34;fallback_constant&#34;

    # -----------------------
    # 6) Freeboard (height)
    # -----------------------
    fwd_height_m = max(0.0, D_vessel - dfwd_m)
    aft_height_m = max(0.0, D_vessel - daft_m)

    # -----------------------
    # 7) Checks (limits)
    # -----------------------
    trim_check = &#34;OK&#34; if abs(trim_cm) &lt;= trim_limit_cm else &#34;EXCESSIVE&#34;
    vs_ops = &#34;OK&#34; if dfwd_m &lt;= max_fwd_draft_ops_m else &#34;NG&#34;
    gm_check = &#34;OK&#34; if gm_m &gt;= gm_min_m else &#34;LOW&#34;

    engineering_grade_active = (
        hydro_flags[&#34;LCF_basis&#34;] == &#34;hydro&#34;
        and hydro_flags[&#34;MCTC_basis&#34;] == &#34;hydro&#34;
        and hydro_flags[&#34;TPC_basis&#34;] == &#34;hydro&#34;
        and (gm_basis != &#34;fallback_constant&#34;)
    )

    # --- Option B Patch: FSM + GM_eff ---
    const_fsm_t_m = _as_float(params.get(&#34;Const_FSM_t_m&#34;, 0.0))
    disp_stage_for_fsm = disp_stage  # Already calculated: base_disp_t + delta_w
    gm_eff_m = gm_m - (
        const_fsm_t_m / disp_stage_for_fsm if disp_stage_for_fsm &gt; 0 else 0.0
    )

    return {
        &#34;ΔW_t&#34;: float(delta_w),
        &#34;x_LCG_m&#34;: float(x_lcg),
        &#34;TM_t_m&#34;: float(tm),
        &#34;Trim_cm&#34;: float(trim_cm),
        &#34;Tmean_m&#34;: float(tmean_stage),
        &#34;Dfwd_m&#34;: float(dfwd_m),
        &#34;Daft_m&#34;: float(daft_m),
        &#34;GM_m&#34;: float(gm_m),
        &#34;GM_min_m&#34;: float(gm_min_m),
        &#34;GM_basis&#34;: gm_basis,
        &#34;LCF_used_m&#34;: float(lcf_used),
        &#34;MCTC_used_t_m_per_cm&#34;: float(mctc_used),
        &#34;TPC_used_t_per_cm&#34;: float(tpc_used),
        &#34;Hydro_flags&#34;: hydro_flags,
        &#34;EngineeringGrade_active&#34;: bool(engineering_grade_active),
        &#34;FWD_Height_m&#34;: float(fwd_height_m),
        &#34;AFT_Height_m&#34;: float(aft_height_m),
        &#34;Trim_Check&#34;: trim_check,
        &#34;vs_ops_fwd_draft&#34;: vs_ops,
        &#34;GM_Check&#34;: gm_check,
        # Patch Option B: FSM and GM_eff
        &#34;FSE_t_m&#34;: float(const_fsm_t_m),
        &#34;GM_eff_m&#34;: float(gm_eff_m),
        # Compatibility keys for create_roro_sheet() and other functions
        &#34;W_stage_t&#34;: float(
            disp_stage
        ),  # Total weight = base_disp_t + delta_w (NOT just delta_w!)
        &#34;x_stage_m&#34;: float(x_lcg),  # Alias for x_LCG_m
        &#34;TM_LCF_tm&#34;: float(tm),  # Alias for TM_t_m
        &#34;vs_2.70m&#34;: vs_ops,  # Alias for vs_ops_fwd_draft
        &#34;Disp_t&#34;: float(disp_stage),  # Displacement = total weight
    }</code></pre>
</details>
<div class="desc"><p>Engineering-grade Stage Solver (Option B).</p>
<p>Key upgrades vs baseline:
- Uses draft-dependent hydro interpolation (by Tmean_m) if available:
* LCF_m_from_midship (aft+)
* MCTC_t_m_per_cm (or MTC_t_m_per_cm)
* TPC_t_per_cm
- GM check uses GM minimum curve if provided (GM_min_m in hydro table or GM_Min_Curve.json)
- Falls back to constants when approved booklet/NAPA hydro data is missing.</p>
<p>Conventions (LOCKED)
- x_from_mid_m: midship 기준, AFT=+, FWD=-
- trim_cm = (Daft - Dfwd) * 100
(+ stern down / - bow down)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_disp_t</code></strong></dt>
<dd>Stage 1 baseline displacement (t)</dd>
<dt><strong><code>base_tmean_m</code></strong></dt>
<dd>Stage 1 baseline mean draft (m) (kept for compatibility)</dd>
<dt><strong><code>loads</code></strong></dt>
<dd>LoadItem list for current stage</dd>
</dl>
<p>**params:
- MTC or MTC_t_m_per_cm: fallback MCTC constant (t·m/cm)
- LCF or LCF_m_from_midship: fallback LCF constant (m, aft+)
- TPC or TPC_t_per_cm: fallback TPC constant (t/cm)
- LBP: length used for trim slope (m)
- D_vessel: molded depth (m)
- hydro_table: list[dict] hydro points (recommended: includes Tmean_m + LCF/MCTC/TPC)
- gm_curve: optional GM minimum curve list[dict]
- max_fwd_draft_ops_m: forward draft operational limit (m)
- trim_limit_cm: |trim| limit (cm)</p>
<h2 id="returns">Returns</h2>
<p>dict with stage results and basis metadata.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.x_to_fr"><code class="name flex">
<span>def <span class="ident">x_to_fr</span></span>(<span>x: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_to_fr(x: float) -&gt; float:
    &#34;&#34;&#34;
    Inverse: x [m from midship] → Frame number.

    공식: fr = _FRAME_OFFSET - x (x = -1.0 * (fr - 30.151) 이므로)
    &#34;&#34;&#34;
    return _FRAME_OFFSET - float(x)</code></pre>
</details>
<div class="desc"><p>Inverse: x [m from midship] → Frame number.</p>
<p>공식: fr = _FRAME_OFFSET - x (x = -1.0 * (fr - 30.151) 이므로)</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.BackupRecoveryError"><code class="flex name class">
<span>class <span class="ident">BackupRecoveryError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackupRecoveryError(Exception):
    &#34;&#34;&#34;BACKUP PLAN: 백업 복구 가능한 에러&#34;&#34;&#34;

    pass</code></pre>
</details>
<div class="desc"><p>BACKUP PLAN: 백업 복구 가능한 에러</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase"><code class="flex name class">
<span>class <span class="ident">LoadCase</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoadCase(Enum):
    STATIC = auto()  # A: 정적
    DYNAMIC = auto()  # B: 동적계수만
    BRAKING = auto()  # C: 동적 + 제동/편심</code></pre>
</details>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access::</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; Color.RED
&lt;Color.RED: 1&gt;
</code></pre>
<ul>
<li>value lookup:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; Color(1)
&lt;Color.RED: 1&gt;
</code></pre>
<ul>
<li>name lookup:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; Color['RED']
&lt;Color.RED: 1&gt;
</code></pre>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase.BRAKING"><code class="name">var <span class="ident">BRAKING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase.DYNAMIC"><code class="name">var <span class="ident">DYNAMIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase.STATIC"><code class="name">var <span class="ident">STATIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem"><code class="flex name class">
<span>class <span class="ident">LoadItem</span></span>
<span>(</span><span>name: str, weight_t: float, x_from_mid_m: float, kind: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoadItem(NamedTuple):
    &#34;&#34;&#34;Stage별 하중 구성 요소&#34;&#34;&#34;

    name: str
    weight_t: float
    x_from_mid_m: float
    kind: str  # &#34;TR&#34;, &#34;SPMT&#34;, &#34;BALLAST&#34;, &#34;CONST&#34;, &#34;CARGO&#34;</code></pre>
</details>
<div class="desc"><p>Stage별 하중 구성 요소</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.kind"><code class="name">var <span class="ident">kind</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoadItem(NamedTuple):
    &#34;&#34;&#34;Stage별 하중 구성 요소&#34;&#34;&#34;

    name: str
    weight_t: float
    x_from_mid_m: float
    kind: str  # &#34;TR&#34;, &#34;SPMT&#34;, &#34;BALLAST&#34;, &#34;CONST&#34;, &#34;CARGO&#34;</code></pre>
</details>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoadItem(NamedTuple):
    &#34;&#34;&#34;Stage별 하중 구성 요소&#34;&#34;&#34;

    name: str
    weight_t: float
    x_from_mid_m: float
    kind: str  # &#34;TR&#34;, &#34;SPMT&#34;, &#34;BALLAST&#34;, &#34;CONST&#34;, &#34;CARGO&#34;</code></pre>
</details>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.weight_t"><code class="name">var <span class="ident">weight_t</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoadItem(NamedTuple):
    &#34;&#34;&#34;Stage별 하중 구성 요소&#34;&#34;&#34;

    name: str
    weight_t: float
    x_from_mid_m: float
    kind: str  # &#34;TR&#34;, &#34;SPMT&#34;, &#34;BALLAST&#34;, &#34;CONST&#34;, &#34;CARGO&#34;</code></pre>
</details>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.x_from_mid_m"><code class="name">var <span class="ident">x_from_mid_m</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoadItem(NamedTuple):
    &#34;&#34;&#34;Stage별 하중 구성 요소&#34;&#34;&#34;

    name: str
    weight_t: float
    x_from_mid_m: float
    kind: str  # &#34;TR&#34;, &#34;SPMT&#34;, &#34;BALLAST&#34;, &#34;CONST&#34;, &#34;CARGO&#34;</code></pre>
</details>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="01_EXECUTION_FILES" href="index.html">01_EXECUTION_FILES</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.apply_dynamic_loads" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.apply_dynamic_loads">apply_dynamic_loads</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_ballast_scenarios_from_stage_results" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_ballast_scenarios_from_stage_results">build_ballast_scenarios_from_stage_results</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_csm_trace" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_csm_trace">build_csm_trace</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_opt_c_stage" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_opt_c_stage">build_opt_c_stage</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_stage5_loads" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_stage5_loads">build_stage5_loads</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_stage6a_loads" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_stage6a_loads">build_stage6a_loads</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_stage_loads" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_stage_loads">build_stage_loads</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_tank_lookup" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.build_tank_lookup">build_tank_lookup</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_draft_with_lcf" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_draft_with_lcf">calc_draft_with_lcf</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_gm_effective" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_gm_effective">calc_gm_effective</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_heel_from_offset" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_heel_from_offset">calc_heel_from_offset</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_trim" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_trim">calc_trim</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_trim_gate_cm_from_tmean" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.calc_trim_gate_cm_from_tmean">calc_trim_gate_cm_from_tmean</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.cleanup_old_backups" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.cleanup_old_backups">cleanup_old_backups</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_acceptance_criteria_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_acceptance_criteria_sheet">create_acceptance_criteria_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_backup_file" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_backup_file">create_backup_file</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_ballast_scenario_comparison_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_ballast_scenario_comparison_sheet">create_ballast_scenario_comparison_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_ballast_tanks_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_ballast_tanks_sheet">create_ballast_tanks_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_calc_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_calc_sheet">create_calc_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_captain_report_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_captain_report_sheet">create_captain_report_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_const_tanks_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_const_tanks_sheet">create_const_tanks_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_csm_trace_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_csm_trace_sheet">create_csm_trace_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_frame_table_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_frame_table_sheet">create_frame_table_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_hourly_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_hourly_sheet">create_hourly_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_hydro_table_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_hydro_table_sheet">create_hydro_table_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_index_match_formula" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_index_match_formula">create_index_match_formula</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_iscode_check_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_iscode_check_sheet">create_iscode_check_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_mws_pack_index_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_mws_pack_index_sheet">create_mws_pack_index_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_delta_lever_report_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_delta_lever_report_sheet">create_roro_delta_lever_report_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_draft_margin_check_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_draft_margin_check_sheet">create_roro_draft_margin_check_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_sheet">create_roro_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_stability_gm_check_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_roro_stability_gm_check_sheet">create_roro_stability_gm_check_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_structural_gate_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_structural_gate_sheet">create_structural_gate_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_tide_sheet" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_tide_sheet">create_tide_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_workbook_from_scratch" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.create_workbook_from_scratch">create_workbook_from_scratch</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.debug_frame_mapping" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.debug_frame_mapping">debug_frame_mapping</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.debug_tank_lcg_check" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.debug_tank_lcg_check">debug_tank_lcg_check</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.draft_from_trim" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.draft_from_trim">draft_from_trim</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.enrich_stage_results_bplus" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.enrich_stage_results_bplus">enrich_stage_results_bplus</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.evaluate_acceptance" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.evaluate_acceptance">evaluate_acceptance</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.evaluate_stages" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.evaluate_stages">evaluate_stages</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.evaluate_structural_gate" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.evaluate_structural_gate">evaluate_structural_gate</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.export_roro_delta_lever_report_to_csv" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.export_roro_delta_lever_report_to_csv">export_roro_delta_lever_report_to_csv</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.export_stages_to_csv" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.export_stages_to_csv">export_stages_to_csv</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.export_whatsapp_summary_png" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.export_whatsapp_summary_png">export_whatsapp_summary_png</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_precision_columns" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_precision_columns">extend_precision_columns</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_roro_bc_br_range" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_roro_bc_br_range">extend_roro_bc_br_range</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_roro_captain_req" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_roro_captain_req">extend_roro_captain_req</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_roro_structural_opt1" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.extend_roro_structural_opt1">extend_roro_structural_opt1</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.find_preballast_opt" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.find_preballast_opt">find_preballast_opt</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.fr_to_x" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.fr_to_x">fr_to_x</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.get_fixed_tank_data" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.get_fixed_tank_data">get_fixed_tank_data</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.get_gm_bilinear" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.get_gm_bilinear">get_gm_bilinear</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.get_styles" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.get_styles">get_styles</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.gm_2d_bilinear" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.gm_2d_bilinear">gm_2d_bilinear</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.gm_min_from_curve" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.gm_min_from_curve">gm_min_from_curve</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.heel_and_gm_check" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.heel_and_gm_check">heel_and_gm_check</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.interpolate_hydro_by_tmean" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.interpolate_hydro_by_tmean">interpolate_hydro_by_tmean</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.interpolate_tmean_from_disp" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.interpolate_tmean_from_disp">interpolate_tmean_from_disp</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.iscode_general_check" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.iscode_general_check">iscode_general_check</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.iterative_ballast_correction" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.iterative_ballast_correction">iterative_ballast_correction</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.load_const_tanks_snapshot" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.load_const_tanks_snapshot">load_const_tanks_snapshot</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.normalize_key" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.normalize_key">normalize_key</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.preflight_check" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.preflight_check">preflight_check</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.safe_sheet_creation" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.safe_sheet_creation">safe_sheet_creation</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.setup_logging" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.setup_logging">setup_logging</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.simulate_stage" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.simulate_stage">simulate_stage</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.solve_stage" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.solve_stage">solve_stage</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.x_to_fr" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.x_to_fr">x_to_fr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.BackupRecoveryError" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.BackupRecoveryError">BackupRecoveryError</a></code></h4>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase">LoadCase</a></code></h4>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase.BRAKING" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase.BRAKING">BRAKING</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase.DYNAMIC" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase.DYNAMIC">DYNAMIC</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase.STATIC" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadCase.STATIC">STATIC</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem">LoadItem</a></code></h4>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.kind" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.kind">kind</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.name" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.name">name</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.weight_t" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.weight_t">weight_t</a></code></li>
<li><code><a title="01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.x_from_mid_m" href="#01_EXECUTION_FILES.agi_tr_patched_v6_6_defsplit_v1.LoadItem.x_from_mid_m">x_from_mid_m</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
