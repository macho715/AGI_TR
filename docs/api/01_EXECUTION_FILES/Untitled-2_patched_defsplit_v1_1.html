<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1 API documentation</title>
<meta name="description" content="BALLAST OPTIMIZER INTEGRATED (LCT BUSHRA &amp; GENERIC)
Merges Linear Programming accuracy with Operational Heuristics …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1</code></h1>
</header>
<section id="section-intro">
<p>=============================================================================
BALLAST OPTIMIZER INTEGRATED (LCT BUSHRA &amp; GENERIC)
=============================================================================
Merges Linear Programming accuracy with Operational Heuristics.</p>
<p>Features:
- SCIPY Linear Programming Solver (Exact targets, Slack variables)
- Interactive CLI for crew use
- Batch processing for office use (CSV/Excel support)
- BWRB (Ballast Water Record Book) Logging generation
- AGI Site &amp; Pre-ballast specific logic</p>
<h2 id="usage">Usage</h2>
<ol>
<li>Interactive: python ballast_optimizer_integrated.py</li>
<li>
<h1 id="batch-python-ballast_optimizer_integratedpy-tank-tankcsv">Batch:
python ballast_optimizer_integrated.py &ndash;tank tank.csv &hellip;</h1>
</li>
</ol>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.build_roro_stage_loads"><code class="name flex">
<span>def <span class="ident">build_roro_stage_loads</span></span>(<span>stage_name: str,<br>preballast_t: float,<br>w_tr: float = 271.2,<br>fr_tr1_stow: float = 42.0,<br>fr_tr1_ramp_start: float = 40.15,<br>fr_tr1_ramp_mid: float = 37.0,<br>fr_tr2_ramp: float = 17.95,<br>fr_tr2_stow: float = 40.0,<br>fr_preballast: float = 3.0) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_roro_stage_loads(
    stage_name: str,
    preballast_t: float,
    w_tr: float = 271.20,
    fr_tr1_stow: float = 42.0,
    fr_tr1_ramp_start: float = 40.15,
    fr_tr1_ramp_mid: float = 37.00,
    fr_tr2_ramp: float = 17.95,
    fr_tr2_stow: float = 40.00,
    fr_preballast: float = 3.0,
) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;
    Build load list for RORO stage.

    Args:
        stage_name: Stage name (e.g., &#34;Stage 1&#34;, &#34;Stage 2&#34;, etc.)
        preballast_t: Pre-ballast weight (t)
        w_tr: Transformer unit weight (t)
        fr_tr1_stow: TR1 stow Frame number
        fr_tr1_ramp_start: TR1 ramp start Frame number
        fr_tr1_ramp_mid: TR1 ramp mid Frame number
        fr_tr2_ramp: TR2 ramp Frame number
        fr_tr2_stow: TR2 stow Frame number
        fr_preballast: Pre-ballast Frame number

    Returns:
        List of load dicts with keys: &#34;name&#34;, &#34;weight_t&#34;, &#34;x_from_mid_m&#34;, &#34;kind&#34;
    &#34;&#34;&#34;
    loads: List[Dict[str, Any]] = []

    if stage_name == &#34;Stage 1&#34;:
        return loads  # Arrival - no loads

    if stage_name == &#34;Stage 2&#34;:
        # TR1 ramp start
        loads.append(
            {
                &#34;name&#34;: &#34;TR1+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr1_ramp_start),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
    elif stage_name == &#34;Stage 3&#34;:
        # TR1 mid-ramp
        loads.append(
            {
                &#34;name&#34;: &#34;TR1+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr1_ramp_mid),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
    elif stage_name == &#34;Stage 4&#34;:
        # TR1 on deck
        loads.append(
            {
                &#34;name&#34;: &#34;TR1+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr1_stow),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
    elif stage_name == &#34;Stage 5&#34;:
        # TR1 final position
        loads.append(
            {
                &#34;name&#34;: &#34;TR1+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr1_stow),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
    elif stage_name == &#34;Stage 5_PreBallast&#34;:
        loads.append(
            {
                &#34;name&#34;: &#34;TR1+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr1_stow),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
        loads.append(
            {
                &#34;name&#34;: &#34;PreBallast&#34;,
                &#34;weight_t&#34;: preballast_t,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_preballast),
                &#34;kind&#34;: &#34;BALLAST&#34;,
            }
        )
    elif stage_name == &#34;Stage 6A_Critical (Opt C)&#34;:
        loads.append(
            {
                &#34;name&#34;: &#34;TR1+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr1_stow),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
        loads.append(
            {
                &#34;name&#34;: &#34;TR2+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr2_ramp),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
        loads.append(
            {
                &#34;name&#34;: &#34;PreBallast&#34;,
                &#34;weight_t&#34;: preballast_t,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_preballast),
                &#34;kind&#34;: &#34;BALLAST&#34;,
            }
        )
    elif stage_name == &#34;Stage 6C_TotalMassOpt&#34;:
        loads.append(
            {
                &#34;name&#34;: &#34;TR1+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr1_stow),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
        loads.append(
            {
                &#34;name&#34;: &#34;TR2+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr2_stow),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
        loads.append(
            {
                &#34;name&#34;: &#34;PreBallast&#34;,
                &#34;weight_t&#34;: preballast_t,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_preballast),
                &#34;kind&#34;: &#34;BALLAST&#34;,
            }
        )
    elif stage_name == &#34;Stage 6C&#34;:
        loads.append(
            {
                &#34;name&#34;: &#34;TR1+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr1_stow),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
        loads.append(
            {
                &#34;name&#34;: &#34;TR2+SPMT&#34;,
                &#34;weight_t&#34;: w_tr,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_tr2_stow),
                &#34;kind&#34;: &#34;CARGO&#34;,
            }
        )
        loads.append(
            {
                &#34;name&#34;: &#34;PreBallast&#34;,
                &#34;weight_t&#34;: preballast_t,
                &#34;x_from_mid_m&#34;: fr_to_x(fr_preballast),
                &#34;kind&#34;: &#34;BALLAST&#34;,
            }
        )
    elif stage_name == &#34;Stage 7&#34;:
        return loads  # Departure - no loads

    return loads</code></pre>
</details>
<div class="desc"><p>Build load list for RORO stage.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stage_name</code></strong></dt>
<dd>Stage name (e.g., "Stage 1", "Stage 2", etc.)</dd>
<dt><strong><code>preballast_t</code></strong></dt>
<dd>Pre-ballast weight (t)</dd>
<dt><strong><code>w_tr</code></strong></dt>
<dd>Transformer unit weight (t)</dd>
<dt><strong><code>fr_tr1_stow</code></strong></dt>
<dd>TR1 stow Frame number</dd>
<dt><strong><code>fr_tr1_ramp_start</code></strong></dt>
<dd>TR1 ramp start Frame number</dd>
<dt><strong><code>fr_tr1_ramp_mid</code></strong></dt>
<dd>TR1 ramp mid Frame number</dd>
<dt><strong><code>fr_tr2_ramp</code></strong></dt>
<dd>TR2 ramp Frame number</dd>
<dt><strong><code>fr_tr2_stow</code></strong></dt>
<dd>TR2 stow Frame number</dd>
<dt><strong><code>fr_preballast</code></strong></dt>
<dd>Pre-ballast Frame number</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code> of <code>load dicts with keys</code></dt>
<dd>"name", "weight_t", "x_from_mid_m", "kind"</dd>
</dl></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.build_tank_log"><code class="name flex">
<span>def <span class="ident">build_tank_log</span></span>(<span>tanks: List[<a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank">Tank</a>],<br>delta: Dict[str, float]) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_tank_log(tanks: List[Tank], delta: Dict[str, float]) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate tank-by-tank log with start/end states.&#34;&#34;&#34;
    return pd.DataFrame(
        [
            {
                &#34;Tank&#34;: t.name,
                &#34;UseFlag&#34;: t.use_flag,
                &#34;Mode&#34;: t.mode,
                &#34;Freeze&#34;: t.freeze_flag,
                &#34;x_from_mid_m&#34;: round(t.x_from_mid_m, 2),
                &#34;Start_t&#34;: round(t.current_t, 2),
                &#34;Δt_t&#34;: round(float(delta.get(t.name, 0.0)), 2),
                &#34;End_t&#34;: round(t.current_t + float(delta.get(t.name, 0.0)), 2),
                &#34;Min_t&#34;: round(t.min_t, 2),
                &#34;Max_t&#34;: round(t.max_t, 2),
            }
            for t in tanks
        ]
    )</code></pre>
</details>
<div class="desc"><p>Generate tank-by-tank log with start/end states.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.calc_draft_with_lcf"><code class="name flex">
<span>def <span class="ident">calc_draft_with_lcf</span></span>(<span>tmean_m: float, trim_cm: float, lcf_m: float, lbp_m: float) ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_draft_with_lcf(
    tmean_m: float, trim_cm: float, lcf_m: float, lbp_m: float
) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;
    Draft 계산 (단일 참조점/부호 규약 고정).

    Conventions (LOCKED)
    --------------------
    - x_from_mid_m: midship 기준, AFT = +, FWD = -
    - trim_cm: (Daft - Dfwd) * 100  [cm]
        * + : stern down (AFT deeper)
        * - : bow down   (FWD deeper)
    - tmean_m: midship draft ≈ (Dfwd + Daft) / 2   [m]
    - lbp_m: LBP/Lpp used for trim slope length     [m]
    - lcf_m: LCF x_from_mid_m (aft+)  [m]

    Returns
    -------
    (Dfwd_m, Daft_m)
    &#34;&#34;&#34;
    if lbp_m &lt;= 0:
        raise ValueError(&#34;LBP must be &gt; 0&#34;)

    halfL = lbp_m / 2.0

    # Guard-rail: LCF는 midship 기준이면 |LCF| &lt;= LBP/2 근처여야 한다.
    if abs(lcf_m) &gt; halfL + 0.50:
        raise ValueError(
            f&#34;LCF reference mismatch suspected. &#34;
            f&#34;Expected lcf_m as x_from_mid_m (|lcf|&lt;=~{halfL:.3f}), got {lcf_m:.3f}.&#34;
        )

    trim_m = trim_cm / 100.0  # cm -&gt; m

    # Linear trim line about midship:
    # draft(x) = tmean_m + (trim_m / lbp_m) * x_from_mid_m
    dfwd_m = tmean_m + (trim_m / lbp_m) * (-halfL)
    daft_m = tmean_m + (trim_m / lbp_m) * (+halfL)

    return dfwd_m, daft_m</code></pre>
</details>
<div class="desc"><p>Draft 계산 (단일 참조점/부호 규약 고정).</p>
<h2 id="conventions-locked">Conventions (LOCKED)</h2>
<ul>
<li>x_from_mid_m: midship 기준, AFT = +, FWD = -</li>
<li>trim_cm: (Daft - Dfwd) * 100
[cm]<ul>
<li>
<ul>
<li>: stern down (AFT deeper)</li>
</ul>
</li>
<li>
<ul>
<li>: bow down
(FWD deeper)</li>
</ul>
</li>
</ul>
</li>
<li>tmean_m: midship draft ≈ (Dfwd + Daft) / 2
[m]</li>
<li>lbp_m: LBP/Lpp used for trim slope length
[m]</li>
<li>lcf_m: LCF x_from_mid_m (aft+)
[m]</li>
</ul>
<h2 id="returns">Returns</h2>
<p>(Dfwd_m, Daft_m)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.calc_trim_gate_cm_from_tmean"><code class="name flex">
<span>def <span class="ident">calc_trim_gate_cm_from_tmean</span></span>(<span>tmean_m: float, fwd_limit_m: float = 2.7) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_trim_gate_cm_from_tmean(tmean_m: float, fwd_limit_m: float = 2.70) -&gt; float:
    &#34;&#34;&#34;
    Calculate required trim (cm) to satisfy forward draft limit.

    Formula: Trim_gate_cm = max(0, 2 * (Tmean - FWD_limit) * 100)

    This ensures: Dfwd = Tmean - (Trim/2) &lt;= FWD_limit
    Therefore: Trim &gt;= 2 * (Tmean - FWD_limit)

    Args:
        tmean_m: Mean draft (m)
        fwd_limit_m: Forward draft limit (m), default 2.70

    Returns:
        Required trim in cm (positive = stern down, negative = bow down)
        Returns 0 if Tmean &lt;= FWD_limit (no trim needed)
    &#34;&#34;&#34;
    trim_gate_cm = max(0.0, 2.0 * (tmean_m - fwd_limit_m) * 100.0)
    return float(trim_gate_cm)</code></pre>
</details>
<div class="desc"><p>Calculate required trim (cm) to satisfy forward draft limit.</p>
<p>Formula: Trim_gate_cm = max(0, 2 * (Tmean - FWD_limit) * 100)</p>
<p>This ensures: Dfwd = Tmean - (Trim/2) &lt;= FWD_limit
Therefore: Trim &gt;= 2 * (Tmean - FWD_limit)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tmean_m</code></strong></dt>
<dd>Mean draft (m)</dd>
<dt><strong><code>fwd_limit_m</code></strong></dt>
<dd>Forward draft limit (m), default 2.70</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Required trim in cm (positive = stern down, negative = bow down)
Returns 0 if Tmean &lt;= FWD_limit (no trim needed)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.calculate_roro_stage_drafts"><code class="name flex">
<span>def <span class="ident">calculate_roro_stage_drafts</span></span>(<span>stage_name: str,<br>loads: List[Dict[str, Any]],<br>base_disp: float,<br>base_tmean: float,<br>hydro_df: Optional[pd.DataFrame],<br>params: Dict[str, Any]) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_roro_stage_drafts(
    stage_name: str,
    loads: List[Dict[str, Any]],
    base_disp: float,
    base_tmean: float,
    hydro_df: Optional[pd.DataFrame],
    params: Dict[str, Any],
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Calculate drafts for a RORO stage based on loads.

    Args:
        stage_name: Stage name
        loads: List of load dicts
        base_disp: Base displacement (t)
        base_tmean: Base mean draft (m)
        hydro_df: Hydro table DataFrame
        params: Parameters dict

    Returns:
        dict with stage calculation results
    &#34;&#34;&#34;
    # Get constants
    MTC = params.get(&#34;MTC&#34;, params.get(&#34;MTC_t_m_per_cm&#34;, VesselParams.MTC))
    LCF = params.get(&#34;LCF&#34;, params.get(&#34;LCF_m_from_midship&#34;, VesselParams.LCF))
    LBP = params.get(&#34;LBP&#34;, VesselParams.LBP)
    TPC = params.get(&#34;TPC&#34;, params.get(&#34;TPC_t_per_cm&#34;, VesselParams.TPC))
    D_vessel = params.get(&#34;D_vessel&#34;, VesselParams.D_VESSEL)

    # Calculate total weight and moment
    delta_w = sum(ld[&#34;weight_t&#34;] for ld in loads)
    disp_stage = base_disp + delta_w

    if abs(delta_w) &lt; 1e-9:
        x_lcg = 0.0
    else:
        x_lcg = sum(ld[&#34;weight_t&#34;] * ld[&#34;x_from_mid_m&#34;] for ld in loads) / delta_w

    # Calculate Tmean from displacement
    if hydro_df is not None and not hydro_df.empty:
        tmean_stage = interpolate_tmean_from_disp(disp_stage, hydro_df)
        hydro_i = interpolate_hydro_by_tmean(tmean_stage, hydro_df)
        lcf_used = hydro_i.get(&#34;LCF_m_from_midship&#34;, LCF)
        mctc_used = hydro_i.get(&#34;MCTC_t_m_per_cm&#34;, MTC)
        tpc_used = hydro_i.get(&#34;TPC_t_per_cm&#34;, TPC)
    else:
        tmean_stage = base_tmean + delta_w / (TPC * 100.0)
        lcf_used = LCF
        mctc_used = MTC
        tpc_used = TPC

    # Calculate trimming moment and trim
    tm = sum(ld[&#34;weight_t&#34;] * (ld[&#34;x_from_mid_m&#34;] - lcf_used) for ld in loads)
    trim_cm = (tm / mctc_used) if (mctc_used and mctc_used &gt; 1e-9) else 0.0

    # Calculate end drafts
    dfwd_m, daft_m = calc_draft_with_lcf(tmean_stage, trim_cm, lcf_used, LBP)

    # Calculate GM (simplified - can be enhanced with GM grid)
    trim_m = trim_cm / 100.0
    gm_m = gm_2d_bilinear(disp_stage, trim_m, params.get(&#34;gm_grid&#34;))

    # Calculate freeboard
    fwd_height_m = max(0.0, D_vessel - dfwd_m)
    aft_height_m = max(0.0, D_vessel - daft_m)

    # Validation checks
    max_fwd = params.get(&#34;max_fwd_draft_ops_m&#34;, VesselParams.MAX_FWD_DRAFT_OPS)
    trim_limit = params.get(&#34;trim_limit_abs_cm&#34;, VesselParams.TRIM_LIMIT_CM)
    gm_min = params.get(&#34;gm_min_m&#34;, VesselParams.MIN_GM_M)

    trim_check = &#34;OK&#34; if abs(trim_cm) &lt;= trim_limit else &#34;EXCESSIVE&#34;
    vs_ops = &#34;OK&#34; if dfwd_m &lt;= max_fwd else &#34;NG&#34;
    gm_check = &#34;OK&#34; if gm_m &gt;= gm_min else &#34;LOW&#34;

    # Calculate Ballast_t and Ballast_time_h (if applicable)
    ballast_t = 0.0
    ballast_time_h = 0.0
    if abs(trim_cm) &gt; 0 and tpc_used &gt; 0:
        trim_m_abs = abs(trim_cm / 100.0)
        ballast_t = round(trim_m_abs * 50.0 * tpc_used, 2)
        pump_rate = params.get(&#34;pump_rate_effective_tph&#34;, 100.0)
        if pump_rate &gt; 0:
            ballast_time_h = round(ballast_t / pump_rate, 2)

    return {
        &#34;ΔW_t&#34;: float(delta_w),
        &#34;x_LCG_m&#34;: float(x_lcg),
        &#34;TM_t_m&#34;: float(tm),
        &#34;Trim_cm&#34;: float(trim_cm),
        &#34;Tmean_m&#34;: float(tmean_stage),
        &#34;Dfwd_m&#34;: float(dfwd_m),
        &#34;Daft_m&#34;: float(daft_m),
        &#34;GM_m&#34;: float(gm_m),
        &#34;FWD_Height_m&#34;: float(fwd_height_m),
        &#34;AFT_Height_m&#34;: float(aft_height_m),
        &#34;Trim_Check&#34;: trim_check,
        &#34;vs_ops_fwd_draft&#34;: vs_ops,
        &#34;GM_Check&#34;: gm_check,
        &#34;W_stage_t&#34;: float(disp_stage),
        &#34;x_stage_m&#34;: float(x_lcg),
        &#34;TM_LCF_tm&#34;: float(tm),
        &#34;vs_2.70m&#34;: vs_ops,
        &#34;Disp_t&#34;: float(disp_stage),
        &#34;Ballast_t&#34;: float(ballast_t),
        &#34;Ballast_time_h&#34;: float(ballast_time_h),
    }</code></pre>
</details>
<div class="desc"><p>Calculate drafts for a RORO stage based on loads.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stage_name</code></strong></dt>
<dd>Stage name</dd>
<dt><strong><code>loads</code></strong></dt>
<dd>List of load dicts</dd>
<dt><strong><code>base_disp</code></strong></dt>
<dd>Base displacement (t)</dd>
<dt><strong><code>base_tmean</code></strong></dt>
<dd>Base mean draft (m)</dd>
<dt><strong><code>hydro_df</code></strong></dt>
<dd>Hydro table DataFrame</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Parameters dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dict with stage calculation results</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.col_idx_to_excel_letter"><code class="name flex">
<span>def <span class="ident">col_idx_to_excel_letter</span></span>(<span>col_idx: int) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def col_idx_to_excel_letter(col_idx: int) -&gt; str:
    &#34;&#34;&#34;
    Convert 0-based column index to Excel column letter (A, B, ..., Z, AA, AB, ...)

    Args:
        col_idx: 0-based column index

    Returns:
        Excel column letter (e.g., 0 -&gt; &#39;A&#39;, 15 -&gt; &#39;P&#39;, 26 -&gt; &#39;AA&#39;)
    &#34;&#34;&#34;
    result = &#34;&#34;
    col_idx += 1  # Convert to 1-based
    while col_idx &gt; 0:
        col_idx -= 1
        result = chr(65 + (col_idx % 26)) + result
        col_idx //= 26
    return result</code></pre>
</details>
<div class="desc"><p>Convert 0-based column index to Excel column letter (A, B, &hellip;, Z, AA, AB, &hellip;)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>col_idx</code></strong></dt>
<dd>0-based column index</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Excel column letter (e.g., 0 -&gt; 'A', 15 -&gt; 'P', 26 -&gt; 'AA')</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.create_ballasting_sheet"><code class="name flex">
<span>def <span class="ident">create_ballasting_sheet</span></span>(<span>workbook: Any,<br>stage_results: Dict[str, Dict[str, Any]],<br>tanks: Optional[List[<a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank">Tank</a>]] = None,<br>styles: Optional[Dict[str, Any]] = None,<br>params: Optional[Dict[str, Any]] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_ballasting_sheet(
    workbook: Any,
    stage_results: Dict[str, Dict[str, Any]],
    tanks: Optional[List[Tank]] = None,
    styles: Optional[Dict[str, Any]] = None,
    params: Optional[Dict[str, Any]] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Create BALLASTING sheet showing stage-by-stage tank status and ballast operations.

    Args:
        workbook: xlsxwriter Workbook instance
        stage_results: Dict mapping stage names to calculation results
        tanks: Optional list of Tank objects (uses default if None)
        styles: Optional styles dict (creates if None)
    &#34;&#34;&#34;
    if not HAS_XLSXWRITER:
        print(&#34;[WARNING] xlsxwriter not available, skipping BALLASTING sheet&#34;)
        return

    if styles is None:
        styles = get_styles(workbook)

    # Get default tanks if not provided
    if tanks is None:
        tanks = get_default_tanks()

    # Get parameters
    if params is None:
        params = {}
    Tide_ref = params.get(
        &#34;Forecast_Tide_m&#34;, params.get(&#34;Tide_ref&#34;, 2.00)
    )  # Forecast tide height (CD)
    pump_rate_effective_tph = params.get(&#34;pump_rate_effective_tph&#34;, 100.00)

    # Create BALLASTING sheet
    ws = workbook.add_worksheet(&#34;BALLASTING&#34;)
    number_format = &#34;#,##0.00&#34;
    num_format = workbook.add_format({&#34;num_format&#34;: number_format})

    # Row 1: Title
    ws.write(
        0, 0, &#34;BALLASTING PLAN - Stage by Stage Tank Status&#34;, styles[&#34;title_format&#34;]
    )

    # Row 2: Input parameter 안내
    ws.write(1, 0, &#34;← Ballast transfer operations by stage&#34;, styles[&#34;normal_font&#34;])

    # Row 4: 섹션 제목
    ws.write(3, 0, &#34;Stage-by-Stage Ballast Tank Operations&#34;, styles[&#34;normal_font&#34;])

    # Row 5: 헤더
    # Base headers (columns 0-12)
    headers = [
        &#34;Stage&#34;,
        &#34;Tank&#34;,
        &#34;Group&#34;,
        &#34;x_from_mid_m&#34;,
        &#34;Capacity_t&#34;,
        &#34;Start_t&#34;,
        &#34;Transfer_t&#34;,
        &#34;End_t&#34;,
        &#34;Pump_Time_h&#34;,
        &#34;Status&#34;,
        &#34;Draft_FWD_m&#34;,
        &#34;Draft_AFT_m&#34;,
        &#34;Remarks&#34;,
    ]
    # Step-by-step headers (columns 13-20 for Step 1 and Step 2)
    # Step 1: columns 13-16 (N-O-P-Q)
    step_headers = [
        &#34;Step1_n&#34;,
        &#34;Step1_Transfer_t&#34;,
        &#34;Step1_Cumulative_t&#34;,
        &#34;Step1_Pump_Time_h&#34;,
    ]
    # Step 2: columns 17-20 (R-S-T-U)
    step_headers.extend(
        [
            &#34;Step2_n&#34;,
            &#34;Step2_Transfer_t&#34;,
            &#34;Step2_Cumulative_t&#34;,
            &#34;Step2_Pump_Time_h&#34;,
        ]
    )
    headers.extend(step_headers)
    for col_idx, header in enumerate(headers):
        ws.write(4, col_idx, header, styles[&#34;header_format&#34;])

    # Stage order (same as RORO_Stage_Scenarios)
    stages_order = [
        &#34;Stage 1&#34;,
        &#34;Stage 2&#34;,
        &#34;Stage 3&#34;,
        &#34;Stage 4&#34;,
        &#34;Stage 5&#34;,
        &#34;Stage 5_PreBallast&#34;,
        &#34;Stage 6A_Critical (Opt C)&#34;,
        &#34;Stage 6C_TotalMassOpt&#34;,
        &#34;Stage 6C&#34;,
        &#34;Stage 7&#34;,
    ]

    # Track cumulative ballast by tank
    tank_states: Dict[str, float] = {t.name: t.current_t for t in tanks}
    cumulative_ballast: Dict[str, float] = {t.name: 0.0 for t in tanks}

    # Track stage-by-stage ballast totals
    stage_ballast_totals: Dict[str, float] = {}
    for stage_name in stages_order:
        if stage_name in stage_results:
            stage_ballast_totals[stage_name] = stage_results[stage_name].get(
                &#34;Ballast_t&#34;, 0.0
            )
        else:
            stage_ballast_totals[stage_name] = 0.0

    # Calculate cumulative ballast
    running_total = 0.0
    for stage_name in stages_order:
        if stage_name in [&#34;Stage 1&#34;, &#34;Stage 7&#34;]:
            # Arrival/Departure - reset ballast
            running_total = 0.0
        else:
            running_total += stage_ballast_totals.get(stage_name, 0.0)
        cumulative_ballast[stage_name] = running_total

    # Write data rows
    row_idx = 5  # Start from row 6 (0-based index 5)

    # Track validation statistics
    validation_stats = {
        &#34;capacity_breaches&#34;: 0,  # Hard breaches: clamp required (End_t_raw outside bounds)
        &#34;capacity_limits_applied&#34;: 0,  # Soft limits: requested transfer limited to stay within bounds
        &#34;capacity_clamps&#34;: 0,  # Count of clamp events applied after calculation
        &#34;continuity_mismatches&#34;: 0,
        &#34;redistributions&#34;: 0,
        &#34;warnings&#34;: [],
    }

    # Track previous stage end states for continuity validation
    previous_stage_ends: Dict[str, Dict[str, float]] = (
        {}
    )  # stage_name -&gt; {tank_name: end_t}

    # Track redistributions per stage (for applying excess to other tanks)
    stage_redistributions: Dict[str, Dict[str, float]] = (
        {}
    )  # stage_name -&gt; {tank_name: additional_transfer}

    for stage_name in stages_order:
        stage_ballast = stage_ballast_totals.get(stage_name, 0.0)
        stage_pump_time = 0.0

        if stage_name in stage_results:
            stage_pump_time = stage_results[stage_name].get(&#34;Ballast_time_h&#34;, 0.0)

        # Distribute ballast to tanks based on group and priority
        # Strategy: Distribute to BOW tanks (FWB1, FWB2) for forward ballast
        # For pre-ballast stages, distribute to STERN tanks (FW2)

        # Determine ballast distribution strategy
        # For pre-ballast: Use STERN tanks (FW2) to reduce forward draft
        # For forward ballast: Use BOW tanks (FWB1, FWB2) to increase forward draft
        # For discharge: Use appropriate tanks based on trim requirements

        if stage_name == &#34;Stage 5_PreBallast&#34;:
            # Pre-ballast: Use STERN tanks (FW2) to reduce forward draft
            target_tanks = [
                t for t in tanks if t.group == &#34;STERN&#34; and t.use_flag == &#34;Y&#34;
            ]
        elif stage_ballast &gt; 0:
            # Forward ballast: Use BOW tanks (FWB1, FWB2) to increase forward draft
            target_tanks = [t for t in tanks if t.group == &#34;BOW&#34; and t.use_flag == &#34;Y&#34;]
        elif stage_ballast &lt; 0:
            # Discharge: Use FWD tanks (FWCARGO) to reduce forward draft
            target_tanks = [t for t in tanks if t.group == &#34;FWD&#34; and t.use_flag == &#34;Y&#34;]
        else:
            # No ballast change
            target_tanks = []

        # If no target tanks found but ballast is needed, use all available tanks
        if not target_tanks and abs(stage_ballast) &gt; 0.01:
            target_tanks = [t for t in tanks if t.use_flag == &#34;Y&#34;]

        # Get actual optimization result if available (tank_deltas from BallastOptimizer)
        tank_deltas = {}
        if stage_name in stage_results:
            tank_deltas = stage_results[stage_name].get(&#34;tank_deltas&#34;, {})

        # Use actual optimization results if available, otherwise use even distribution
        use_optimization = len(tank_deltas) &gt; 0

        # Distribute ballast evenly among target tanks (fallback if no optimization)
        num_targets = len(target_tanks) if target_tanks else 1
        ballast_per_tank = stage_ballast / num_targets if num_targets &gt; 0 else 0.0
        pump_time_per_tank = stage_pump_time / num_targets if num_targets &gt; 0 else 0.0

        # Get stage drafts for Effective Draft calculation
        stage_dfwd = 0.0
        stage_daft = 0.0
        if stage_name in stage_results:
            stage_dfwd = stage_results[stage_name].get(&#34;Dfwd_m&#34;, 0.0)
            stage_daft = stage_results[stage_name].get(&#34;Daft_m&#34;, 0.0)

        # Calculate step-by-step breakdown for this stage
        step_size_t = 50.0  # Each step = 50t
        num_steps = (
            max(1, int(math.ceil(abs(stage_ballast) / step_size_t)))
            if abs(stage_ballast) &gt; 0.01
            else 0
        )
        actual_step_size = abs(stage_ballast) / num_steps if num_steps &gt; 0 else 0.0

        # Write tank rows for this stage - show all tanks, not just target tanks
        tanks_to_show = tanks  # Show all tanks for visibility
        tank_row_index = 0  # Track which tank row we&#39;re on for this stage

        # Initialize redistribution dict for this stage
        stage_redistributions[stage_name] = {}

        for tank in tanks_to_show:
            # Calculate tank state for this stage with continuity validation
            if stage_name == &#34;Stage 1&#34;:
                # Reset to initial state
                start_t = tank.current_t
            else:
                # Use previous stage&#39;s end state
                start_t = tank_states.get(tank.name, tank.current_t)

                # Validate continuity with previous stage
                prev_stage_name = stages_order[stages_order.index(stage_name) - 1]
                if prev_stage_name in previous_stage_ends:
                    prev_end_t = previous_stage_ends[prev_stage_name].get(tank.name)
                    if prev_end_t is not None:
                        corrected_start, continuity_warnings = (
                            validate_stage_continuity(
                                stage_name, tank.name, start_t, prev_end_t
                            )
                        )
                        if continuity_warnings:
                            validation_stats[&#34;continuity_mismatches&#34;] += 1
                            validation_stats[&#34;warnings&#34;].extend(continuity_warnings)
                            start_t = corrected_start

            # Calculate transfer for this tank
            # Priority: Use actual optimization result if available
            if use_optimization and tank.name in tank_deltas:
                transfer_t = float(tank_deltas[tank.name])
                # Calculate pump time from actual transfer
                if abs(transfer_t) &gt; 0.01 and tank.pump_rate_tph &gt; 0:
                    pump_time_per_tank = abs(transfer_t) / tank.pump_rate_tph
                else:
                    pump_time_per_tank = 0.0
            elif tank in target_tanks:
                transfer_t = ballast_per_tank
            else:
                transfer_t = 0.0

            # Apply any redistributions from other tanks in this stage
            if tank.name in stage_redistributions.get(stage_name, {}):
                transfer_t += stage_redistributions[stage_name][tank.name]

            # Validate and correct transfer to ensure capacity limits
            original_transfer = transfer_t
            transfer_t, transfer_warnings = validate_and_correct_transfer(
                transfer_t, start_t, tank, stage_ballast, target_tanks
            )

            if transfer_warnings:
                validation_stats[&#34;warnings&#34;].extend(transfer_warnings)

                # Soft-limit accounting: requested transfer was limited due to capacity bounds
                if abs(transfer_t) &lt; abs(original_transfer):
                    validation_stats[&#34;capacity_limits_applied&#34;] += 1

                    # Attempt redistribution if transfer was limited
                    excess = abs(original_transfer) - abs(transfer_t)
                    if excess &gt; 0.01 and stage_ballast &gt; 0:
                        redistribution = redistribute_excess_ballast(
                            excess,
                            source_tank=tank,
                            available_tanks=target_tanks,
                            tank_states=tank_states,
                        )
                        if redistribution:
                            stage_redistributions.update(redistribution)
                            validation_stats[&#34;redistributions&#34;] += 1
                            validation_stats[&#34;warnings&#34;].append(
                                f&#34;Redistributed {excess:.2f}t from {tank.name} to other tanks: {redistribution}&#34;
                            )
                        else:
                            validation_stats[&#34;warnings&#34;].append(
                                f&#34;Redistribution skipped: no eligible tanks for {excess:.2f}t from {tank.name} in {stage_name}&#34;
                            )
            end_t_raw = start_t + transfer_t
            end_t = max(tank.min_t, min(end_t_raw, tank.max_t))

            # Hard-breach accounting: clamp required (End_t_raw outside bounds)
            tol = 0.01
            if abs(end_t - end_t_raw) &gt; tol:
                validation_stats[&#34;capacity_breaches&#34;] += 1
                validation_stats[&#34;capacity_clamps&#34;] += 1
                validation_stats[&#34;warnings&#34;].append(
                    f&#34;Hard capacity clamp: {tank.name} in {stage_name} &#34;
                    f&#34;(raw {end_t_raw:.2f}t -&gt; clamped {end_t:.2f}t, &#34;
                    f&#34;bounds [{tank.min_t:.2f}, {tank.max_t:.2f}]t)&#34;
                )

            # Sync Transfer_t so Excel always satisfies End_t = Start_t + Transfer_t
            transfer_t = end_t - start_t

            # Update tank state for next stage
            tank_states[tank.name] = end_t

            # Status check (NG only on hard clamp; CHECK on zero pump time with non-zero transfer)
            status = &#34;OK&#34; if abs(end_t - end_t_raw) &lt;= tol else &#34;NG&#34;
            if abs(transfer_t) &gt; 0.01 and abs(pump_time_per_tank) &lt; 0.01:
                status = &#34;CHECK&#34;
            status_format = styles[&#34;ok_fill&#34;] if status == &#34;OK&#34; else styles[&#34;ng_fill&#34;]

            # Get Excel row number (1-based) for formulas
            excel_row = row_idx + 1

            # Write row
            ws.write(row_idx, 0, stage_name, styles[&#34;normal_font&#34;])
            ws.write(row_idx, 1, tank.name, styles[&#34;normal_font&#34;])
            ws.write(row_idx, 2, tank.group or &#34;&#34;, styles[&#34;normal_font&#34;])
            ws.write(row_idx, 3, tank.x_from_mid_m, num_format)
            ws.write(row_idx, 4, tank.max_t, num_format)
            ws.write(row_idx, 5, start_t, num_format)

            # Transfer_t: Use value (can be manually adjusted)
            ws.write(row_idx, 6, transfer_t, num_format)

            # End_t: Excel formula = Start_t + Transfer_t
            # Start_t: col_idx=5 (F in Excel), Transfer_t: col_idx=6 (G in Excel)
            col_letter_start = col_idx_to_excel_letter(5)  # Start_t column
            col_letter_transfer = col_idx_to_excel_letter(6)  # Transfer_t column
            ws.write_formula(
                row_idx,
                7,
                f&#34;={col_letter_start}{excel_row}+{col_letter_transfer}{excel_row}&#34;,
                num_format,
            )

            # Pump_Time_h: Calculate based on transfer and pump rate
            if abs(transfer_t) &gt; 0.01:
                if pump_rate_effective_tph &gt; 0:
                    pump_time_val = abs(transfer_t) / pump_rate_effective_tph
                    ws.write(row_idx, 8, pump_time_val, num_format)
                elif tank.pump_rate_tph &gt; 0:
                    pump_time_val = abs(transfer_t) / tank.pump_rate_tph
                    ws.write(row_idx, 8, pump_time_val, num_format)
                else:
                    ws.write(row_idx, 8, 0.0, num_format)
            else:
                ws.write(row_idx, 8, 0.0, num_format)

            ws.write(row_idx, 9, status, status_format)

            # Draft_FWD_m: physical draft at FWD (do NOT add tide)
            ws.write(row_idx, 10, stage_dfwd, num_format)

            # Draft_AFT_m: physical draft at AFT (do NOT add tide)
            ws.write(row_idx, 11, stage_daft, num_format)

            # Remarks
            remarks = &#34;&#34;
            if abs(transfer_t) &gt; 0.01:
                if transfer_t &gt; 0:
                    remarks = f&#34;Fill {transfer_t:.2f}t&#34;
                else:
                    remarks = f&#34;Discharge {abs(transfer_t):.2f}t&#34;
            ws.write(row_idx, 12, remarks, styles[&#34;normal_font&#34;])

            # Add step-by-step breakdown in columns 13-20 (only for first tank row of each stage)
            # Step 1: columns 13-16 (N-O-P-Q)
            # Step 2: columns 17-20 (R-S-T-U)
            if tank_row_index == 0 and num_steps &gt; 0:
                cumulative_step = 0.0
                # Show max 2 steps per row (Step 1 and Step 2)
                max_steps_to_show = min(num_steps, 2)

                for step_n in range(1, max_steps_to_show + 1):
                    if step_n == num_steps:
                        step_transfer = abs(stage_ballast) - cumulative_step
                    else:
                        step_transfer = actual_step_size

                    cumulative_step += step_transfer
                    step_pump_time = (
                        step_transfer / pump_rate_effective_tph
                        if pump_rate_effective_tph &gt; 0
                        else 0.0
                    )

                    # Calculate column base for this step
                    # Step 1: column base = 13, Step 2: column base = 17
                    step_col_base = 13 + (step_n - 1) * 4

                    # Check if step fits within column range (N-U, columns 13-20)
                    # Last column for this step = step_col_base + 3 (4 columns per step)
                    if step_col_base + 3 &lt;= 20:  # Allow up to column U (index 20)
                        # Write step data: Step_n, Step_Transfer_t, Cumulative_t, Step_Pump_Time_h
                        ws.write(row_idx, step_col_base, step_n, styles[&#34;normal_font&#34;])
                        ws.write(
                            row_idx,
                            step_col_base + 1,
                            step_transfer if stage_ballast &gt; 0 else -step_transfer,
                            num_format,
                        )
                        ws.write(
                            row_idx,
                            step_col_base + 2,
                            cumulative_step if stage_ballast &gt; 0 else -cumulative_step,
                            num_format,
                        )
                        ws.write(row_idx, step_col_base + 3, step_pump_time, num_format)

                # If more than 2 steps, write total steps count in Remarks column
                if num_steps &gt; 2:
                    additional_remarks = f&#34; (Total {num_steps} steps)&#34;
                    updated_remarks = (
                        (remarks + additional_remarks)
                        if remarks
                        else additional_remarks
                    )
                    ws.write(row_idx, 12, updated_remarks, styles[&#34;normal_font&#34;])

            tank_row_index += 1
            row_idx += 1

        # Store end states for next stage continuity validation
        previous_stage_ends[stage_name] = {
            t.name: tank_states.get(t.name, t.current_t) for t in tanks
        }

        # Add empty row between stages for readability
        row_idx += 1

    # Set column widths
    ws.set_column(0, 0, 25)  # Stage
    ws.set_column(1, 1, 15)  # Tank
    ws.set_column(2, 2, 10)  # Group
    ws.set_column(3, 3, 15)  # x_from_mid_m
    ws.set_column(4, 4, 12)  # Capacity_t
    ws.set_column(5, 8, 12)  # Start_t, Transfer_t, End_t, Pump_Time_h
    ws.set_column(9, 9, 10)  # Status
    ws.set_column(10, 11, 15)  # Effective_FWD_m, Effective_AFT_m
    ws.set_column(12, 12, 20)  # Remarks
    # Step 1 columns (13-16): N-O-P-Q
    ws.set_column(13, 13, 10)  # Step1_n
    ws.set_column(14, 14, 15)  # Step1_Transfer_t
    ws.set_column(15, 15, 15)  # Step1_Cumulative_t
    ws.set_column(16, 16, 15)  # Step1_Pump_Time_h
    # Step 2 columns (17-20): R-S-T-U
    ws.set_column(17, 17, 10)  # Step2_n
    ws.set_column(18, 18, 15)  # Step2_Transfer_t
    ws.set_column(19, 19, 15)  # Step2_Cumulative_t
    ws.set_column(20, 20, 15)  # Step2_Pump_Time_h

    # Freeze panes at A6 (row 5, column 0)
    ws.freeze_panes(5, 0)

    # Add summary section at the end
    summary_row = row_idx + 2
    ws.write(summary_row, 0, &#34;Summary&#34;, styles[&#34;title_format&#34;])
    summary_row += 1
    ws.write(summary_row, 0, &#34;Total Ballast Operations:&#34;, styles[&#34;normal_font&#34;])
    ws.write(summary_row, 1, f&#34;{sum(stage_ballast_totals.values()):.2f} t&#34;, num_format)
    summary_row += 1
    ws.write(summary_row, 0, &#34;Total Pump Time:&#34;, styles[&#34;normal_font&#34;])
    total_pump_time = sum(
        stage_results.get(s, {}).get(&#34;Ballast_time_h&#34;, 0.0) for s in stages_order
    )
    ws.write(summary_row, 1, f&#34;{total_pump_time:.2f} h&#34;, num_format)

    # Add validation report section
    summary_row += 2
    ws.write(summary_row, 0, &#34;Validation Report&#34;, styles[&#34;title_format&#34;])
    summary_row += 1
    ws.write(summary_row, 0, &#34;Capacity Breaches:&#34;, styles[&#34;normal_font&#34;])
    capacity_status = &#34;PASS&#34; if validation_stats[&#34;capacity_breaches&#34;] == 0 else &#34;FAIL&#34;
    capacity_format = (
        styles[&#34;ok_fill&#34;]
        if validation_stats[&#34;capacity_breaches&#34;] == 0
        else styles[&#34;ng_fill&#34;]
    )
    ws.write(
        summary_row,
        1,
        f&#34;{validation_stats[&#39;capacity_breaches&#39;]} ({capacity_status})&#34;,
        capacity_format,
    )
    summary_row += 1
    ws.write(summary_row, 0, &#34;Capacity Limits Applied:&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        summary_row,
        1,
        f&#34;{validation_stats.get(&#39;capacity_limits_applied&#39;,0)} (INFO)&#34;,
        styles[&#34;normal_font&#34;],
    )
    summary_row += 1
    ws.write(summary_row, 0, &#34;Capacity Clamps Applied:&#34;, styles[&#34;normal_font&#34;])
    clamps_status = (
        &#34;PASS&#34; if validation_stats.get(&#34;capacity_clamps&#34;, 0) == 0 else &#34;FAIL&#34;
    )
    clamps_format = (
        styles[&#34;ok_fill&#34;]
        if validation_stats.get(&#34;capacity_clamps&#34;, 0) == 0
        else styles[&#34;ng_fill&#34;]
    )
    ws.write(
        summary_row,
        1,
        f&#34;{validation_stats.get(&#39;capacity_clamps&#39;,0)} ({clamps_status})&#34;,
        clamps_format,
    )
    summary_row += 1
    ws.write(summary_row, 0, &#34;Continuity Mismatches:&#34;, styles[&#34;normal_font&#34;])
    continuity_status = (
        &#34;PASS&#34; if validation_stats[&#34;continuity_mismatches&#34;] == 0 else &#34;FAIL&#34;
    )
    continuity_format = (
        styles[&#34;ok_fill&#34;]
        if validation_stats[&#34;continuity_mismatches&#34;] == 0
        else styles[&#34;ng_fill&#34;]
    )
    ws.write(
        summary_row,
        1,
        f&#34;{validation_stats[&#39;continuity_mismatches&#39;]} ({continuity_status})&#34;,
        continuity_format,
    )
    summary_row += 1
    ws.write(summary_row, 0, &#34;Redistributions:&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        summary_row, 1, f&#34;{validation_stats[&#39;redistributions&#39;]}&#34;, styles[&#34;normal_font&#34;]
    )

    # Print warnings if any
    if validation_stats[&#34;warnings&#34;]:
        summary_row += 2
        ws.write(summary_row, 0, &#34;Warnings:&#34;, styles[&#34;normal_font&#34;])
        summary_row += 1
        for warning in validation_stats[&#34;warnings&#34;][:10]:  # Limit to first 10 warnings
            ws.write(summary_row, 0, f&#34;- {warning}&#34;, styles[&#34;normal_font&#34;])
            summary_row += 1
        if len(validation_stats[&#34;warnings&#34;]) &gt; 10:
            ws.write(
                summary_row,
                0,
                f&#34;... and {len(validation_stats[&#39;warnings&#39;]) - 10} more warnings&#34;,
                styles[&#34;normal_font&#34;],
            )

    # Print validation summary to console
    if (
        validation_stats[&#34;capacity_breaches&#34;] &gt; 0
        or validation_stats[&#34;continuity_mismatches&#34;] &gt; 0
    ):
        print(
            f&#34;  [WARNING] Validation issues: {validation_stats[&#39;capacity_breaches&#39;]} capacity breaches, &#34;
            f&#34;{validation_stats[&#39;continuity_mismatches&#39;]} continuity mismatches&#34;
        )
    else:
        print(&#34;  [OK] Validation passed: 0 capacity breaches, 0 continuity mismatches&#34;)

    print(&#34;  [OK] BALLASTING sheet created&#34;)</code></pre>
</details>
<div class="desc"><p>Create BALLASTING sheet showing stage-by-stage tank status and ballast operations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>workbook</code></strong></dt>
<dd>xlsxwriter Workbook instance</dd>
<dt><strong><code>stage_results</code></strong></dt>
<dd>Dict mapping stage names to calculation results</dd>
<dt><strong><code>tanks</code></strong></dt>
<dd>Optional list of Tank objects (uses default if None)</dd>
<dt><strong><code>styles</code></strong></dt>
<dd>Optional styles dict (creates if None)</dd>
</dl></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.export_roro_stages_to_excel"><code class="name flex">
<span>def <span class="ident">export_roro_stages_to_excel</span></span>(<span>stage_results: Dict[str, Dict[str, Any]],<br>preballast_opt: float,<br>base_tmean: float,<br>base_disp: float,<br>output_path: Path = PosixPath('roro_stages.xlsx'),<br>params: Optional[Dict[str, Any]] = None,<br>tanks: Optional[List[<a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank">Tank</a>]] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_roro_stages_to_excel(
    stage_results: Dict[str, Dict[str, Any]],
    preballast_opt: float,
    base_tmean: float,
    base_disp: float,
    output_path: Path = Path(&#34;roro_stages.xlsx&#34;),
    params: Optional[Dict[str, Any]] = None,
    tanks: Optional[List[Tank]] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Export RORO stage results to Excel file with RORO_Stage_Scenarios sheet.
    Structure matches agi_tr_patched_v6_6.py create_roro_sheet format.

    Args:
        stage_results: Dict mapping stage names to calculation results
        preballast_opt: Optimized pre-ballast weight (t)
        base_tmean: Base mean draft (m)
        base_disp: Base displacement (t)
        output_path: Output Excel file path
        params: Optional parameters dict (MTC, LCF, LBP, D_vessel, TPC, pump_rate_effective_tph, etc.)
    &#34;&#34;&#34;
    if not HAS_XLSXWRITER:
        print(&#34;[WARNING] xlsxwriter not available, skipping Excel export&#34;)
        return

    workbook = xlsxwriter.Workbook(str(output_path))
    number_format = &#34;#,##0.00&#34;

    # Get styles
    styles = get_styles(workbook)

    # Default parameters
    if params is None:
        params = {}
    MTC = params.get(&#34;MTC&#34;, 34.00)
    LCF = params.get(&#34;LCF&#34;, 0.76)
    LBP = params.get(&#34;LBP&#34;, 60.302)
    D_vessel = params.get(&#34;D_vessel&#34;, 3.65)
    TPC = params.get(&#34;TPC&#34;, 8.00)
    pump_rate_effective_tph = params.get(&#34;pump_rate_effective_tph&#34;, 100.00)
    Tide_ref = params.get(
        &#34;Forecast_Tide_m&#34;, params.get(&#34;Tide_ref&#34;, 2.00)
    )  # Forecast tide height (CD)
    Trim_target_cm = params.get(&#34;Trim_target_cm&#34;, 240.0)
    X_Ballast = params.get(&#34;X_Ballast&#34;, fr_to_x(3.0))  # FW2 center at Fr 3.0

    # Create RORO_Stage_Scenarios sheet
    ws = workbook.add_worksheet(&#34;RORO_Stage_Scenarios&#34;)

    # Row 1: Title
    ws.write(
        0,
        0,
        &#34;RORO Stage Scenarios – Option C (Target 240cm Safe Margin)&#34;,
        styles[&#34;title_format&#34;],
    )

    # Row 2: Input parameter 안내
    ws.write(1, 2, &#34;← Input parameter(yellow cellls only)&#34;, styles[&#34;normal_font&#34;])

    # Row 4: 섹션 제목
    ws.write(
        3,
        0,
        &#34;1.Critical Stage Verification: Trim &amp; Draft Status Sequence&#34;,
        styles[&#34;normal_font&#34;],
    )
    ws.write(3, 5, &#34;2. Stage Sequence Table&#34;, styles[&#34;normal_font&#34;])

    # Row 5: 헤더
    headers_row5 = [
        (&#34;A&#34;, &#34;Parameter&#34;),
        (&#34;B&#34;, &#34;Value&#34;),
        (&#34;C&#34;, &#34;Unit&#34;),
        (&#34;D&#34;, &#34;REMARK&#34;),
        (&#34;F&#34;, &#34;Stage&#34;),
        (&#34;G&#34;, &#34;EXPLANATION&#34;),
        (&#34;O&#34;, &#34;Fwd Draft (m)&#34;),
        (&#34;P&#34;, &#34;Freeboard (m)&#34;),
        (&#34;Q&#34;, &#34;Aft Draft (m)&#34;),
        (&#34;R&#34;, &#34;Status Assessment&#34;),
    ]
    col_map = {
        &#34;A&#34;: 0,
        &#34;B&#34;: 1,
        &#34;C&#34;: 2,
        &#34;D&#34;: 3,
        &#34;E&#34;: 4,
        &#34;F&#34;: 5,
        &#34;G&#34;: 6,
        &#34;H&#34;: 7,
        &#34;I&#34;: 8,
        &#34;J&#34;: 9,
        &#34;K&#34;: 10,
        &#34;L&#34;: 11,
        &#34;M&#34;: 12,
        &#34;N&#34;: 13,
        &#34;O&#34;: 14,
        &#34;P&#34;: 15,
        &#34;Q&#34;: 16,
        &#34;R&#34;: 17,
    }
    for letter, header in headers_row5:
        col_idx = col_map.get(letter, 0)
        ws.write(4, col_idx, header, styles[&#34;header_format&#34;])

    # Row 6-15: 파라미터 섹션
    num_format = workbook.add_format({&#34;num_format&#34;: number_format})
    input_num_format = workbook.add_format(
        {&#34;num_format&#34;: number_format, &#34;bg_color&#34;: &#34;#FFFF99&#34;}
    )

    # Stage explanations
    explanations = {
        &#34;Stage 1&#34;: &#34;Arrival lightship condition. Baseline drafts, trim, and GM are checked before any cargo loading or ballast change.&#34;,
        &#34;Stage 2&#34;: &#34;TR1 roll-on start – first axle on the ramp. Initial bow-down trim response is checked against allowable draft and freeboard limits.&#34;,
        &#34;Stage 3&#34;: &#34;TR1 mid-ramp – transformer COG on the ramp. Progressive bow-down trim is monitored to remain within the allowable envelope.&#34;,
        &#34;Stage 4&#34;: &#34;TR1 fully on deck. Weight is completely transferred from ramp to vessel deck; deck loading, ramp condition, drafts, and trim are verified.&#34;,
        &#34;Stage 5&#34;: &#34;TR1 secured at final aft stowage position (around Fr.42). New reference condition with TR1 only on board, used as the basis for D-1 stern pre-ballasting using FW2 (Fr.0–6, aft).&#34;,
        &#34;Stage 5_PreBallast&#34;: (
            &#34;Pre-ballast condition with TR1 only on board (D-1, using shore water). &#34;
            &#34;An intentional stern trim is set using the aft FW2 fresh water tanks (Fr.0–6, AFT, Ballast CG near FR 3.0) &#34;
            &#34;so that the bow-down trimming moment of TR2 at ramp entry is counterbalanced and the forward draft remains within the 2.70 m AGI limit &#34;
            &#34;without any major dynamic ballasting during the critical RORO operation on D-day.&#34;
        ),
        &#34;Stage 6A_Critical (Opt C)&#34;: &#34;Critical TR2 ramp-entry condition on D-day with the D-1 stern pre-ballast (FW2, Fr.0–6) kept fixed. This stage is used to check worst-case forward draft against the 2.70 m limit, trim envelope, GM criteria, and ramp/linkspan clearance under combined TR1+TR2 loading.&#34;,
        &#34;Stage 6C_TotalMassOpt&#34;: &#39;Alternative &#34;total mass optimized&#34; final condition with TR1 and TR2 on deck and higher combined cargo+ballast weight. Sensitivity case to assess maximum displacement effects on drafts, trim, GM and freeboard.&#39;,
        &#34;Stage 6C&#34;: &#34;Planned final stowage condition with TR1 and TR2 secured on deck and ballast as per departure plan. Main departure case for checking GM, trim and freeboard criteria.&#34;,
        &#34;Stage 7&#34;: &#34;Post-operation lightship/reference condition after cargo is discharged. Used to reconfirm hydrostatic characteristics and GM consistency against Stage 1.&#34;,
    }

    stages_list = [
        &#34;Stage 1&#34;,
        &#34;Stage 2&#34;,
        &#34;Stage 3&#34;,
        &#34;Stage 4&#34;,
        &#34;Stage 5&#34;,
        &#34;Stage 5_PreBallast&#34;,
        &#34;Stage 6A_Critical (Opt C)&#34;,
        &#34;Stage 6C_TotalMassOpt&#34;,
        &#34;Stage 6C&#34;,
        &#34;Stage 7&#34;,
    ]

    # A6: Tmean_baseline
    ws.write(5, 0, &#34;Tmean_baseline&#34;, styles[&#34;normal_font&#34;])
    ws.write(5, 1, base_tmean, input_num_format)
    ws.write(5, 2, &#34;m&#34;, styles[&#34;normal_font&#34;])
    ws.write(5, 3, &#34;Baseline mean draft (from hydro table)&#34;, styles[&#34;normal_font&#34;])
    ws.write(5, 5, stages_list[0], styles[&#34;normal_font&#34;])
    if stages_list[0] in explanations:
        ws.write(5, 6, explanations[stages_list[0]], styles[&#34;input_fill&#34;])

    # A7: Forecast_Tide_m (Chart Datum)
    ws.write(6, 0, &#34;Forecast_Tide_m&#34;, styles[&#34;normal_font&#34;])
    ws.write(6, 1, Tide_ref, input_num_format)
    ws.write(6, 2, &#34;m&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        6,
        3,
        &#34;Forecast tide height (Chart Datum) – source: official tide table (station/datum/TZ)&#34;,
        styles[&#34;normal_font&#34;],
    )
    ws.write(
        6, 5, stages_list[1] if len(stages_list) &gt; 1 else &#34;&#34;, styles[&#34;normal_font&#34;]
    )
    if len(stages_list) &gt; 1 and stages_list[1] in explanations:
        ws.write(6, 6, explanations[stages_list[1]], styles[&#34;input_fill&#34;])

    # A8: Trim_target_cm
    ws.write(7, 0, &#34;Trim_target_cm&#34;, styles[&#34;normal_font&#34;])
    ws.write(7, 1, Trim_target_cm, input_num_format)
    ws.write(7, 2, &#34;cm&#34;, styles[&#34;normal_font&#34;])
    ws.write(7, 3, &#34;Target trim (bow down = negative)&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        7, 5, stages_list[2] if len(stages_list) &gt; 2 else &#34;&#34;, styles[&#34;normal_font&#34;]
    )
    if len(stages_list) &gt; 2 and stages_list[2] in explanations:
        ws.write(7, 6, explanations[stages_list[2]], styles[&#34;input_fill&#34;])

    # A9: MTC
    ws.write(8, 0, &#34;MTC&#34;, styles[&#34;normal_font&#34;])
    ws.write(8, 1, MTC, input_num_format)
    ws.write(8, 2, &#34;t·m/cm&#34;, styles[&#34;normal_font&#34;])
    ws.write(8, 3, &#34;Moment to change trim 1cm&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        8, 5, stages_list[3] if len(stages_list) &gt; 3 else &#34;&#34;, styles[&#34;normal_font&#34;]
    )
    if len(stages_list) &gt; 3 and stages_list[3] in explanations:
        ws.write(8, 6, explanations[stages_list[3]], styles[&#34;input_fill&#34;])

    # A10: LCF
    ws.write(9, 0, &#34;LCF&#34;, styles[&#34;normal_font&#34;])
    ws.write(9, 1, LCF, input_num_format)
    ws.write(9, 2, &#34;m&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        9,
        3,
        &#34;Longitudinal center of flotation (from midship, aft=+)&#34;,
        styles[&#34;normal_font&#34;],
    )
    ws.write(
        9, 5, stages_list[4] if len(stages_list) &gt; 4 else &#34;&#34;, styles[&#34;normal_font&#34;]
    )
    if len(stages_list) &gt; 4 and stages_list[4] in explanations:
        ws.write(9, 6, explanations[stages_list[4]], styles[&#34;input_fill&#34;])

    # A11: D_vessel
    ws.write(10, 0, &#34;D_vessel&#34;, styles[&#34;normal_font&#34;])
    ws.write(10, 1, D_vessel, input_num_format)
    ws.write(10, 2, &#34;m&#34;, styles[&#34;normal_font&#34;])
    ws.write(10, 3, &#34;Deck elevation (CD)&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        10, 5, stages_list[5] if len(stages_list) &gt; 5 else &#34;&#34;, styles[&#34;normal_font&#34;]
    )
    if len(stages_list) &gt; 5 and stages_list[5] in explanations:
        ws.write(10, 6, explanations[stages_list[5]], styles[&#34;input_fill&#34;])

    # A12: TPC
    ws.write(11, 0, &#34;TPC&#34;, styles[&#34;normal_font&#34;])
    ws.write(11, 1, TPC, input_num_format)
    ws.write(11, 2, &#34;t/cm&#34;, styles[&#34;normal_font&#34;])
    ws.write(11, 3, &#34;Tons per centimeter immersion&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        11, 5, stages_list[6] if len(stages_list) &gt; 6 else &#34;&#34;, styles[&#34;normal_font&#34;]
    )
    if len(stages_list) &gt; 6 and stages_list[6] in explanations:
        ws.write(11, 6, explanations[stages_list[6]], styles[&#34;input_fill&#34;])

    # A13: pump_rate_effective_tph
    ws.write(12, 0, &#34;pump_rate_effective_tph&#34;, styles[&#34;normal_font&#34;])
    ws.write(12, 1, pump_rate_effective_tph, input_num_format)
    ws.write(12, 2, &#34;t/h&#34;, styles[&#34;normal_font&#34;])
    ws.write(12, 3, &#34;Effective ballast pump rate&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        12, 5, stages_list[7] if len(stages_list) &gt; 7 else &#34;&#34;, styles[&#34;normal_font&#34;]
    )
    if len(stages_list) &gt; 7 and stages_list[7] in explanations:
        ws.write(12, 6, explanations[stages_list[7]], styles[&#34;input_fill&#34;])

    # A14: X_Ballast
    ws.write(13, 0, &#34;X_Ballast&#34;, styles[&#34;normal_font&#34;])
    ws.write(13, 1, X_Ballast, input_num_format)
    ws.write(13, 2, &#34;m&#34;, styles[&#34;normal_font&#34;])
    ws.write(13, 3, &#34;Ballast CG x from midship (aft=+)&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        13, 5, stages_list[8] if len(stages_list) &gt; 8 else &#34;&#34;, styles[&#34;normal_font&#34;]
    )
    if len(stages_list) &gt; 8 and stages_list[8] in explanations:
        ws.write(13, 6, explanations[stages_list[8]], styles[&#34;input_fill&#34;])

    # A15: Lpp
    ws.write(14, 0, &#34;Lpp&#34;, styles[&#34;normal_font&#34;])
    ws.write(14, 1, LBP, input_num_format)
    ws.write(14, 2, &#34;m&#34;, styles[&#34;normal_font&#34;])
    ws.write(14, 3, &#34;Length between perpendiculars&#34;, styles[&#34;normal_font&#34;])
    ws.write(
        14, 5, stages_list[9] if len(stages_list) &gt; 9 else &#34;&#34;, styles[&#34;normal_font&#34;]
    )
    if len(stages_list) &gt; 9 and stages_list[9] in explanations:
        ws.write(14, 6, explanations[stages_list[9]], styles[&#34;input_fill&#34;])

    # Row 17: Ballast Water Optimization Matrix 제목
    ws.write(16, 0, &#34;Ballast Water Optimization Matrix&#34;, styles[&#34;title_format&#34;])

    # Row 18: Stage table 헤더 (21개 컬럼)
    stage_headers = [
        &#34;Stage&#34;,
        &#34;W_stage_t&#34;,
        &#34;Fr_stage&#34;,
        &#34;x_stage_m&#34;,
        &#34;TM (t·m)&#34;,
        &#34;Trim_cm&#34;,
        &#34;FWD_precise_m&#34;,
        &#34;AFT_precise_m&#34;,
        &#34;ΔTM_cm_tm&#34;,
        &#34;Lever_arm_m&#34;,
        &#34;Ballast_t_calc&#34;,
        &#34;Ballast_time_h_calc&#34;,
        &#34;Ballast_t&#34;,
        &#34;Ballast_time_h&#34;,
        &#34;Trim_Check&#34;,
        &#34;Dfwd_m&#34;,
        &#34;Daft_m&#34;,
        &#34;Trim_target_stage_cm&#34;,
        &#34;FWD_DeckElev_CD_m&#34;,
        &#34;AFT_DeckElev_CD_m&#34;,
        &#34;Difference&#34;,
    ]
    for col_idx, header in enumerate(stage_headers):
        ws.write(17, col_idx, header, styles[&#34;header_format&#34;])

    # Row 19+: Stage 데이터
    stages_order = [
        &#34;Stage 1&#34;,
        &#34;Stage 2&#34;,
        &#34;Stage 3&#34;,
        &#34;Stage 4&#34;,
        &#34;Stage 5&#34;,
        &#34;Stage 5_PreBallast&#34;,
        &#34;Stage 6A_Critical (Opt C)&#34;,
        &#34;Stage 6C_TotalMassOpt&#34;,
        &#34;Stage 6C&#34;,
        &#34;Stage 7&#34;,
    ]

    first_data_row = 18  # Row 19 (0-based index 18)
    for row_idx, stage_name in enumerate(stages_order, start=first_data_row):
        if stage_name not in stage_results:
            continue

        res = stage_results[stage_name]

        # Stage
        ws.write(row_idx, 0, stage_name, styles[&#34;normal_font&#34;])

        # W_stage_t
        ws.write(row_idx, 1, res.get(&#34;W_stage_t&#34;, 0.0), num_format)

        # Fr_stage (calculate from x_stage_m)
        x_stage = res.get(&#34;x_stage_m&#34;, 0.0)
        fr_stage = x_to_fr(x_stage) if abs(x_stage) &gt; 0.01 else 0.0
        ws.write(row_idx, 2, fr_stage, num_format)

        # x_stage_m
        ws.write(row_idx, 3, x_stage, num_format)

        # TM (t·m)
        tm_tm = res.get(&#34;TM_LCF_tm&#34;, res.get(&#34;TM_tm&#34;, 0.0))
        ws.write(row_idx, 4, tm_tm, num_format)

        # Trim_cm
        trim_cm = res.get(&#34;Trim_cm&#34;, 0.0)
        ws.write(row_idx, 5, trim_cm, num_format)

        # FWD_precise_m
        dfwd_m = res.get(&#34;Dfwd_m&#34;, 0.0)
        ws.write(row_idx, 6, dfwd_m, num_format)

        # AFT_precise_m
        daft_m = res.get(&#34;Daft_m&#34;, 0.0)
        ws.write(row_idx, 7, daft_m, num_format)

        # ΔTM_cm_tm (trim change moment)
        dtm_cm_tm = res.get(&#34;ΔTM_cm_tm&#34;, 0.0)
        ws.write(row_idx, 8, dtm_cm_tm, num_format)

        # Lever_arm_m
        lever_arm = res.get(&#34;Lever_arm_m&#34;, X_Ballast - LCF)
        ws.write(row_idx, 9, lever_arm, num_format)

        # Ballast_t_calc
        ballast_t_calc = res.get(&#34;Ballast_t_calc&#34;, res.get(&#34;Ballast_t&#34;, 0.0))
        ws.write(row_idx, 10, ballast_t_calc, num_format)

        # Ballast_time_h_calc
        ballast_time_h_calc = res.get(
            &#34;Ballast_time_h_calc&#34;, res.get(&#34;Ballast_time_h&#34;, 0.0)
        )
        ws.write(row_idx, 11, ballast_time_h_calc, num_format)

        # Ballast_t
        ballast_t = res.get(&#34;Ballast_t&#34;, 0.0)
        ws.write(row_idx, 12, ballast_t, num_format)

        # Ballast_time_h
        ballast_time_h = res.get(&#34;Ballast_time_h&#34;, 0.0)
        ws.write(row_idx, 13, ballast_time_h, num_format)

        # Trim_Check
        trim_check = res.get(
            &#34;Trim_Check&#34;, &#34;OK&#34; if abs(trim_cm) &lt;= abs(Trim_target_cm) else &#34;NG&#34;
        )
        trim_check_format = (
            styles[&#34;ok_fill&#34;] if trim_check == &#34;OK&#34; else styles[&#34;ng_fill&#34;]
        )
        ws.write(row_idx, 14, trim_check, trim_check_format)

        # Dfwd_m
        ws.write(row_idx, 15, dfwd_m, num_format)

        # Daft_m
        ws.write(row_idx, 16, daft_m, num_format)

        # Trim_target_stage_cm
        trim_target_stage = res.get(&#34;Trim_target_stage_cm&#34;, Trim_target_cm)
        ws.write(row_idx, 17, trim_target_stage, num_format)

        # FWD_DeckElev_CD_m (D_vessel - Dfwd_m + Tide_ref)
        fwd_deck_elev = D_vessel - dfwd_m + Tide_ref
        ws.write(row_idx, 18, fwd_deck_elev, num_format)

        # AFT_DeckElev_CD_m (D_vessel - Daft_m + Tide_ref)
        aft_deck_elev = D_vessel - daft_m + Tide_ref
        ws.write(row_idx, 19, aft_deck_elev, num_format)

        # Difference
        difference = res.get(&#34;Difference&#34;, fwd_deck_elev - aft_deck_elev)
        ws.write(row_idx, 20, difference, num_format)

        # Status Assessment (Column R, index 17) - Fwd Draft vs 2.70m
        fwd_limit = 2.70
        vs_270 = &#34;OK&#34; if dfwd_m &lt;= fwd_limit else &#34;NG&#34;
        status_format = styles[&#34;ok_fill&#34;] if vs_270 == &#34;OK&#34; else styles[&#34;ng_fill&#34;]
        ws.write(row_idx, col_map[&#34;R&#34;], vs_270, status_format)

    # Set column widths
    ws.set_column(0, 0, 25)  # Stage
    ws.set_column(1, 20, 12)  # Other columns
    ws.set_column(6, 6, 15)  # EXPLANATION column wider

    # Freeze panes at G2 (column F, row 1)
    ws.freeze_panes(1, 6)

    # Extend with Captain Requirement columns (U-AE)
    extend_roro_captain_req(
        ws,
        workbook,
        first_data_row,
        len(stages_order),
        styles,
        num_format,
        D_vessel,
        TPC,
        pump_rate_effective_tph,
        Trim_target_cm,
    )

    # Extend with Structural/Option 1 columns (AK-BB)
    extend_roro_structural_opt1(
        ws, workbook, first_data_row, len(stages_order), styles, num_format
    )

    # Create BALLASTING sheet
    create_ballasting_sheet(
        workbook=workbook,
        stage_results=stage_results,
        tanks=tanks,  # Use provided tanks or default
        styles=styles,
        params=params,
    )

    workbook.close()
    print(f&#34;[INFO] RORO Excel file created: {output_path}&#34;)</code></pre>
</details>
<div class="desc"><p>Export RORO stage results to Excel file with RORO_Stage_Scenarios sheet.
Structure matches agi_tr_patched_v6_6.py create_roro_sheet format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stage_results</code></strong></dt>
<dd>Dict mapping stage names to calculation results</dd>
<dt><strong><code>preballast_opt</code></strong></dt>
<dd>Optimized pre-ballast weight (t)</dd>
<dt><strong><code>base_tmean</code></strong></dt>
<dd>Base mean draft (m)</dd>
<dt><strong><code>base_disp</code></strong></dt>
<dd>Base displacement (t)</dd>
<dt><strong><code>output_path</code></strong></dt>
<dd>Output Excel file path</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Optional parameters dict (MTC, LCF, LBP, D_vessel, TPC, pump_rate_effective_tph, etc.)</dd>
</dl></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.export_to_excel"><code class="name flex">
<span>def <span class="ident">export_to_excel</span></span>(<span>plan_df: pd.DataFrame,<br>summary_df: pd.DataFrame,<br>tank_log_df: Optional[pd.DataFrame] = None,<br>bwrb_log_df: Optional[pd.DataFrame] = None,<br>output_path: Path = PosixPath('ballast_plan.xlsx')) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_to_excel(
    plan_df: pd.DataFrame,
    summary_df: pd.DataFrame,
    tank_log_df: Optional[pd.DataFrame] = None,
    bwrb_log_df: Optional[pd.DataFrame] = None,
    output_path: Path = Path(&#34;ballast_plan.xlsx&#34;),
) -&gt; None:
    &#34;&#34;&#34;Export all results to a formatted Excel file with multiple sheets.&#34;&#34;&#34;
    if not HAS_XLSXWRITER:
        raise ImportError(
            &#34;xlsxwriter is required for Excel export. Install with: pip install xlsxwriter&#34;
        )

    workbook = xlsxwriter.Workbook(str(output_path))

    # Define formats
    header_format = workbook.add_format(
        {
            &#34;bold&#34;: True,
            &#34;bg_color&#34;: &#34;#366092&#34;,
            &#34;font_color&#34;: &#34;white&#34;,
            &#34;border&#34;: 1,
            &#34;align&#34;: &#34;center&#34;,
            &#34;valign&#34;: &#34;vcenter&#34;,
        }
    )

    number_format = workbook.add_format({&#34;num_format&#34;: &#34;#,##0.00&#34;})
    percent_format = workbook.add_format({&#34;num_format&#34;: &#34;0.0%&#34;})
    warning_format = workbook.add_format(
        {&#34;bg_color&#34;: &#34;#FFC7CE&#34;, &#34;font_color&#34;: &#34;#9C0006&#34;}
    )
    ok_format = workbook.add_format({&#34;bg_color&#34;: &#34;#C6EFCE&#34;, &#34;font_color&#34;: &#34;#006100&#34;})

    # Sheet 1: Plan
    if not plan_df.empty:
        ws_plan = workbook.add_worksheet(&#34;Plan&#34;)
        for col_num, col_name in enumerate(plan_df.columns):
            ws_plan.write(0, col_num, col_name, header_format)
            # Auto-adjust column width
            max_len = max(
                len(str(col_name)), plan_df[col_name].astype(str).str.len().max()
            )
            ws_plan.set_column(col_num, col_num, min(max_len + 2, 50))

        for row_num, (_, row) in enumerate(plan_df.iterrows(), start=1):
            for col_num, col_name in enumerate(plan_df.columns):
                value = row[col_name]
                if isinstance(value, (int, float)):
                    ws_plan.write(row_num, col_num, value, number_format)
                else:
                    ws_plan.write(row_num, col_num, value)

    # Sheet 2: Summary
    if not summary_df.empty:
        ws_summary = workbook.add_worksheet(&#34;Summary&#34;)
        for col_num, col_name in enumerate(summary_df.columns):
            ws_summary.write(0, col_num, col_name, header_format)
            ws_summary.set_column(col_num, col_num, max(len(str(col_name)) + 2, 15))

        for row_num, (_, row) in enumerate(summary_df.iterrows(), start=1):
            for col_num, col_name in enumerate(summary_df.columns):
                value = row[col_name]
                # Check for warnings or compliance issues
                fmt = number_format
                if col_name == &#34;dfwd_new_m&#34; and isinstance(value, (int, float)):
                    if value &gt; VesselParams.MAX_FWD_DRAFT_OPS:
                        fmt = warning_format
                    elif value &gt;= VesselParams.MIN_DRAFT:
                        fmt = ok_format
                elif col_name == &#34;daft_new_m&#34; and isinstance(value, (int, float)):
                    if value &gt; VesselParams.MAX_AFT_DRAFT_OPS:
                        fmt = warning_format
                    elif value &gt;= VesselParams.MIN_DRAFT:
                        fmt = ok_format

                # Handle dict/list types (convert to string)
                if isinstance(value, (dict, list)):
                    value = str(value)

                if isinstance(value, (int, float)):
                    ws_summary.write(row_num, col_num, value, fmt)
                else:
                    ws_summary.write(row_num, col_num, str(value))

    # Sheet 3: Tank Log
    if tank_log_df is not None and not tank_log_df.empty:
        ws_tank = workbook.add_worksheet(&#34;Tank Log&#34;)
        for col_num, col_name in enumerate(tank_log_df.columns):
            ws_tank.write(0, col_num, col_name, header_format)
            ws_tank.set_column(col_num, col_num, max(len(str(col_name)) + 2, 12))

        for row_num, (_, row) in enumerate(tank_log_df.iterrows(), start=1):
            for col_num, col_name in enumerate(tank_log_df.columns):
                value = row[col_name]
                if isinstance(value, (int, float)):
                    ws_tank.write(row_num, col_num, value, number_format)
                else:
                    ws_tank.write(row_num, col_num, value)

    # Sheet 4: BWRB Log
    if bwrb_log_df is not None and not bwrb_log_df.empty:
        ws_bwrb = workbook.add_worksheet(&#34;BWRB Log&#34;)
        for col_num, col_name in enumerate(bwrb_log_df.columns):
            ws_bwrb.write(0, col_num, col_name, header_format)
            ws_bwrb.set_column(col_num, col_num, max(len(str(col_name)) + 2, 15))

        for row_num, (_, row) in enumerate(bwrb_log_df.iterrows(), start=1):
            for col_num, col_name in enumerate(bwrb_log_df.columns):
                value = row[col_name]
                if isinstance(value, (int, float)):
                    ws_bwrb.write(row_num, col_num, value, number_format)
                else:
                    ws_bwrb.write(row_num, col_num, value)

    # Sheet 5: Charts
    if (
        not summary_df.empty
        and &#34;dfwd_new_m&#34; in summary_df.columns
        and &#34;daft_new_m&#34; in summary_df.columns
    ):
        ws_charts = workbook.add_worksheet(&#34;Charts&#34;)

        # Draft comparison chart
        chart1 = workbook.add_chart({&#34;type&#34;: &#34;line&#34;})
        fwd_col = summary_df.columns.get_loc(&#34;dfwd_new_m&#34;)
        aft_col = summary_df.columns.get_loc(&#34;daft_new_m&#34;)
        num_rows = len(summary_df)

        chart1.add_series(
            {
                &#34;name&#34;: &#34;FWD Draft&#34;,
                &#34;categories&#34;: (
                    [&#34;Summary&#34;, 0, 0, num_rows, 0]
                    if &#34;Stage&#34; in summary_df.columns
                    else None
                ),
                &#34;values&#34;: [&#34;Summary&#34;, 1, fwd_col, num_rows, fwd_col],
            }
        )
        chart1.add_series(
            {
                &#34;name&#34;: &#34;AFT Draft&#34;,
                &#34;values&#34;: [&#34;Summary&#34;, 1, aft_col, num_rows, aft_col],
            }
        )
        chart1.set_title({&#34;name&#34;: &#34;Draft Comparison&#34;})
        chart1.set_x_axis(
            {&#34;name&#34;: &#34;Stage&#34; if &#34;Stage&#34; in summary_df.columns else &#34;Index&#34;}
        )
        chart1.set_y_axis({&#34;name&#34;: &#34;Draft (m)&#34;})
        chart1.set_size({&#34;width&#34;: 720, &#34;height&#34;: 480})
        ws_charts.insert_chart(&#34;B2&#34;, chart1)

        # Tank usage chart (if tank log available)
        if (
            tank_log_df is not None
            and not tank_log_df.empty
            and &#34;Δt_t&#34; in tank_log_df.columns
        ):
            chart2 = workbook.add_chart({&#34;type&#34;: &#34;column&#34;})
            # Get top 10 tanks by absolute delta
            top_tanks = tank_log_df.reindex(
                tank_log_df[&#34;Δt_t&#34;].abs().nlargest(10).index
            )
            tank_col = tank_log_df.columns.get_loc(&#34;Tank&#34;)
            delta_col = tank_log_df.columns.get_loc(&#34;Δt_t&#34;)
            num_tanks = len(top_tanks)

            chart2.add_series(
                {
                    &#34;name&#34;: &#34;Weight Change&#34;,
                    &#34;categories&#34;: [&#34;Tank Log&#34;, 1, tank_col, num_tanks, tank_col],
                    &#34;values&#34;: [&#34;Tank Log&#34;, 1, delta_col, num_tanks, delta_col],
                }
            )
            chart2.set_title({&#34;name&#34;: &#34;Top 10 Tank Weight Changes&#34;})
            chart2.set_x_axis({&#34;name&#34;: &#34;Tank&#34;})
            chart2.set_y_axis({&#34;name&#34;: &#34;Weight Change (t)&#34;})
            chart2.set_size({&#34;width&#34;: 720, &#34;height&#34;: 480})
            ws_charts.insert_chart(&#34;B30&#34;, chart2)

    workbook.close()</code></pre>
</details>
<div class="desc"><p>Export all results to a formatted Excel file with multiple sheets.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.extend_roro_captain_req"><code class="name flex">
<span>def <span class="ident">extend_roro_captain_req</span></span>(<span>ws: Any,<br>workbook: Any,<br>first_data_row: int,<br>num_stages: int,<br>styles: Dict[str, Any],<br>num_format: Any,<br>D_vessel: float,<br>TPC: float,<br>pump_rate_effective_tph: float,<br>Trim_target_cm: float) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_roro_captain_req(
    ws: Any,
    workbook: Any,
    first_data_row: int,
    num_stages: int,
    styles: Dict[str, Any],
    num_format: Any,
    D_vessel: float,
    TPC: float,
    pump_rate_effective_tph: float,
    Trim_target_cm: float,
) -&gt; None:
    &#34;&#34;&#34;
    Add Captain Requirement columns (U-AE) to RORO_Stage_Scenarios sheet.

    Columns:
    - U(21): GM(m) - from stage_results
    - V(22): Fwd Draft(m) - Dfwd_m copy
    - W(23): vs 2.70m - Fwd ≤ 2.70m check
    - X(24): De-ballast Qty(t) - Ballast_t
    - Y(25): Timing - manual input
    - Z(26): Phys_Freeboard_m - D_vessel - Dfwd_m
    - AA(27): Clearance_Check - optional
    - AB(28): GM_calc - GM copy
    - AC(29): GM_Check - GM ≥ GM_target check
    - AD(30): Disp_total_t - Total displacement
    - AE(31): Vent_Time_h - De-ballast qty / pump rate
    &#34;&#34;&#34;
    # Header row (Row 18, 0-based index 17)
    header_row = 17

    captain_cols = [
        &#34;GM(m)&#34;,  # U(21)
        &#34;Fwd Draft(m)&#34;,  # V(22)
        &#34;vs 2.70m+Tide&#34;,  # W(23)
        &#34;De-ballast Qty(t)&#34;,  # X(24)
        &#34;Timing&#34;,  # Y(25)
        &#34;Phys_Freeboard_m&#34;,  # Z(26)
        &#34;Clearance_Check&#34;,  # AA(27)
        &#34;GM_calc&#34;,  # AB(28)
        &#34;GM_Check&#34;,  # AC(29)
        &#34;Disp_total_t&#34;,  # AD(30)
        &#34;Vent_Time_h&#34;,  # AE(31)
    ]

    start_col = 21  # U column (0-based index 21)

    # Write headers
    for i, header in enumerate(captain_cols):
        col_idx = start_col + i
        ws.write(header_row, col_idx, header, styles[&#34;header_format&#34;])

    # Write data for each stage
    # Define column indices for reference
    col_dfwd = 15  # Dfwd_m column (P in Excel)
    col_daft = 16  # Daft_m column (Q in Excel)
    col_ballast_t = 12  # Ballast_t column (M in Excel)
    col_w_stage = 1  # W_stage_t column (B in Excel)
    col_gm = 21  # GM(m) column (U in Excel)
    col_fwd_draft = 22  # Fwd Draft(m) column (V in Excel)
    col_vs_270 = 23  # vs 2.70m column (W in Excel)
    col_deballast = 24  # De-ballast Qty(t) column (X in Excel)
    col_phys_freeboard = 26  # Phys_Freeboard_m column (Z in Excel)
    col_gm_calc = 28  # GM_calc column (AB in Excel)
    col_gm_check = 29  # GM_Check column (AC in Excel)
    col_disp_total = 30  # Disp_total_t column (AD in Excel)
    col_vent_time = 31  # Vent_Time_h column (AE in Excel)

    # Parameter row references (1-based Excel row numbers)
    param_row_d_vessel = 11  # D_vessel parameter (row_idx=10, Excel row 11)
    param_row_pump_rate = 13  # pump_rate_effective_tph (row_idx=12, Excel row 13)
    col_letter_param_b = col_idx_to_excel_letter(1)  # B column

    for row_idx in range(first_data_row, first_data_row + num_stages):
        row_num = row_idx + 1  # Excel row number (1-based)

        # U(21): GM(m) - from stage_results (will be filled by Python values)
        # Note: Excel formula would be: =IFERROR(VLOOKUP(AVERAGE(P{row},Q{row}), Hydro_Table!$B:$D, 3, 1), &#34;&#34;)
        # But we use Python calculated values instead
        ws.write(
            row_idx, col_gm, &#34;&#34;, num_format
        )  # Placeholder, will be filled from stage_results

        # V(22): Fwd Draft(m) - =P{row} (Dfwd_m column, index 15)
        col_letter_dfwd = col_idx_to_excel_letter(col_dfwd)
        ws.write_formula(
            row_idx, col_fwd_draft, f&#34;={col_letter_dfwd}{row_num}&#34;, num_format
        )

        # W(23): vs 2.70m - =IF(V{row}&lt;=2.70,&#34;OK&#34;,&#34;NG&#34;)
        col_letter_fwd_draft = col_idx_to_excel_letter(col_fwd_draft)
        ws.write_formula(
            row_idx,
            col_vs_270,
            f&#39;=IF({col_letter_fwd_draft}{row_num}&lt;=2.70+$B$7,&#34;OK&#34;,&#34;NG&#34;)&#39;,
            styles[&#34;normal_font&#34;],
        )

        # X(24): De-ballast Qty(t) - =M{row} (Ballast_t column, index 12)
        col_letter_ballast = col_idx_to_excel_letter(col_ballast_t)
        ws.write_formula(
            row_idx, col_deballast, f&#34;={col_letter_ballast}{row_num}&#34;, num_format
        )

        # Y(25): Timing - manual input (yellow fill)
        ws.write(row_idx, 25, &#34;&#34;, styles[&#34;input_fill&#34;])

        # Z(26): Phys_Freeboard_m - =B11 - P{row} (D_vessel - Dfwd_m)
        # Note: B11 is parameter row 11 (row_idx=10, col 1)
        ws.write_formula(
            row_idx,
            col_phys_freeboard,
            f&#34;={col_letter_param_b}{param_row_d_vessel}-{col_letter_dfwd}{row_num}&#34;,
            num_format,
        )

        # AA(27): Clearance_Check - optional, skip for now

        # AB(28): GM_calc - =U{row}
        col_letter_gm = col_idx_to_excel_letter(col_gm)
        ws.write_formula(row_idx, col_gm_calc, f&#34;={col_letter_gm}{row_num}&#34;, num_format)

        # AC(29): GM_Check - =IF(AB{row}&gt;=1.50,&#34;OK&#34;,&#34;NG&#34;) (GM_target = 1.50m)
        col_letter_gm_calc = col_idx_to_excel_letter(col_gm_calc)
        ws.write_formula(
            row_idx,
            col_gm_check,
            f&#39;=IF({col_letter_gm_calc}{row_num}&gt;=1.50,&#34;OK&#34;,&#34;NG&#34;)&#39;,
            styles[&#34;normal_font&#34;],
        )

        # AD(30): Disp_total_t - =B{row} + M{row} (W_stage_t + Ballast_t)
        # Note: This is simplified; actual formula might include CONST_TANKS
        col_letter_w_stage = col_idx_to_excel_letter(col_w_stage)
        ws.write_formula(
            row_idx,
            col_disp_total,
            f&#34;={col_letter_w_stage}{row_num}+{col_letter_ballast}{row_num}&#34;,
            num_format,
        )

        # AE(31): Vent_Time_h - =IF(OR(X{row}=&#34;&#34;,B13=&#34;&#34;,B13=0),&#34;&#34;,ROUND(ABS(X{row})/B13,2))
        # Note: B13 is pump_rate_effective_tph (row 13, col 1)
        col_letter_deballast = col_idx_to_excel_letter(col_deballast)
        ws.write_formula(
            row_idx,
            col_vent_time,
            f&#39;=IF(OR({col_letter_deballast}{row_num}=&#34;&#34;,{col_letter_param_b}{param_row_pump_rate}=&#34;&#34;,{col_letter_param_b}{param_row_pump_rate}=0),&#34;&#34;,ROUND(ABS({col_letter_deballast}{row_num})/{col_letter_param_b}{param_row_pump_rate},2))&#39;,
            num_format,
        )

    print(&#34;  [OK] Captain Requirement columns added (U-AE)&#34;)</code></pre>
</details>
<div class="desc"><p>Add Captain Requirement columns (U-AE) to RORO_Stage_Scenarios sheet.</p>
<p>Columns:
- U(21): GM(m) - from stage_results
- V(22): Fwd Draft(m) - Dfwd_m copy
- W(23): vs 2.70m - Fwd ≤ 2.70m check
- X(24): De-ballast Qty(t) - Ballast_t
- Y(25): Timing - manual input
- Z(26): Phys_Freeboard_m - D_vessel - Dfwd_m
- AA(27): Clearance_Check - optional
- AB(28): GM_calc - GM copy
- AC(29): GM_Check - GM ≥ GM_target check
- AD(30): Disp_total_t - Total displacement
- AE(31): Vent_Time_h - De-ballast qty / pump rate</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.extend_roro_structural_opt1"><code class="name flex">
<span>def <span class="ident">extend_roro_structural_opt1</span></span>(<span>ws: Any,<br>workbook: Any,<br>first_data_row: int,<br>num_stages: int,<br>styles: Dict[str, Any],<br>num_format: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_roro_structural_opt1(
    ws: Any,
    workbook: Any,
    first_data_row: int,
    num_stages: int,
    styles: Dict[str, Any],
    num_format: Any,
) -&gt; None:
    &#34;&#34;&#34;
    Add Structural Strength and Option 1 Ballast Fix Check columns (AK-BB) to RORO_Stage_Scenarios sheet.

    Columns:
    - AK-AP(37-42): Structural Strength columns
    - AQ(43): Dynamic Load Case B
    - AR-AS(44-45): Heel/FSE (handled by extend_roro_captain_req)
    - AT-AV(46-48): Option 1 Ballast Fix Check
    - AW-AZ(49-52): Ramp Angle &amp; Pin Stress
    - BA-BB(53-54): Opt C / High Tide
    &#34;&#34;&#34;
    # Header row (Row 18, 0-based index 17)
    header_row = 17

    structural_cols = [
        &#34;Share_Load_t&#34;,  # AK(37)
        &#34;Share_Check&#34;,  # AL(38)
        &#34;Hinge_Rx_t&#34;,  # AM(39)
        &#34;Rx_Check&#34;,  # AN(40)
        &#34;Deck_Press_t/m²&#34;,  # AO(41)
        &#34;Press_Check&#34;,  # AP(42)
    ]

    dynamic_load_cols = [
        &#34;Load_Case_B_t&#34;,  # AQ(43)
    ]

    opt1_cols = [
        &#34;Ballast_req_t&#34;,  # AT(46)
        &#34;Ballast_gap_t&#34;,  # AU(47)
        &#34;Time_Add_h&#34;,  # AV(48)
    ]

    ramp_stress_cols = [
        &#34;Ramp_Angle_deg&#34;,  # AW(49)
        &#34;Ramp_Angle_Check&#34;,  # AX(50)
        &#34;Pin_Stress_N/mm²&#34;,  # AY(51)
        &#34;Von_Mises_Check&#34;,  # AZ(52)
    ]

    # Tide / Water Level definitions (to avoid misinterpretation)
    # - Forecast_Tide_m: from official tide table (Chart Datum)
    # - Required_WL_m: required water level (sea level) to satisfy draft limits (NOT a forecast)
    opt_c_tide_cols = [
        &#34;Required_WL_m&#34;,  # BA(53) - required water level/sea level (NOT forecast)
        &#34;WL_OK&#34;,  # BB(54) - Forecast_Tide_m &gt;= Required_WL_m
        &#34;Forecast_Tide_m&#34;,  # BC(55) - repeated input value for clarity
        &#34;FWD_Allow_m&#34;,  # BD(56) = MAX_FWD_DRAFT_OPS + Forecast_Tide_m
        &#34;FWD_OK_wTide&#34;,  # BE(57) = IF(Dfwd_m &lt;= FWD_Allow_m, OK, NG)
        &#34;AFT_Min_2.70_OK&#34;,  # BF(58) = IF(Daft_m &gt;= 2.70, OK, NG)
        &#34;Min_Freeboard_m&#34;,  # BG(59) = D_vessel - MAX(Dfwd_m, Daft_m)
        &#34;Deck_Encroach_Check&#34;,  # BH(60) = IF(Min_Freeboard_m &gt; 0, OK, NG)
    ]

    all_cols = (
        structural_cols
        + dynamic_load_cols
        + opt1_cols
        + ramp_stress_cols
        + opt_c_tide_cols
    )
    start_col = 37  # AK column (0-based index 37)

    # Write headers with appropriate fills
    for i, header in enumerate(all_cols):
        col_idx = start_col + i

        # Create header format with appropriate fill color
        if i &lt; len(structural_cols):
            bg_color = &#34;#FFC000&#34;  # Orange for structural
        elif i &lt; len(structural_cols) + len(dynamic_load_cols):
            bg_color = &#34;#FFC000&#34;  # Orange for dynamic load
        elif i &lt; len(structural_cols) + len(dynamic_load_cols) + len(opt1_cols):
            bg_color = &#34;#D9D9D9&#34;  # Gray for option 1
        elif i &lt; len(structural_cols) + len(dynamic_load_cols) + len(opt1_cols) + len(
            ramp_stress_cols
        ):
            bg_color = &#34;#FFC000&#34;  # Orange for ramp/stress
        else:
            bg_color = &#34;#D9D9D9&#34;  # Gray for opt c tide

        header_fmt = workbook.add_format(
            {
                &#34;bold&#34;: True,
                &#34;bg_color&#34;: bg_color,
                &#34;font_color&#34;: &#34;#FFFFFF&#34;,
                &#34;align&#34;: &#34;center&#34;,
                &#34;valign&#34;: &#34;vcenter&#34;,
                &#34;border&#34;: 1,
                &#34;font_name&#34;: &#34;Calibri&#34;,
            }
        )

        ws.write(header_row, col_idx, header, header_fmt)

    # Write data for each stage
    # Define column indices for reference
    col_share_load = 37  # Share_Load_t column (AK in Excel)
    col_share_check = 38  # Share_Check column (AL in Excel)
    col_hinge_rx = 39  # Hinge_Rx_t column (AM in Excel)
    col_rx_check = 40  # Rx_Check column (AN in Excel)
    col_deck_press = 41  # Deck_Press_t/m² column (AO in Excel)
    col_press_check = 42  # Press_Check column (AP in Excel)
    col_load_case_b = 43  # Load_Case_B_t column (AQ in Excel)
    col_ballast_req = 46  # Ballast_req_t column (AT in Excel)
    col_ballast_gap = 47  # Ballast_gap_t column (AU in Excel)
    col_time_add = 48  # Time_Add_h column (AV in Excel)
    col_stage = 0  # Stage column (A in Excel)
    col_lever_arm = (
        9  # Lever_arm_m column (J in Excel, but formula uses I which is col 8)
    )
    col_lever_arm_formula = (
        8  # I column in formula (actually Lever_arm_m is col 9, but formula uses I)
    )
    col_mtc_formula = 9  # J column in formula (MTC reference)
    col_ballast_t_ref = 12  # Ballast_t column (M in Excel)

    # Parameter row references
    param_row_pump_rate = 13  # pump_rate_effective_tph (row_idx=12, Excel row 13)
    col_letter_param_b = col_idx_to_excel_letter(1)  # B column

    for row_idx in range(first_data_row, first_data_row + num_stages):
        row_num = row_idx + 1  # Excel row number (1-based)

        # AK(37): Share_Load_t - manual input (yellow fill)
        ws.write(row_idx, col_share_load, &#34;&#34;, styles[&#34;input_fill&#34;])

        # AL(38): Share_Check - =IF(AK{row}&lt;=Calc!$E$24,&#34;OK&#34;,&#34;CHECK&#34;)
        # Note: Simplified without Calc sheet reference
        col_letter_share_load = col_idx_to_excel_letter(col_share_load)
        ws.write_formula(
            row_idx,
            col_share_check,
            f&#39;=IF({col_letter_share_load}{row_num}&lt;=100,&#34;OK&#34;,&#34;CHECK&#34;)&#39;,
            styles[&#34;normal_font&#34;],
        )

        # AM(39): Hinge_Rx_t - =IF(AK{row}=&#34;&#34;,45,45+AK{row}*0.545)
        ws.write_formula(
            row_idx,
            col_hinge_rx,
            f&#39;=IF({col_letter_share_load}{row_num}=&#34;&#34;,45,45+{col_letter_share_load}{row_num}*0.545)&#39;,
            num_format,
        )

        # AN(40): Rx_Check - =IF(AM{row}&lt;=Calc!$E$37,&#34;OK&#34;,&#34;NG&#34;)
        col_letter_hinge_rx = col_idx_to_excel_letter(col_hinge_rx)
        ws.write_formula(
            row_idx,
            col_rx_check,
            f&#39;=IF({col_letter_hinge_rx}{row_num}&lt;=200,&#34;OK&#34;,&#34;NG&#34;)&#39;,
            styles[&#34;normal_font&#34;],
        )

        # AO(41): Deck_Press_t/m² - =IF(AK{row}=&#34;&#34;,&#34;&#34;,AK{row}/Calc!$E$26)
        ws.write_formula(
            row_idx,
            col_deck_press,
            f&#39;=IF({col_letter_share_load}{row_num}=&#34;&#34;,&#34;&#34;,{col_letter_share_load}{row_num}/10)&#39;,
            num_format,
        )

        # AP(42): Press_Check - =IF(AO{row}&lt;=Calc!$E$25,&#34;OK&#34;,&#34;CHECK&#34;)
        col_letter_deck_press = col_idx_to_excel_letter(col_deck_press)
        ws.write_formula(
            row_idx,
            col_press_check,
            f&#39;=IF({col_letter_deck_press}{row_num}&lt;=4,&#34;OK&#34;,&#34;CHECK&#34;)&#39;,
            styles[&#34;normal_font&#34;],
        )

        # AQ(43): Load_Case_B_t - =IF(AK{row}=&#34;&#34;,&#34;&#34;,AK{row}*Calc!$E$42)
        ws.write_formula(
            row_idx,
            col_load_case_b,
            f&#39;=IF({col_letter_share_load}{row_num}=&#34;&#34;,&#34;&#34;,{col_letter_share_load}{row_num}*1.5)&#39;,
            num_format,
        )

        # AT(46): Ballast_req_t - =IF($A{row}=&#34;&#34;,&#34;&#34;,IF(OR($I{row}=&#34;&#34;,$I{row}=0),0,ROUND(H{row}/$I{row},2)))
        # Note: H{row} is Lever_arm_m (col 9, Excel I), I{row} is MTC reference (col 8, Excel J)
        # Actually: Lever_arm_m is col 9 (J), but formula uses I (col 8) and J (col 9)
        col_letter_stage = col_idx_to_excel_letter(col_stage)
        col_letter_lever_arm_i = col_idx_to_excel_letter(
            col_lever_arm_formula
        )  # I column
        col_letter_mtc_j = col_idx_to_excel_letter(col_mtc_formula)  # J column
        ws.write_formula(
            row_idx,
            col_ballast_req,
            f&#39;=IF(${col_letter_stage}{row_num}=&#34;&#34;,&#34;&#34;,IF(OR(${col_letter_mtc_j}{row_num}=&#34;&#34;,${col_letter_mtc_j}{row_num}=0),0,ROUND({col_letter_lever_arm_i}{row_num}/${col_letter_mtc_j}{row_num},2)))&#39;,
            num_format,
        )

        # AU(47): Ballast_gap_t - =IF($A{row}=&#34;&#34;,&#34;&#34;,AT{row}-$M{row})
        col_letter_ballast_req = col_idx_to_excel_letter(col_ballast_req)
        col_letter_ballast_t = col_idx_to_excel_letter(col_ballast_t_ref)
        ws.write_formula(
            row_idx,
            col_ballast_gap,
            f&#39;=IF(${col_letter_stage}{row_num}=&#34;&#34;,&#34;&#34;,{col_letter_ballast_req}{row_num}-${col_letter_ballast_t}{row_num})&#39;,
            num_format,
        )

        # AV(48): Time_Add_h - =IF(AU{row}=&#34;&#34;,&#34;&#34;,ROUND(AU{row}/B13,2))
        col_letter_ballast_gap = col_idx_to_excel_letter(col_ballast_gap)
        ws.write_formula(
            row_idx,
            col_time_add,
            f&#39;=IF({col_letter_ballast_gap}{row_num}=&#34;&#34;,&#34;&#34;,ROUND({col_letter_ballast_gap}{row_num}/{col_letter_param_b}{param_row_pump_rate},2))&#39;,
            num_format,
        )

        # AW(49): Ramp_Angle_deg - placeholder
        ws.write(row_idx, 49, &#34;&#34;, num_format)

        # AX(50): Ramp_Angle_Check - placeholder
        ws.write(row_idx, 50, &#34;&#34;, styles[&#34;normal_font&#34;])

        # AY(51): Pin_Stress_N/mm² - placeholder
        ws.write(row_idx, 51, &#34;&#34;, num_format)

        # AZ(52): Von_Mises_Check - placeholder
        ws.write(row_idx, 52, &#34;&#34;, styles[&#34;normal_font&#34;])

        # BA(53): Required_WL_m (required water level/sea level to satisfy draft limits; NOT forecast)
        # Required_WL_m = MAX(0, Dfwd_m - MAX_FWD_DRAFT_OPS, Daft_m - MAX_AFT_DRAFT_OPS)
        col_letter_dfwd = col_idx_to_excel_letter(15)  # Dfwd_m column (P, 0-based 15)
        col_letter_daft = col_idx_to_excel_letter(16)  # Daft_m column (Q, 0-based 16)
        ws.write_formula(
            row_idx,
            53,
            f&#34;=MAX(0,{col_letter_dfwd}{row_num}-{VesselParams.MAX_FWD_DRAFT_OPS:.2f},{col_letter_daft}{row_num}-{VesselParams.MAX_AFT_DRAFT_OPS:.2f})&#34;,
            num_format,
        )

        # BB(54): WL_OK (Forecast_Tide_m &gt;= Required_WL_m)
        ws.write_formula(
            row_idx,
            54,
            f&#39;=IF($B$7&gt;={col_idx_to_excel_letter(53)}{row_num},&#34;OK&#34;,&#34;NG&#34;)&#39;,
            styles[&#34;normal_font&#34;],
        )

        # BC(55): Forecast_Tide_m (repeat input for clarity)
        ws.write_formula(row_idx, 55, &#34;=$B$7&#34;, num_format)

        # BD(56): FWD_Allow_m = MAX_FWD_DRAFT_OPS + Forecast_Tide_m
        ws.write_formula(
            row_idx, 56, f&#34;={VesselParams.MAX_FWD_DRAFT_OPS:.2f}+$B$7&#34;, num_format
        )

        # BE(57): FWD_OK_wTide = IF(Dfwd_m &lt;= FWD_Allow_m, OK, NG)
        ws.write_formula(
            row_idx,
            57,
            f&#39;=IF({col_letter_dfwd}{row_num}&lt;={col_idx_to_excel_letter(56)}{row_num},&#34;OK&#34;,&#34;NG&#34;)&#39;,
            styles[&#34;normal_font&#34;],
        )

        # BF(58): AFT_Min_2.70_OK (Captain emergency propulsion gate)
        ws.write_formula(
            row_idx,
            58,
            f&#39;=IF({col_letter_daft}{row_num}&gt;=2.70,&#34;OK&#34;,&#34;NG&#34;)&#39;,
            styles[&#34;normal_font&#34;],
        )

        # BG(59): Min_Freeboard_m = D_vessel - MAX(Dfwd_m, Daft_m)
        # D_vessel is parameter cell $B$11
        ws.write_formula(
            row_idx,
            59,
            f&#34;=$B$11-MAX({col_letter_dfwd}{row_num},{col_letter_daft}{row_num})&#34;,
            num_format,
        )

        # BH(60): Deck_Encroach_Check = IF(Min_Freeboard_m &gt; 0, OK, NG)
        ws.write_formula(
            row_idx,
            60,
            f&#39;=IF({col_idx_to_excel_letter(59)}{row_num}&gt;0,&#34;OK&#34;,&#34;NG&#34;)&#39;,
            styles[&#34;normal_font&#34;],
        )

    print(&#34;  [OK] Structural/Option 1 columns added (AK-BB)&#34;)</code></pre>
</details>
<div class="desc"><p>Add Structural Strength and Option 1 Ballast Fix Check columns (AK-BB) to RORO_Stage_Scenarios sheet.</p>
<p>Columns:
- AK-AP(37-42): Structural Strength columns
- AQ(43): Dynamic Load Case B
- AR-AS(44-45): Heel/FSE (handled by extend_roro_captain_req)
- AT-AV(46-48): Option 1 Ballast Fix Check
- AW-AZ(49-52): Ramp Angle &amp; Pin Stress
- BA-BB(53-54): Opt C / High Tide</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.fr_to_x"><code class="name flex">
<span>def <span class="ident">fr_to_x</span></span>(<span>fr: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fr_to_x(fr: float) -&gt; float:
    &#34;&#34;&#34;
    Convert Frame number to x [m from midship].

    BUSHRA 757 TCP 기준:
    - Frame 증가 = FWD 방향
    - Frame 30.151 = Midship → x = 0.0
    - Frame &lt; 30.151 (AFT) → x &gt; 0 (AFT)
    - Frame &gt; 30.151 (FWD) → x &lt; 0 (FWD)

    공식: x = _FRAME_SLOPE * (fr - _FRAME_OFFSET)
    &#34;&#34;&#34;
    return _FRAME_SLOPE * (float(fr) - _FRAME_OFFSET)</code></pre>
</details>
<div class="desc"><p>Convert Frame number to x [m from midship].</p>
<p>BUSHRA 757 TCP 기준:
- Frame 증가 = FWD 방향
- Frame 30.151 = Midship → x = 0.0
- Frame &lt; 30.151 (AFT) → x &gt; 0 (AFT)
- Frame &gt; 30.151 (FWD) → x &lt; 0 (FWD)</p>
<p>공식: x = _FRAME_SLOPE * (fr - _FRAME_OFFSET)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.generate_bwrb_log"><code class="name flex">
<span>def <span class="ident">generate_bwrb_log</span></span>(<span>plan_df: pd.DataFrame,<br>vessel: str,<br>loc: str,<br>lat: str,<br>lon: str,<br>officer: str,<br>master_verified: str = 'N')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_bwrb_log(
    plan_df: pd.DataFrame,
    vessel: str,
    loc: str,
    lat: str,
    lon: str,
    officer: str,
    master_verified: str = &#34;N&#34;,
):
    &#34;&#34;&#34;Generates a CSV compatible with Ballast Water Record Books (IMO BWRB compliant).&#34;&#34;&#34;
    rows = []
    from datetime import datetime, timedelta

    # Validate location data
    if not lat or not lon:
        print(&#34;WARNING: Lat/Lon missing - BWRB requires location information&#34;)

    t_cursor = datetime.now()

    for _, r in plan_df.iterrows():
        dur_h = float(r.get(&#34;Time_h&#34;, 0.0))
        weight_t = float(r.get(&#34;Weight_t&#34;, 0.0))
        volume_m3 = round(weight_t / 1.025, 1) if weight_t &gt; 0 else 0.0

        rows.append(
            {
                &#34;Vessel&#34;: vessel,
                &#34;Location&#34;: loc or &#34;Sea&#34;,
                &#34;Lat&#34;: lat or &#34;&#34;,
                &#34;Lon&#34;: lon or &#34;&#34;,
                &#34;Date&#34;: t_cursor.strftime(&#34;%Y-%m-%d&#34;),
                &#34;Start&#34;: t_cursor.strftime(&#34;%H:%M&#34;),
                &#34;End&#34;: (
                    (t_cursor + timedelta(hours=dur_h)).strftime(&#34;%H:%M&#34;)
                    if dur_h &gt; 0
                    else &#34;&#34;
                ),
                &#34;Tank&#34;: r.get(&#34;Tank&#34;, &#34;&#34;),
                &#34;Operation&#34;: r.get(&#34;Action&#34;, &#34;&#34;),
                &#34;Volume_m3&#34;: volume_m3,
                &#34;Weight_t&#34;: round(weight_t, 2),
                &#34;Officer&#34;: officer or &#34;&#34;,
                &#34;MasterVerified&#34;: master_verified,
                &#34;Remarks&#34;: &#34;&#34;,
            }
        )
        if dur_h &gt; 0:
            t_cursor += timedelta(hours=dur_h)
    return pd.DataFrame(rows)</code></pre>
</details>
<div class="desc"><p>Generates a CSV compatible with Ballast Water Record Books (IMO BWRB compliant).</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.get_default_hydro_table"><code class="name flex">
<span>def <span class="ident">get_default_hydro_table</span></span>(<span>) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_hydro_table() -&gt; pd.DataFrame:
    &#34;&#34;&#34;Create a synthetic hydro table based on vessel constants.&#34;&#34;&#34;
    # Create a range of drafts
    drafts = np.linspace(1.0, 4.0, 31)
    data = []
    for d in drafts:
        data.append(
            {
                &#34;Tmean_m&#34;: d,
                &#34;TPC_t_per_cm&#34;: VesselParams.TPC,
                &#34;MTC_t_m_per_cm&#34;: VesselParams.MTC,
                &#34;LCF_m&#34;: VesselParams.LCF,
                &#34;LBP_m&#34;: VesselParams.LBP,
            }
        )
    return pd.DataFrame(data)</code></pre>
</details>
<div class="desc"><p>Create a synthetic hydro table based on vessel constants.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.get_default_tanks"><code class="name flex">
<span>def <span class="ident">get_default_tanks</span></span>(<span>) ‑> List[01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_tanks() -&gt; List[Tank]:
    &#34;&#34;&#34;Load default hardcoded tanks.&#34;&#34;&#34;
    tanks = []
    for name, x, cap, rate, grp in DEFAULT_TANKS_DATA:
        tanks.append(
            Tank(
                name=name,
                x_from_mid_m=x,
                current_t=0.0,
                min_t=0.0,
                max_t=cap,
                mode=&#34;FILL_DISCHARGE&#34;,
                use_flag=&#34;Y&#34;,
                pump_rate_tph=rate,
                group=grp,
                priority_weight=1.0,
                density_t_per_m3=VesselParams.DENSITY,
                freeze_flag=&#34;N&#34;,
            )
        )
    return tanks</code></pre>
</details>
<div class="desc"><p>Load default hardcoded tanks.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.get_styles"><code class="name flex">
<span>def <span class="ident">get_styles</span></span>(<span>workbook: Optional[Any] = None) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_styles(workbook: Optional[Any] = None) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Get xlsxwriter format styles for RORO Excel export.

    Args:
        workbook: xlsxwriter Workbook instance (required for creating formats)

    Returns:
        dict with format keys: title_format, header_format, input_fill, normal_font, etc.
    &#34;&#34;&#34;
    if workbook is None:
        # Return format names only (will be created later)
        return {
            &#34;title_format&#34;: None,
            &#34;header_format&#34;: None,
            &#34;input_fill&#34;: None,
            &#34;normal_font&#34;: None,
            &#34;ok_fill&#34;: None,
            &#34;ng_fill&#34;: None,
            &#34;structure_fill&#34;: None,
            &#34;opt1_fill&#34;: None,
            &#34;center_align&#34;: None,
        }

    # Create formats using workbook
    styles = {}

    # Title format
    styles[&#34;title_format&#34;] = workbook.add_format(
        {
            &#34;bold&#34;: True,
            &#34;font_size&#34;: 14,
            &#34;font_name&#34;: &#34;Calibri&#34;,
        }
    )

    # Header format
    styles[&#34;header_format&#34;] = workbook.add_format(
        {
            &#34;bold&#34;: True,
            &#34;bg_color&#34;: &#34;#366092&#34;,
            &#34;font_color&#34;: &#34;#FFFFFF&#34;,
            &#34;align&#34;: &#34;center&#34;,
            &#34;valign&#34;: &#34;vcenter&#34;,
            &#34;border&#34;: 1,
            &#34;font_name&#34;: &#34;Calibri&#34;,
        }
    )

    # Input fill (yellow)
    styles[&#34;input_fill&#34;] = workbook.add_format(
        {
            &#34;bg_color&#34;: &#34;#FFFF99&#34;,
            &#34;font_name&#34;: &#34;Calibri&#34;,
        }
    )

    # Normal font
    styles[&#34;normal_font&#34;] = workbook.add_format(
        {
            &#34;font_name&#34;: &#34;Calibri&#34;,
        }
    )

    # OK fill (green)
    styles[&#34;ok_fill&#34;] = workbook.add_format(
        {
            &#34;bg_color&#34;: &#34;#C6EFCE&#34;,
            &#34;font_color&#34;: &#34;#006100&#34;,
            &#34;font_name&#34;: &#34;Calibri&#34;,
        }
    )

    # NG fill (red)
    styles[&#34;ng_fill&#34;] = workbook.add_format(
        {
            &#34;bg_color&#34;: &#34;#FFC7CE&#34;,
            &#34;font_color&#34;: &#34;#9C0006&#34;,
            &#34;font_name&#34;: &#34;Calibri&#34;,
        }
    )

    # Structure fill (orange)
    styles[&#34;structure_fill&#34;] = workbook.add_format(
        {
            &#34;bg_color&#34;: &#34;#FFC000&#34;,
            &#34;font_name&#34;: &#34;Calibri&#34;,
        }
    )

    # Option 1 fill (purple)
    styles[&#34;opt1_fill&#34;] = workbook.add_format(
        {
            &#34;bg_color&#34;: &#34;#D9D9D9&#34;,
            &#34;font_name&#34;: &#34;Calibri&#34;,
        }
    )

    # Center align
    styles[&#34;center_align&#34;] = workbook.add_format(
        {
            &#34;align&#34;: &#34;center&#34;,
            &#34;valign&#34;: &#34;vcenter&#34;,
            &#34;font_name&#34;: &#34;Calibri&#34;,
        }
    )

    return styles</code></pre>
</details>
<div class="desc"><p>Get xlsxwriter format styles for RORO Excel export.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>workbook</code></strong></dt>
<dd>xlsxwriter Workbook instance (required for creating formats)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict with format keys</code></dt>
<dd>title_format, header_format, input_fill, normal_font, etc.</dd>
</dl></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.gm_2d_bilinear"><code class="name flex">
<span>def <span class="ident">gm_2d_bilinear</span></span>(<span>disp_t: float, trim_m: float, gm_grid: Optional[Dict[str, Any]] = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gm_2d_bilinear(
    disp_t: float, trim_m: float, gm_grid: Optional[Dict[str, Any]] = None
) -&gt; float:
    &#34;&#34;&#34;
    Bilinear interpolation on (disp, trim) → GM 2D grid.

    Args:
        disp_t: Displacement (tons)
        trim_m: Trim in meters (positive = bow down, negative = stern down)
        gm_grid: Optional GM grid dict with keys:
            - &#34;disp_grid&#34;: list of displacement values
            - &#34;trim_grid&#34;: list of trim values
            - &#34;gm_grid&#34;: 2D list of GM values [disp_idx][trim_idx]

    Returns:
        GM value (meters) or 1.50m fallback if data not available
    &#34;&#34;&#34;
    # Fallback: Grid가 없으면 안전한 최소값 반환
    if gm_grid is None:
        return VesselParams.MIN_GM_M  # Safe minimum GM requirement

    try:
        disp_grid = gm_grid.get(&#34;disp_grid&#34;, [])
        trim_grid = gm_grid.get(&#34;trim_grid&#34;, [])
        gm_values = gm_grid.get(&#34;gm_grid&#34;, [])

        if not disp_grid or not trim_grid or not gm_values:
            return VesselParams.MIN_GM_M

        # Clamp disp
        if disp_t &lt;= disp_grid[0]:
            i0 = i1 = 0
        elif disp_t &gt;= disp_grid[-1]:
            i0 = i1 = len(disp_grid) - 1
        else:
            i = np.searchsorted(disp_grid, disp_t)
            i0 = max(0, i - 1)
            i1 = min(len(disp_grid) - 1, i)

        # Clamp trim
        if trim_m &lt;= trim_grid[0]:
            j0 = j1 = 0
        elif trim_m &gt;= trim_grid[-1]:
            j0 = j1 = len(trim_grid) - 1
        else:
            j = np.searchsorted(trim_grid, trim_m)
            j0 = max(0, j - 1)
            j1 = min(len(trim_grid) - 1, j)

        d0, d1 = disp_grid[i0], disp_grid[i1]
        t0, t1 = trim_grid[j0], trim_grid[j1]

        # 보간 비율
        td = (disp_t - d0) / (d1 - d0) if d1 != d0 else 0.0
        tt = (trim_m - t0) / (t1 - t0) if t1 != t0 else 0.0

        # 모서리 GM 값
        g00 = gm_values[i0][j0]
        g10 = gm_values[i1][j0]
        g01 = gm_values[i0][j1]
        g11 = gm_values[i1][j1]

        # Bilinear interpolation
        gm = (
            (1 - td) * (1 - tt) * g00
            + td * (1 - tt) * g10
            + (1 - td) * tt * g01
            + td * tt * g11
        )

        # Sanity check
        if gm &lt; 0 or gm &gt; 5.0:
            return VesselParams.MIN_GM_M

        return float(gm)
    except Exception as e:
        print(
            f&#34;[WARNING] GM calculation error: {e} → fallback GM={VesselParams.MIN_GM_M}m&#34;
        )
        return VesselParams.MIN_GM_M</code></pre>
</details>
<div class="desc"><p>Bilinear interpolation on (disp, trim) → GM 2D grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>disp_t</code></strong></dt>
<dd>Displacement (tons)</dd>
<dt><strong><code>trim_m</code></strong></dt>
<dd>Trim in meters (positive = bow down, negative = stern down)</dd>
<dt><strong><code>gm_grid</code></strong></dt>
<dd>Optional GM grid dict with keys:
- "disp_grid": list of displacement values
- "trim_grid": list of trim values
- "gm_grid": 2D list of GM values [disp_idx][trim_idx]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>GM value (meters) or 1.50m fallback if data not available</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.interpolate_hydro_by_tmean"><code class="name flex">
<span>def <span class="ident">interpolate_hydro_by_tmean</span></span>(<span>tmean_m: float, hydro_df: Optional[pd.DataFrame] = None) ‑> Dict[str, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_hydro_by_tmean(
    tmean_m: float, hydro_df: Optional[pd.DataFrame] = None
) -&gt; Dict[str, float]:
    &#34;&#34;&#34;
    Interpolate hydrostatic fields by mean draft (Tmean_m).

    Expected columns in hydro_df:
      - Tmean_m
      - LCF_m_from_midship or LCF_m (x_from_mid_m, aft+)
      - MCTC_t_m_per_cm or MTC_t_m_per_cm
      - TPC_t_per_cm or TPC
      - GM_min_m (optional)

    Returns:
      dict with any available interpolated fields (missing fields omitted).
    &#34;&#34;&#34;
    if hydro_df is None or hydro_df.empty:
        return {}

    out = {&#34;Tmean_m&#34;: float(tmean_m)}

    # Tmean 컬럼 찾기
    tmean_col = None
    for col in hydro_df.columns:
        if &#34;tmean&#34; in col.lower():
            tmean_col = col
            break

    if tmean_col is None:
        return out

    # Tmean 기준 정렬
    df_sorted = hydro_df.sort_values(tmean_col).reset_index(drop=True)
    tmeans = df_sorted[tmean_col].astype(float).values

    # Clamp
    if tmean_m &lt;= tmeans[0]:
        idx = 0
    elif tmean_m &gt;= tmeans[-1]:
        idx = len(tmeans) - 1
    else:
        idx = np.searchsorted(tmeans, tmean_m)

    # 보간할 컬럼들
    interp_cols = {
        &#34;LCF_m_from_midship&#34;: [&#34;lcf_m_from_midship&#34;, &#34;lcf_from_mid_m&#34;, &#34;lcf_m&#34;, &#34;lcf&#34;],
        &#34;MCTC_t_m_per_cm&#34;: [&#34;mctc_t_m_per_cm&#34;, &#34;mtc_t_m_per_cm&#34;, &#34;mctc&#34;, &#34;mtc&#34;],
        &#34;TPC_t_per_cm&#34;: [&#34;tpc_t_per_cm&#34;, &#34;tpc&#34;],
        &#34;GM_min_m&#34;: [&#34;gm_min_m&#34;, &#34;gmmin_m&#34;, &#34;gm_min&#34;],
    }

    for out_key, candidates in interp_cols.items():
        col = None
        for c in df_sorted.columns:
            if c.lower() in [cand.lower() for cand in candidates]:
                col = c
                break

        if col is None:
            continue

        values = df_sorted[col].astype(float).values
        # 유효한 값만 필터링
        valid_mask = ~np.isnan(values)
        if valid_mask.sum() &lt; 2:
            continue

        valid_tmeans = tmeans[valid_mask]
        valid_values = values[valid_mask]

        # Clamp
        if tmean_m &lt;= valid_tmeans[0]:
            out[out_key] = float(valid_values[0])
        elif tmean_m &gt;= valid_tmeans[-1]:
            out[out_key] = float(valid_values[-1])
        else:
            # 선형 보간
            interp_val = np.interp(tmean_m, valid_tmeans, valid_values)
            out[out_key] = float(interp_val)

    return out</code></pre>
</details>
<div class="desc"><p>Interpolate hydrostatic fields by mean draft (Tmean_m).</p>
<p>Expected columns in hydro_df:
- Tmean_m
- LCF_m_from_midship or LCF_m (x_from_mid_m, aft+)
- MCTC_t_m_per_cm or MTC_t_m_per_cm
- TPC_t_per_cm or TPC
- GM_min_m (optional)</p>
<h2 id="returns">Returns</h2>
<p>dict with any available interpolated fields (missing fields omitted).</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.interpolate_tmean_from_disp"><code class="name flex">
<span>def <span class="ident">interpolate_tmean_from_disp</span></span>(<span>disp_t: float, hydro_df: Optional[pd.DataFrame] = None) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_tmean_from_disp(
    disp_t: float, hydro_df: Optional[pd.DataFrame] = None
) -&gt; float:
    &#34;&#34;&#34;
    Δdisp → Tmean 보간

    Args:
        disp_t: 배수량 (ton)
        hydro_df: Hydro table DataFrame (Tmean_m, Displacement_t 또는 Disp_t 컬럼 필요)

    Returns:
        Tmean (m) - 선형 보간된 평균 흘수
    &#34;&#34;&#34;
    if hydro_df is None or hydro_df.empty:
        return 2.00  # Fallback

    try:
        # 컬럼 이름 확인 (다양한 형식 지원)
        disp_col = None
        tmean_col = None

        for col in hydro_df.columns:
            col_lower = col.strip().lower()
            if &#34;disp&#34; in col_lower or &#34;displacement&#34; in col_lower:
                disp_col = col
            if &#34;tmean&#34; in col_lower or (&#34;mean&#34; in col_lower and &#34;draft&#34; in col_lower):
                tmean_col = col

        if disp_col is None or tmean_col is None:
            return 2.00

        # Displacement 및 Tmean 배열 추출
        disps = pd.to_numeric(hydro_df[disp_col], errors=&#34;coerce&#34;).dropna().values
        tmeans = pd.to_numeric(hydro_df[tmean_col], errors=&#34;coerce&#34;).dropna().values

        if len(disps) == 0 or len(tmeans) == 0:
            return 2.00

        # 정렬 확인 (필요시 정렬)
        sorted_idx = np.argsort(disps)
        disps = disps[sorted_idx]
        tmeans = tmeans[sorted_idx]

        # Clamp 및 보간
        if disp_t &lt;= disps[0]:
            return float(tmeans[0])
        elif disp_t &gt;= disps[-1]:
            return float(tmeans[-1])

        # 선형 보간
        tmean = np.interp(disp_t, disps, tmeans)
        return float(tmean)
    except Exception as e:
        return 2.00</code></pre>
</details>
<div class="desc"><p>Δdisp → Tmean 보간</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>disp_t</code></strong></dt>
<dd>배수량 (ton)</dd>
<dt><strong><code>hydro_df</code></strong></dt>
<dd>Hydro table DataFrame (Tmean_m, Displacement_t 또는 Disp_t 컬럼 필요)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tmean (m) - 선형 보간된 평균 흘수</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.load_hydro_table"><code class="name flex">
<span>def <span class="ident">load_hydro_table</span></span>(<span>path: Path) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_hydro_table(path: Path) -&gt; pd.DataFrame:
    df = _read_df_any(path).copy()
    need = {&#34;Tmean_m&#34;, &#34;TPC_t_per_cm&#34;, &#34;MTC_t_m_per_cm&#34;, &#34;LCF_m&#34;, &#34;LBP_m&#34;}

    # Normalize column names (strip whitespace, handle case)
    df.columns = [c.strip() for c in df.columns]
    cols_lower = {c.lower(): c for c in df.columns}

    # Column mapping for common variations
    col_map = {
        &#34;tmean_m&#34;: &#34;Tmean_m&#34;,
        &#34;tpc_t_per_cm&#34;: &#34;TPC_t_per_cm&#34;,
        &#34;mtc_t_m_per_cm&#34;: &#34;MTC_t_m_per_cm&#34;,
        &#34;mctc_t_m_per_cm&#34;: &#34;MTC_t_m_per_cm&#34;,  # Alternative spelling
        &#34;lcf_m&#34;: &#34;LCF_m&#34;,
        &#34;lbp_m&#34;: &#34;LBP_m&#34;,
    }

    # Check for missing columns
    missing = []
    for req_lower, req_std in col_map.items():
        if req_lower not in cols_lower and req_std not in df.columns:
            missing.append(req_std)

    if missing:
        raise ValueError(f&#34;Hydro table missing required columns: {sorted(missing)}&#34;)

    # Rename columns to standard names if needed
    rename_dict = {}
    for req_lower, req_std in col_map.items():
        if req_std not in df.columns and req_lower in cols_lower:
            rename_dict[cols_lower[req_lower]] = req_std

    if rename_dict:
        df = df.rename(columns=rename_dict)

    # Basic cleanup and validation
    df[&#34;Tmean_m&#34;] = pd.to_numeric(df[&#34;Tmean_m&#34;], errors=&#34;coerce&#34;)
    df[&#34;TPC_t_per_cm&#34;] = pd.to_numeric(df[&#34;TPC_t_per_cm&#34;], errors=&#34;coerce&#34;)
    df[&#34;MTC_t_m_per_cm&#34;] = pd.to_numeric(df[&#34;MTC_t_m_per_cm&#34;], errors=&#34;coerce&#34;)
    df[&#34;LCF_m&#34;] = pd.to_numeric(df[&#34;LCF_m&#34;], errors=&#34;coerce&#34;)

    # LBP_m is optional, use default if missing
    if &#34;LBP_m&#34; not in df.columns:
        df[&#34;LBP_m&#34;] = VesselParams.LBP
    else:
        df[&#34;LBP_m&#34;] = pd.to_numeric(df[&#34;LBP_m&#34;], errors=&#34;coerce&#34;).fillna(
            VesselParams.LBP
        )

    df_clean = (
        df.dropna(subset=[&#34;Tmean_m&#34;]).sort_values(&#34;Tmean_m&#34;).reset_index(drop=True)
    )

    # Validate with pydantic if available
    if HAS_PYDANTIC:
        for idx, row in df_clean.iterrows():
            try:
                hydro_data = {
                    &#34;tmean_m&#34;: float(row[&#34;Tmean_m&#34;]),
                    &#34;tpc_t_per_cm&#34;: float(row[&#34;TPC_t_per_cm&#34;]),
                    &#34;mtc_t_m_per_cm&#34;: float(row[&#34;MTC_t_m_per_cm&#34;]),
                    &#34;lcf_m&#34;: float(row[&#34;LCF_m&#34;]),
                    &#34;lbp_m&#34;: float(row[&#34;LBP_m&#34;]),
                }
                HydroPointModel(**hydro_data)
            except Exception as e:
                raise ValueError(
                    f&#34;Validation error for hydro table row {idx} (Tmean={row.get(&#39;Tmean_m&#39;, &#39;N/A&#39;)}): {e}&#34;
                )

    return df_clean</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.load_stage_table"><code class="name flex">
<span>def <span class="ident">load_stage_table</span></span>(<span>path: Path) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_stage_table(path: Path) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Load stage table with flexible column name mapping.&#34;&#34;&#34;
    df = _read_df_any(path).copy()
    colmap = {}
    for c in df.columns:
        cl = c.strip().lower()
        if cl in (&#34;stage&#34;, &#34;stage_name&#34;):
            colmap[c] = &#34;Stage&#34;
        elif cl in (&#34;dfwd_m&#34;, &#34;current_fwd_m&#34;, &#34;fwd_m&#34;, &#34;fwd&#34;):
            colmap[c] = &#34;Current_FWD_m&#34;
        elif cl in (&#34;daft_m&#34;, &#34;current_aft_m&#34;, &#34;aft_m&#34;, &#34;aft&#34;):
            colmap[c] = &#34;Current_AFT_m&#34;
        elif cl in (&#34;target_fwd_m&#34;, &#34;fwd_target_m&#34;):
            colmap[c] = &#34;Target_FWD_m&#34;
        elif cl in (&#34;target_aft_m&#34;, &#34;aft_target_m&#34;):
            colmap[c] = &#34;Target_AFT_m&#34;
        elif cl in (&#34;fwd_limit_m&#34;, &#34;limit_fwd_m&#34;):
            colmap[c] = &#34;FWD_Limit_m&#34;
        elif cl in (&#34;aft_limit_m&#34;, &#34;limit_aft_m&#34;):
            colmap[c] = &#34;AFT_Limit_m&#34;
        elif cl in (&#34;trim_limit_m&#34;, &#34;trim_abs_limit_m&#34;):
            colmap[c] = &#34;Trim_Abs_Limit_m&#34;

    df = df.rename(columns=colmap)
    need = {&#34;Stage&#34;, &#34;Current_FWD_m&#34;, &#34;Current_AFT_m&#34;}
    miss = need - set(df.columns)
    if miss:
        raise ValueError(f&#34;stage table missing columns: {sorted(miss)}&#34;)
    for c in [
        &#34;Current_FWD_m&#34;,
        &#34;Current_AFT_m&#34;,
        &#34;Target_FWD_m&#34;,
        &#34;Target_AFT_m&#34;,
        &#34;FWD_Limit_m&#34;,
        &#34;AFT_Limit_m&#34;,
        &#34;Trim_Abs_Limit_m&#34;,
    ]:
        if c in df.columns:
            df[c] = pd.to_numeric(df[c], errors=&#34;coerce&#34;)
    return df</code></pre>
</details>
<div class="desc"><p>Load stage table with flexible column name mapping.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.load_tanks_from_file"><code class="name flex">
<span>def <span class="ident">load_tanks_from_file</span></span>(<span>path: Path) ‑> List[01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_tanks_from_file(path: Path) -&gt; List[Tank]:
    df = _read_df_any(path).copy()
    # Normalize columns
    df.columns = [c.strip() for c in df.columns]

    # Required check
    required = {&#34;Tank&#34;, &#34;Capacity_t&#34;, &#34;x_from_mid_m&#34;}
    missing = required - set(df.columns)
    if missing:
        raise ValueError(f&#34;Tank file missing columns: {missing}&#34;)

    # Set defaults for optional
    defaults = {
        &#34;Current_t&#34;: 0.0,
        &#34;Min_t&#34;: 0.0,
        &#34;Max_t&#34;: 0.0,
        &#34;mode&#34;: &#34;FILL_DISCHARGE&#34;,
        &#34;use_flag&#34;: &#34;Y&#34;,
        &#34;pump_rate_tph&#34;: VesselParams.PUMP_RATE,
        &#34;group&#34;: &#34;MID&#34;,
        &#34;priority_weight&#34;: 1.0,
        &#34;density_t_per_m3&#34;: VesselParams.DENSITY,
        &#34;freeze_flag&#34;: &#34;N&#34;,
    }
    for col, val in defaults.items():
        if col not in df.columns:
            df[col] = val

    tanks = []
    for _, r in df.iterrows():
        cap = float(r[&#34;Capacity_t&#34;])
        mx = float(r[&#34;Max_t&#34;])
        if mx &lt;= 0:
            mx = cap

        tank_data = {
            &#34;name&#34;: str(r[&#34;Tank&#34;]),
            &#34;x_from_mid_m&#34;: float(r[&#34;x_from_mid_m&#34;]),
            &#34;current_t&#34;: min(max(float(r[&#34;Current_t&#34;]), 0), mx),
            &#34;min_t&#34;: float(r[&#34;Min_t&#34;]),
            &#34;max_t&#34;: mx,
            &#34;mode&#34;: str(r[&#34;mode&#34;]),
            &#34;use_flag&#34;: str(r[&#34;use_flag&#34;]),
            &#34;pump_rate_tph&#34;: float(r[&#34;pump_rate_tph&#34;]),
            &#34;group&#34;: str(r[&#34;group&#34;]) if pd.notna(r.get(&#34;group&#34;)) else None,
            &#34;priority_weight&#34;: float(r[&#34;priority_weight&#34;]),
            &#34;density_t_per_m3&#34;: float(r[&#34;density_t_per_m3&#34;]),
            &#34;freeze_flag&#34;: str(r[&#34;freeze_flag&#34;]),
        }

        # Validate with pydantic if available
        if HAS_PYDANTIC:
            try:
                tank_model = TankModel(**tank_data)
                tanks.append(tank_model.to_tank())
            except Exception as e:
                raise ValueError(f&#34;Validation error for tank {tank_data[&#39;name&#39;]}: {e}&#34;)
        else:
            tanks.append(Tank(**tank_data))
    return tanks</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.optimize_preballast_for_roro"><code class="name flex">
<span>def <span class="ident">optimize_preballast_for_roro</span></span>(<span>base_disp_t: float,<br>base_tmean_m: float,<br>hydro_df: Optional[pd.DataFrame],<br>w_tr_unit_t: float = 271.2,<br>fr_tr1_stow: float = 42.0,<br>fr_tr2_ramp: float = 17.95,<br>fr_preballast: float = 3.0,<br>search_min_t: float = 20.0,<br>search_max_t: float = 400.0,<br>search_step_t: float = 1.0,<br>params: Optional[Dict[str, Any]] = None) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize_preballast_for_roro(
    base_disp_t: float,
    base_tmean_m: float,
    hydro_df: Optional[pd.DataFrame],
    w_tr_unit_t: float = 271.20,
    fr_tr1_stow: float = 42.0,
    fr_tr2_ramp: float = 17.95,
    fr_preballast: float = 3.0,
    search_min_t: float = 20.0,
    search_max_t: float = 400.0,
    search_step_t: float = 1.0,
    params: Optional[Dict[str, Any]] = None,
) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Optimize pre-ballast weight for Stage 5_PreBallast and Stage 6A_Critical.

    Args:
        base_disp_t: Base displacement (t)
        base_tmean_m: Base mean draft (m)
        hydro_df: Hydro table DataFrame
        w_tr_unit_t: Transformer unit weight (t)
        fr_tr1_stow: TR1 stow Frame number
        fr_tr2_ramp: TR2 ramp Frame number
        fr_preballast: Pre-ballast Frame number
        search_min_t: Minimum search weight (t)
        search_max_t: Maximum search weight (t)
        search_step_t: Search step (t)
        params: Additional parameters dict

    Returns:
        dict with keys: &#34;ok&#34;, &#34;reason&#34;, &#34;w_preballast_t&#34;, &#34;stage5&#34;, &#34;stage6A&#34;
    &#34;&#34;&#34;
    if params is None:
        params = {}

    min_fwd = params.get(&#34;min_fwd_draft_m&#34;, VesselParams.MIN_DRAFT)
    max_fwd = params.get(&#34;max_fwd_draft_ops_m&#34;, VesselParams.MAX_FWD_DRAFT_OPS)
    trim_limit = params.get(&#34;trim_limit_abs_cm&#34;, VesselParams.TRIM_LIMIT_CM)
    check_stage5 = params.get(&#34;CHECK_STAGE5&#34;, True)

    if search_step_t &lt;= 0:
        raise ValueError(&#34;search_step_t must be positive.&#34;)

    best: Optional[Dict[str, Any]] = None
    best_metric: Optional[float] = None

    w = search_min_t
    while w &lt;= search_max_t + 1e-9:
        result = _stage_moment_and_drafts_for_preballast(
            w_tr_unit_t=w_tr_unit_t,
            w_preballast_t=w,
            fr_tr1_stow=fr_tr1_stow,
            fr_tr2_ramp=fr_tr2_ramp,
            fr_preballast=fr_preballast,
            base_disp_t=base_disp_t,
            base_tmean_m=base_tmean_m,
            hydro_df=hydro_df,
            params=params,
        )

        st5 = result[&#34;stage5&#34;]
        st6 = result[&#34;stage6A&#34;]

        fwd5 = st5[&#34;FWD_m&#34;]
        fwd6 = st6[&#34;FWD_m&#34;]
        trim5 = abs(st5[&#34;Trim_cm&#34;])
        trim6 = abs(st6[&#34;Trim_cm&#34;])

        # Gate 1: Draft limits
        if check_stage5 and not (min_fwd &lt;= fwd5 &lt;= max_fwd):
            w += search_step_t
            continue
        if not (min_fwd &lt;= fwd6 &lt;= max_fwd):
            w += search_step_t
            continue

        # Gate 2: Trim envelope
        if check_stage5 and trim5 &gt; trim_limit:
            w += search_step_t
            continue
        if trim6 &gt; trim_limit:
            w += search_step_t
            continue

        # Objective: Stage 6A FWD as close as possible to ops limit
        margin5 = max_fwd - fwd5
        margin6 = max_fwd - fwd6
        metric = abs(margin6) + 0.1 * abs(margin5)  # Stage 5 penalty 10%

        if best_metric is None or metric &lt; best_metric - 1e-9:
            best_metric = metric
            best = result
        elif best is not None and abs(metric - best_metric) &lt; 1e-9:
            # Tie-breaker: smaller ballast preferred
            if w &lt; best[&#34;w_preballast_t&#34;]:
                best_metric = metric
                best = result

        w += search_step_t

    if best is None:
        return {
            &#34;ok&#34;: False,
            &#34;reason&#34;: &#34;No feasible pre-ballast found within search range.&#34;,
            &#34;w_preballast_t&#34;: None,
            &#34;stage5&#34;: None,
            &#34;stage6A&#34;: None,
        }

    return {
        &#34;ok&#34;: True,
        &#34;reason&#34;: &#34;Feasible pre-ballast found.&#34;,
        &#34;w_preballast_t&#34;: best[&#34;w_preballast_t&#34;],
        &#34;stage5&#34;: best[&#34;stage5&#34;],
        &#34;stage6A&#34;: best[&#34;stage6A&#34;],
    }</code></pre>
</details>
<div class="desc"><p>Optimize pre-ballast weight for Stage 5_PreBallast and Stage 6A_Critical.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_disp_t</code></strong></dt>
<dd>Base displacement (t)</dd>
<dt><strong><code>base_tmean_m</code></strong></dt>
<dd>Base mean draft (m)</dd>
<dt><strong><code>hydro_df</code></strong></dt>
<dd>Hydro table DataFrame</dd>
<dt><strong><code>w_tr_unit_t</code></strong></dt>
<dd>Transformer unit weight (t)</dd>
<dt><strong><code>fr_tr1_stow</code></strong></dt>
<dd>TR1 stow Frame number</dd>
<dt><strong><code>fr_tr2_ramp</code></strong></dt>
<dd>TR2 ramp Frame number</dd>
<dt><strong><code>fr_preballast</code></strong></dt>
<dd>Pre-ballast Frame number</dd>
<dt><strong><code>search_min_t</code></strong></dt>
<dd>Minimum search weight (t)</dd>
<dt><strong><code>search_max_t</code></strong></dt>
<dd>Maximum search weight (t)</dd>
<dt><strong><code>search_step_t</code></strong></dt>
<dd>Search step (t)</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Additional parameters dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict with keys</code></dt>
<dd>"ok", "reason", "w_preballast_t", "stage5", "stage6A"</dd>
</dl></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.print_summary"><code class="name flex">
<span>def <span class="ident">print_summary</span></span>(<span>res: <a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult">OptimizationResult</a>,<br>initial: Tuple[float, float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_summary(res: OptimizationResult, initial: Tuple[float, float]):
    if not res.success:
        print(f&#34;\n[ERROR] Optimization Failed: {res.msg}&#34;)
        return

    print(&#34;\n&#34; + &#34;=&#34; * 60)
    print(&#34; OPTIMIZED BALLAST PLAN&#34;)
    print(&#34;=&#34; * 60)

    print(&#34;Draft Change:&#34;)
    print(f&#34;  FWD:  {initial[0]:.3f}m -&gt; {res.summary[&#39;dfwd_new_m&#39;]:.3f}m&#34;)
    print(f&#34;  AFT:  {initial[1]:.3f}m -&gt; {res.summary[&#39;daft_new_m&#39;]:.3f}m&#34;)
    print(f&#34;  TRIM: {initial[1]-initial[0]:.3f}m -&gt; {res.summary[&#39;trim_new_m&#39;]:.3f}m&#34;)
    print(f&#34;  Total Ballast Moved: {res.summary[&#39;total_w_t&#39;]:.1f} t&#34;)
    print(f&#34;  Total Pump Time:     {res.summary.get(&#39;total_time_h&#39;, 0):.2f} h&#34;)
    print(&#34;-&#34; * 60)

    if not res.plan_df.empty:
        print(res.plan_df.to_string(index=False))
    else:
        print(&#34;No ballast operations required.&#34;)
    print(&#34;=&#34; * 60 + &#34;\n&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.redistribute_excess_ballast"><code class="name flex">
<span>def <span class="ident">redistribute_excess_ballast</span></span>(<span>excess_t: float,<br>source_tank: <a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank">Tank</a>,<br>available_tanks: List[<a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank">Tank</a>],<br>tank_states: Dict[str, float]) ‑> Dict[str, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redistribute_excess_ballast(
    excess_t: float,
    source_tank: Tank,
    available_tanks: List[Tank],
    tank_states: Dict[str, float],
) -&gt; Dict[str, float]:
    &#34;&#34;&#34;
    Redistribute excess ballast to other available tanks.

    Args:
        excess_t: Excess ballast amount to redistribute (t)
        source_tank: Source tank that exceeded capacity
        available_tanks: List of available tanks for redistribution
        tank_states: Current tank states dict

    Returns:
        dict mapping tank names to additional transfer amounts
    &#34;&#34;&#34;
    redistribution = {}
    remaining_excess = excess_t

    # Find tanks with available capacity (prioritize same group)
    same_group_tanks = [
        t
        for t in available_tanks
        if t.group == source_tank.group and t.name != source_tank.name
    ]
    other_tanks = [
        t
        for t in available_tanks
        if t.group != source_tank.group and t.name != source_tank.name
    ]

    # Try same group first, then other groups
    for tank in same_group_tanks + other_tanks:
        if remaining_excess &lt;= 0.01:
            break

        current_level = tank_states.get(tank.name, tank.current_t)
        available_capacity = tank.max_t - current_level

        if available_capacity &gt; 0.01:
            transfer_amount = min(remaining_excess, available_capacity)
            redistribution[tank.name] = transfer_amount
            remaining_excess -= transfer_amount

    return redistribution</code></pre>
</details>
<div class="desc"><p>Redistribute excess ballast to other available tanks.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>excess_t</code></strong></dt>
<dd>Excess ballast amount to redistribute (t)</dd>
<dt><strong><code>source_tank</code></strong></dt>
<dd>Source tank that exceeded capacity</dd>
<dt><strong><code>available_tanks</code></strong></dt>
<dd>List of available tanks for redistribution</dd>
<dt><strong><code>tank_states</code></strong></dt>
<dd>Current tank states dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>dict mapping tank names to additional transfer amounts</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.run_batch_mode"><code class="name flex">
<span>def <span class="ident">run_batch_mode</span></span>(<span>args)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_batch_mode(args):
    print(&#34;Running Batch Mode...&#34;)
    tanks = load_tanks_from_file(Path(args.tank))
    hydro_df = load_hydro_table(Path(args.hydro)) if args.hydro else None

    optimizer = BallastOptimizer(tanks, hydro_df)

    # Stage table loop mode
    if args.stage:
        st = load_stage_table(Path(args.stage))
        cur_tanks = tanks
        all_plan = []
        summary = []

        for _, r in st.iterrows():
            plan, pred, hydro, delta = optimizer.iterate_hydro_solve(
                dfwd0=float(r[&#34;Current_FWD_m&#34;]),
                daft0=float(r[&#34;Current_AFT_m&#34;]),
                iterate_hydro=getattr(args, &#34;iterate_hydro&#34;, 2),
                target_fwd=(
                    float(r[&#34;Target_FWD_m&#34;])
                    if &#34;Target_FWD_m&#34; in r and pd.notna(r[&#34;Target_FWD_m&#34;])
                    else args.target_fwd
                ),
                target_aft=(
                    float(r[&#34;Target_AFT_m&#34;])
                    if &#34;Target_AFT_m&#34; in r and pd.notna(r[&#34;Target_AFT_m&#34;])
                    else args.target_aft
                ),
                limit_fwd=(
                    float(r[&#34;FWD_Limit_m&#34;])
                    if &#34;FWD_Limit_m&#34; in r and pd.notna(r[&#34;FWD_Limit_m&#34;])
                    else args.fwd_limit
                ),
                limit_aft=(
                    float(r[&#34;AFT_Limit_m&#34;])
                    if &#34;AFT_Limit_m&#34; in r and pd.notna(r[&#34;AFT_Limit_m&#34;])
                    else args.aft_limit
                ),
                limit_trim=(
                    float(r[&#34;Trim_Abs_Limit_m&#34;])
                    if &#34;Trim_Abs_Limit_m&#34; in r and pd.notna(r[&#34;Trim_Abs_Limit_m&#34;])
                    else args.trim_limit
                ),
                prefer_time=getattr(args, &#34;prefer_time&#34;, True),
            )

            if not plan.empty:
                p2 = plan.copy()
                p2.insert(0, &#34;Stage&#34;, str(r[&#34;Stage&#34;]))
                all_plan.append(p2)

            summary.append(
                {
                    &#34;Stage&#34;: str(r[&#34;Stage&#34;]),
                    &#34;Current_FWD_m&#34;: round(float(r[&#34;Current_FWD_m&#34;]), 2),
                    &#34;Current_AFT_m&#34;: round(float(r[&#34;Current_AFT_m&#34;]), 2),
                    &#34;New_FWD_m&#34;: round(pred[&#34;dfwd_new_m&#34;], 2),
                    &#34;New_AFT_m&#34;: round(pred[&#34;daft_new_m&#34;], 2),
                    &#34;ΔW_t&#34;: round(pred[&#34;total_w_t&#34;], 2),
                    &#34;PumpTime_h&#34;: round(pred.get(&#34;total_time_h&#34;, 0.0), 2),
                    &#34;viol_fwd_m&#34;: round(pred.get(&#34;viol_fwd_m&#34;, 0.0), 3),
                }
            )

            # Validate stage result before proceeding
            validation_passed = True
            validation_errors = []

            # Check draft limits
            if pred[&#34;dfwd_new_m&#34;] &lt; VesselParams.MIN_DRAFT:
                validation_errors.append(
                    f&#34;FWD draft {pred[&#39;dfwd_new_m&#39;]:.3f}m below minimum&#34;
                )
                validation_passed = False
            if pred[&#34;dfwd_new_m&#34;] &gt; VesselParams.MAX_FWD_DRAFT_OPS:
                validation_errors.append(
                    f&#34;FWD draft {pred[&#39;dfwd_new_m&#39;]:.3f}m exceeds limit&#34;
                )
                validation_passed = False
            if pred[&#34;daft_new_m&#34;] &gt; VesselParams.MAX_AFT_DRAFT_OPS:
                validation_errors.append(
                    f&#34;AFT draft {pred[&#39;daft_new_m&#39;]:.3f}m exceeds limit&#34;
                )
                validation_passed = False

            # Check trim limit
            trim_cm = abs(pred[&#34;trim_new_m&#34;]) * 100.0
            if trim_cm &gt; VesselParams.TRIM_LIMIT_CM:
                validation_errors.append(f&#34;Trim {trim_cm:.1f}cm exceeds limit&#34;)
                validation_passed = False

            # Check violations in limit mode
            if pred.get(&#34;viol_fwd_m&#34;, 0.0) &gt; 0.01 or pred.get(&#34;viol_aft_m&#34;, 0.0) &gt; 0.01:
                validation_errors.append(&#34;Draft limit violations detected&#34;)
                validation_passed = False

            if not validation_passed:
                print(f&#34;\n[WARNING] Stage {r[&#39;Stage&#39;]} validation failed:&#34;)
                for err in validation_errors:
                    print(f&#34;  - {err}&#34;)
                if getattr(args, &#34;strict_validation&#34;, False):
                    print(
                        &#34;[ERROR] Strict validation enabled - stopping stage processing&#34;
                    )
                    break

            # Update tanks for next stage
            cur_tanks = optimizer.apply_delta_to_tanks(delta)
            optimizer.tanks = cur_tanks

        # Output stage results
        if all_plan:
            df_all_plan = pd.concat(all_plan, ignore_index=True)
            out_stage_plan = getattr(args, &#34;out_stage_plan&#34;, &#34;ballast_stage_plan.csv&#34;)
            out_stage_path = Path(out_stage_plan)
            out_stage_path.parent.mkdir(parents=True, exist_ok=True)
            df_all_plan.to_csv(out_stage_path, index=False, encoding=&#34;utf-8-sig&#34;)
            print(f&#34;Stage plan saved to {out_stage_path}&#34;)

            # Pipeline compatibility: also write --out_plan if provided
            out_plan = getattr(args, &#34;out_plan&#34;, &#34;&#34;) or &#34;&#34;
            if out_plan:
                out_plan_path = Path(out_plan)
                if out_plan_path.resolve() != out_stage_path.resolve():
                    out_plan_path.parent.mkdir(parents=True, exist_ok=True)
                    df_all_plan.to_csv(out_plan_path, index=False, encoding=&#34;utf-8-sig&#34;)
                    print(f&#34;Plan saved to {out_plan_path}&#34;)

        # Prepare data for Excel
        summary_df = pd.DataFrame(summary)
        df_all_plan = (
            pd.concat(all_plan, ignore_index=True) if all_plan else pd.DataFrame()
        )

        # Build tank log and BWRB log if available (for both Excel and CSV export)
        tank_log_df = None
        if getattr(args, &#34;tanklog_out&#34;, None) and cur_tanks:
            tank_log_df = build_tank_log(cur_tanks, {})

        bwrb_log_df = None
        if args.bwrb_out and not df_all_plan.empty:
            master_verified = getattr(args, &#34;master_verified&#34;, &#34;N&#34;)
            bwrb_log_df = generate_bwrb_log(
                df_all_plan,
                args.vessel,
                args.location_name,
                args.lat,
                args.lon,
                args.officer,
                master_verified,
            )

        # Excel export for stage mode (default behavior unless --no_excel is set)
        if not getattr(args, &#34;no_excel&#34;, False):
            excel_output_path = None
            if getattr(args, &#34;excel_out&#34;, None):
                excel_output_path = Path(args.excel_out)
            else:
                # Default Excel file name for stage mode
                excel_output_path = Path(&#34;ballast_stage_plan.xlsx&#34;)

            try:

                export_to_excel(
                    df_all_plan,
                    summary_df,
                    tank_log_df,
                    bwrb_log_df,
                    excel_output_path,
                )
                print(f&#34;Excel file saved to {excel_output_path}&#34;)
            except ImportError as e:
                print(f&#34;WARNING: Excel export failed: {e}&#34;)
            except Exception as e:
                print(f&#34;ERROR: Excel export failed: {e}&#34;)

        # CSV outputs (optional, only if specified)
        if args.out_summary:
            out_summary_path = Path(args.out_summary)
            out_summary_path.parent.mkdir(parents=True, exist_ok=True)
            summary_df.to_csv(out_summary_path, index=False, encoding=&#34;utf-8-sig&#34;)
            print(f&#34;Summary saved to {out_summary_path}&#34;)

        # Optional CSV logs (stage mode)
        if getattr(args, &#34;tanklog_out&#34;, &#34;&#34;) and tank_log_df is not None:
            Path(args.tanklog_out).parent.mkdir(parents=True, exist_ok=True)
            tank_log_df.to_csv(args.tanklog_out, index=False, encoding=&#34;utf-8-sig&#34;)
        if getattr(args, &#34;bwrb_out&#34;, &#34;&#34;) and bwrb_log_df is not None:
            Path(args.bwrb_out).parent.mkdir(parents=True, exist_ok=True)
            bwrb_log_df.to_csv(args.bwrb_out, index=False, encoding=&#34;utf-8-sig&#34;)

        return

    # Single solve mode
    # Check inputs
    if args.current_fwd is None or args.current_aft is None:
        print(&#34;Error: --current_fwd and --current_aft are required (or use --stage).&#34;)
        return

    # Solve
    res = optimizer.solve(
        args.current_fwd,
        args.current_aft,
        target_fwd=args.target_fwd,
        target_aft=args.target_aft,
        limit_fwd=args.fwd_limit,
        limit_aft=args.aft_limit,
        limit_trim=args.trim_limit,
        prefer_time=getattr(args, &#34;prefer_time&#34;, True),
    )

    if not res.success:
        print(f&#34;Optimization Failed: {res.msg}&#34;)
        return

    # Prepare data for Excel (always prepare, even if not exporting)
    summary_df = pd.DataFrame([res.summary])
    tank_log_df = build_tank_log(optimizer.tanks, res.delta)
    master_verified = getattr(args, &#34;master_verified&#34;, &#34;N&#34;)
    bwrb_log_df = generate_bwrb_log(
        res.plan_df,
        args.vessel,
        args.location_name,
        args.lat,
        args.lon,
        args.officer,
        master_verified,
    )

    # Excel export (default behavior unless --no_excel is set)
    excel_output_path = None
    if not getattr(args, &#34;no_excel&#34;, False):
        if getattr(args, &#34;excel_out&#34;, None):
            excel_output_path = Path(args.excel_out)
        else:
            # Default Excel file name
            excel_output_path = Path(&#34;ballast_plan.xlsx&#34;)

        try:
            export_to_excel(
                res.plan_df,
                summary_df,
                tank_log_df,
                bwrb_log_df,
                excel_output_path,
            )
            print(f&#34;Excel file saved to {excel_output_path}&#34;)
        except ImportError as e:
            print(f&#34;WARNING: Excel export failed: {e}&#34;)
        except Exception as e:
            print(f&#34;ERROR: Excel export failed: {e}&#34;)

    # CSV outputs (optional, only if specified)
    if args.out_plan:
        res.plan_df.to_csv(args.out_plan, index=False, encoding=&#34;utf-8-sig&#34;)
        print(f&#34;Plan saved to {args.out_plan}&#34;)

    if args.out_summary:
        summary_df.to_csv(args.out_summary, index=False, encoding=&#34;utf-8-sig&#34;)
        print(f&#34;Summary saved to {args.out_summary}&#34;)

    if args.bwrb_out:
        bwrb_log_df.to_csv(args.bwrb_out, index=False, encoding=&#34;utf-8-sig&#34;)
        print(f&#34;BWRB Log saved to {args.bwrb_out}&#34;)

    if getattr(args, &#34;tanklog_out&#34;, None):
        tank_log_df.to_csv(args.tanklog_out, index=False, encoding=&#34;utf-8-sig&#34;)
        print(f&#34;Tank log saved to {args.tanklog_out}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.run_interactive_mode"><code class="name flex">
<span>def <span class="ident">run_interactive_mode</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_interactive_mode():
    print(&#34;\nInitializing Ballast Optimizer...&#34;)
    tanks = get_default_tanks()

    # Try to load CSVs if they exist in CWD, else silent fallback
    # Check for multiple possible filenames
    tank_files = [&#34;tank_ssot.csv&#34;, &#34;tank_ssot_for_solver.csv&#34;]
    hydro_files = [&#34;hydro_table.csv&#34;, &#34;hydro_table_for_solver.csv&#34;]

    tank_loaded = False
    for tank_file in tank_files:
        if Path(tank_file).exists():
            print(f&#34;Loading local {tank_file}...&#34;)
            try:
                tanks = load_tanks_from_file(Path(tank_file))
                tank_loaded = True
                break
            except Exception as e:
                print(f&#34;Warning: Failed to load {tank_file}: {e}&#34;)
                continue

    if not tank_loaded:
        print(&#34;Using default hardcoded tank data (LCT BUSHRA)&#34;)

    hydro = None
    for hydro_file in hydro_files:
        if Path(hydro_file).exists():
            print(f&#34;Loading local {hydro_file}...&#34;)
            try:
                hydro = load_hydro_table(Path(hydro_file))
                break
            except Exception as e:
                print(f&#34;Warning: Failed to load {hydro_file}: {e}&#34;)
                continue

    if hydro is None:
        print(&#34;Using default synthetic hydro table&#34;)

    optimizer = BallastOptimizer(tanks, hydro)

    # Simple state tracking for the session
    state = {&#34;dfwd&#34;: 2.5, &#34;daft&#34;: 3.0}

    while True:
        print(
            f&#34;\n--- CURRENT STATE: FWD {state[&#39;dfwd&#39;]:.2f}m / AFT {state[&#39;daft&#39;]:.2f}m ---&#34;
        )
        print(&#34;1. Set Current Drafts&#34;)
        print(&#34;2. Set Tank Levels&#34;)
        print(&#34;3. Solve for Target Draft&#34;)
        print(&#34;4. Optimization: AGI Arrival (Max Fwd 2.7m)&#34;)
        print(&#34;5. Optimization: Pre-Ballast (Simulate Cargo)&#34;)
        print(&#34;6. Show Tank Status&#34;)
        print(&#34;q. Quit&#34;)

        choice = input(&#34;Select &gt; &#34;).strip().lower()

        if choice == &#34;q&#34;:
            break

        elif choice == &#34;1&#34;:
            try:
                state[&#34;dfwd&#34;] = float(input(&#34;FWD Draft (m): &#34;))
                state[&#34;daft&#34;] = float(input(&#34;AFT Draft (m): &#34;))
            except:
                print(&#34;Invalid number&#34;)

        elif choice == &#34;2&#34;:
            print(&#34;Enter Tank Name and % (e.g., &#39;FW1.P 50&#39;). Empty to finish.&#34;)
            while True:
                line = input(&#34;Tank &gt; &#34;)
                if not line:
                    break
                parts = line.split()
                if len(parts) &gt;= 2:
                    tname = parts[0]
                    try:
                        pct = float(parts[1])
                        found = False
                        for t in optimizer.tanks:
                            if t.name.lower() == tname.lower():
                                t.current_t = t.max_t * (pct / 100.0)
                                print(f&#34;Updated {t.name} to {t.current_t:.1f}t&#34;)
                                found = True
                        if not found:
                            print(&#34;Tank not found&#34;)
                    except:
                        print(&#34;Invalid format&#34;)

        elif choice == &#34;3&#34;:
            try:
                tf = float(input(&#34;Target FWD (m): &#34;))
                ta = float(input(&#34;Target AFT (m): &#34;))
                res = optimizer.solve(
                    state[&#34;dfwd&#34;], state[&#34;daft&#34;], target_fwd=tf, target_aft=ta
                )
                print_summary(res, (state[&#34;dfwd&#34;], state[&#34;daft&#34;]))
                if (
                    res.success
                    and input(&#34;Apply to virtual tanks? (y/n) &#34;).lower() == &#34;y&#34;
                ):
                    optimizer.update_tanks(res.delta)
                    state[&#34;dfwd&#34;] = res.summary[&#34;dfwd_new_m&#34;]
                    state[&#34;daft&#34;] = res.summary[&#34;daft_new_m&#34;]
            except ValueError:
                print(&#34;Invalid inputs&#34;)

        elif choice == &#34;4&#34;:
            # AGI Arrival Logic: Max FWD 2.7 + Tide
            try:
                tide = float(input(&#34;Tide Height (m, default 0): &#34;) or 0)
                limit = VesselParams.MAX_FWD_DRAFT_OPS + tide
                print(f&#34;Optimizing for FWD Draft &lt;= {limit:.2f}m...&#34;)

                # If already compliant
                if state[&#34;dfwd&#34;] &lt;= limit:
                    print(&#34;Already compliant.&#34;)
                    continue

                # Use LIMIT mode in Solver
                res = optimizer.solve(
                    state[&#34;dfwd&#34;], state[&#34;daft&#34;], limit_fwd=limit - 0.05
                )  # 5cm safety
                print_summary(res, (state[&#34;dfwd&#34;], state[&#34;daft&#34;]))

                if res.success and input(&#34;Apply? (y/n) &#34;).lower() == &#34;y&#34;:
                    optimizer.update_tanks(res.delta)
                    state[&#34;dfwd&#34;] = res.summary[&#34;dfwd_new_m&#34;]
                    state[&#34;daft&#34;] = res.summary[&#34;daft_new_m&#34;]

            except ValueError:
                print(&#34;Error in AGI calculation&#34;)

        elif choice == &#34;5&#34;:
            # Pre-Ballast
            try:
                w = float(input(&#34;Cargo Weight (t): &#34;))
                lcg = float(input(&#34;Cargo LCG from AP (m): &#34;))
                # Convert AP LCG to Midship X
                x_cargo = lcg - (VesselParams.LBP / 2.0)

                # Create a temporary &#39;tank&#39; for cargo to see effect
                sim_delta = {&#34;CARGO&#34;: w}
                # Temporary tank obj
                cargo_t = Tank(&#34;CARGO&#34;, x_cargo, 0, 0, 0, &#34;&#34;, &#34;&#34;, 0, None, 0, 0, &#34;&#34;)
                opt_sim = BallastOptimizer([cargo_t], optimizer.hydro_df)
                pred = opt_sim.predict_drafts(state[&#34;dfwd&#34;], state[&#34;daft&#34;], sim_delta)

                print(
                    f&#34;\nSimulated Draft after Cargo: FWD {pred[&#39;dfwd_new_m&#39;]:.2f}, AFT {pred[&#39;daft_new_m&#39;]:.2f}&#34;
                )

                limit = VesselParams.MAX_FWD_DRAFT_OPS
                if pred[&#34;dfwd_new_m&#34;] &gt; limit:
                    print(
                        f&#34;WARNING: Exceeds limit {limit}m. Calculating pre-ballast...&#34;
                    )
                    # Strategy: Target a draft NOW such that adding cargo lands us at limit
                    # Simple heuristic loop or complex calc?
                    # Let&#39;s target FWD = Limit - (Cargo_Effect)
                    cargo_effect_fwd = pred[&#34;dfwd_new_m&#34;] - state[&#34;dfwd&#34;]
                    target_pre_fwd = limit - cargo_effect_fwd - 0.05

                    # We usually want to keep even keel or slight trim aft.
                    # Let&#39;s try to maintain current trim, just sink/rise
                    trim = state[&#34;daft&#34;] - state[&#34;dfwd&#34;]
                    target_pre_aft = target_pre_fwd + trim

                    print(
                        f&#34;Targeting Pre-Ballast Drafts: FWD {target_pre_fwd:.2f}, AFT {target_pre_aft:.2f}&#34;
                    )

                    res = optimizer.solve(
                        state[&#34;dfwd&#34;],
                        state[&#34;daft&#34;],
                        target_fwd=target_pre_fwd,
                        target_aft=target_pre_aft,
                    )
                    print_summary(res, (state[&#34;dfwd&#34;], state[&#34;daft&#34;]))

                    if (
                        res.success
                        and input(&#34;Apply Pre-Ballast? (y/n) &#34;).lower() == &#34;y&#34;
                    ):
                        optimizer.update_tanks(res.delta)
                        state[&#34;dfwd&#34;] = res.summary[&#34;dfwd_new_m&#34;]
                        state[&#34;daft&#34;] = res.summary[&#34;daft_new_m&#34;]
                else:
                    print(&#34;Safe to load without pre-ballast.&#34;)

            except Exception as e:
                print(f&#34;Error: {e}&#34;)

        elif choice == &#34;6&#34;:
            print(f&#34;\n{&#39;TANK&#39;:&lt;12} {&#39;CAP(t)&#39;:&lt;8} {&#39;CUR(t)&#39;:&lt;8} {&#39;PCT&#39;:&lt;6} {&#39;GRP&#39;:&lt;5}&#34;)
            print(&#34;-&#34; * 45)
            for t in optimizer.tanks:
                print(
                    f&#34;{t.name:&lt;12} {t.max_t:&lt;8.1f} {t.current_t:&lt;8.1f} {t.current_pct:&lt;6.0f} {t.group or &#39;&#39;}&#34;
                )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.run_roro_mode"><code class="name flex">
<span>def <span class="ident">run_roro_mode</span></span>(<span>args)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_roro_mode(args):
    &#34;&#34;&#34;Run RORO stage-by-stage ballast optimization.&#34;&#34;&#34;
    print(&#34;Running RORO Mode...&#34;)

    # Load tanks and hydro table
    tanks = load_tanks_from_file(Path(args.tank)) if args.tank else get_default_tanks()
    hydro_df = load_hydro_table(Path(args.hydro)) if args.hydro else None

    # RORO parameters
    base_disp_t = getattr(args, &#34;roro_base_disp&#34;, 2800.0)
    w_tr = getattr(args, &#34;roro_w_tr&#34;, 271.20)
    fr_tr1_stow = getattr(args, &#34;roro_fr_tr1_stow&#34;, 42.0)
    fr_tr1_ramp_start = getattr(args, &#34;roro_fr_tr1_ramp_start&#34;, 40.15)
    fr_tr1_ramp_mid = getattr(args, &#34;roro_fr_tr1_ramp_mid&#34;, 37.00)
    fr_tr2_ramp = getattr(args, &#34;roro_fr_tr2_ramp&#34;, 17.95)
    fr_tr2_stow = getattr(args, &#34;roro_fr_tr2_stow&#34;, 40.00)
    fr_preballast = getattr(args, &#34;roro_fr_preballast&#34;, 3.0)

    # Calculate base_tmean from hydro table
    if hydro_df is not None and not hydro_df.empty:
        base_tmean_m = interpolate_tmean_from_disp(base_disp_t, hydro_df)
        print(f&#34;[INFO] base_tmean_m calculated from hydro table: {base_tmean_m:.3f} m&#34;)
    else:
        base_tmean_m = 2.00  # Fallback
        print(f&#34;[WARNING] Using fallback base_tmean_m: {base_tmean_m:.3f} m&#34;)

    # Parameters dict
    params = {
        &#34;MTC&#34;: VesselParams.MTC,
        &#34;LCF&#34;: VesselParams.LCF,
        &#34;LBP&#34;: VesselParams.LBP,
        &#34;TPC&#34;: VesselParams.TPC,
        &#34;D_vessel&#34;: VesselParams.D_VESSEL,
        &#34;max_fwd_draft_ops_m&#34;: VesselParams.MAX_FWD_DRAFT_OPS,
        &#34;trim_limit_abs_cm&#34;: VesselParams.TRIM_LIMIT_CM,
        &#34;gm_min_m&#34;: VesselParams.MIN_GM_M,
        &#34;min_fwd_draft_m&#34;: VesselParams.MIN_DRAFT,
        &#34;CHECK_STAGE5&#34;: True,
        &#34;pump_rate_effective_tph&#34;: 100.0,
    }

    # Pre-ballast optimization
    preballast_opt = None
    stage5_pb = None
    stage6a_pb = None

    if getattr(args, &#34;roro_preballast&#34;, None) is not None:
        # Use provided pre-ballast value
        preballast_opt = float(args.roro_preballast)
        print(f&#34;[INFO] Using provided pre-ballast: {preballast_opt:.2f} t&#34;)
    else:
        # Optimize pre-ballast
        print(&#34;[INFO] Optimizing pre-ballast...&#34;)
        search_min = getattr(args, &#34;roro_preballast_min&#34;, 20.0)
        search_max = getattr(args, &#34;roro_preballast_max&#34;, 400.0)
        search_step = getattr(args, &#34;roro_preballast_step&#34;, 1.0)

        preballast_result = optimize_preballast_for_roro(
            base_disp_t=base_disp_t,
            base_tmean_m=base_tmean_m,
            hydro_df=hydro_df,
            w_tr_unit_t=w_tr,
            fr_tr1_stow=fr_tr1_stow,
            fr_tr2_ramp=fr_tr2_ramp,
            fr_preballast=fr_preballast,
            search_min_t=search_min,
            search_max_t=search_max,
            search_step_t=search_step,
            params=params,
        )

        if not preballast_result[&#34;ok&#34;]:
            print(
                f&#34;[WARNING] Pre-ballast optimization failed: {preballast_result[&#39;reason&#39;]}&#34;
            )
            preballast_opt = 250.0  # Fallback
            print(f&#34;[WARNING] Using fallback pre-ballast: {preballast_opt:.2f} t&#34;)
        else:
            preballast_opt = preballast_result[&#34;w_preballast_t&#34;]
            stage5_pb = preballast_result.get(&#34;stage5&#34;)
            stage6a_pb = preballast_result.get(&#34;stage6A&#34;)
            print(f&#34;[INFO] Pre-ballast optimization successful: {preballast_opt:.2f} t&#34;)
            if stage6a_pb:
                fwd6 = stage6a_pb.get(&#34;FWD_m&#34;, 0.0)
                print(f&#34;[INFO] Stage 6A FWD: {fwd6:.2f} m (Limit: 2.70m)&#34;)

    # Stage order
    stages_order = [
        &#34;Stage 1&#34;,
        &#34;Stage 2&#34;,
        &#34;Stage 3&#34;,
        &#34;Stage 4&#34;,
        &#34;Stage 5&#34;,
        &#34;Stage 5_PreBallast&#34;,
        &#34;Stage 6A_Critical (Opt C)&#34;,
        &#34;Stage 6C_TotalMassOpt&#34;,
        &#34;Stage 6C&#34;,
        &#34;Stage 7&#34;,
    ]

    # Process each stage
    stage_results = {}
    current_disp = base_disp_t
    current_tmean = base_tmean_m
    current_fwd = None
    current_aft = None

    optimizer = BallastOptimizer(tanks, hydro_df)

    for stage_name in stages_order:
        print(f&#34;\n[INFO] Processing {stage_name}...&#34;)

        # Build loads for this stage
        loads = build_roro_stage_loads(
            stage_name=stage_name,
            preballast_t=preballast_opt if preballast_opt else 0.0,
            w_tr=w_tr,
            fr_tr1_stow=fr_tr1_stow,
            fr_tr1_ramp_start=fr_tr1_ramp_start,
            fr_tr1_ramp_mid=fr_tr1_ramp_mid,
            fr_tr2_ramp=fr_tr2_ramp,
            fr_tr2_stow=fr_tr2_stow,
            fr_preballast=fr_preballast,
        )

        # Calculate stage drafts
        res = calculate_roro_stage_drafts(
            stage_name=stage_name,
            loads=loads,
            base_disp=current_disp,
            base_tmean=current_tmean,
            hydro_df=hydro_df,
            params=params,
        )

        # Override with pre-ballast optimization results if available
        if stage_name == &#34;Stage 5_PreBallast&#34; and stage5_pb:
            res[&#34;Dfwd_m&#34;] = float(stage5_pb.get(&#34;FWD_m&#34;, res[&#34;Dfwd_m&#34;]))
            res[&#34;Daft_m&#34;] = float(stage5_pb.get(&#34;AFT_m&#34;, res[&#34;Daft_m&#34;]))
            res[&#34;Trim_cm&#34;] = float(stage5_pb.get(&#34;Trim_cm&#34;, res[&#34;Trim_cm&#34;]))
            res[&#34;Tmean_m&#34;] = float(stage5_pb.get(&#34;Tmean_m&#34;, res[&#34;Tmean_m&#34;]))
            res[&#34;FWD_Height_m&#34;] = float(VesselParams.D_VESSEL - res[&#34;Dfwd_m&#34;])
            res[&#34;AFT_Height_m&#34;] = float(VesselParams.D_VESSEL - res[&#34;Daft_m&#34;])

        if stage_name == &#34;Stage 6A_Critical (Opt C)&#34; and stage6a_pb:
            res[&#34;Dfwd_m&#34;] = float(stage6a_pb.get(&#34;FWD_m&#34;, res[&#34;Dfwd_m&#34;]))
            res[&#34;Daft_m&#34;] = float(stage6a_pb.get(&#34;AFT_m&#34;, res[&#34;Daft_m&#34;]))
            res[&#34;Trim_cm&#34;] = float(stage6a_pb.get(&#34;Trim_cm&#34;, res[&#34;Trim_cm&#34;]))
            res[&#34;Tmean_m&#34;] = float(stage6a_pb.get(&#34;Tmean_m&#34;, res[&#34;Tmean_m&#34;]))
            res[&#34;FWD_Height_m&#34;] = float(VesselParams.D_VESSEL - res[&#34;Dfwd_m&#34;])
            res[&#34;AFT_Height_m&#34;] = float(VesselParams.D_VESSEL - res[&#34;Daft_m&#34;])

        # Run BallastOptimizer for stages that require ballast operations
        # This provides actual tank-by-tank ballast distribution from LP optimization
        if abs(res.get(&#34;Ballast_t&#34;, 0.0)) &gt; 0.01:
            # Get current drafts for optimization
            opt_fwd = res[&#34;Dfwd_m&#34;]
            opt_aft = res[&#34;Daft_m&#34;]

            # Determine optimization mode based on stage requirements
            max_fwd = params.get(&#34;max_fwd_draft_ops_m&#34;, VesselParams.MAX_FWD_DRAFT_OPS)

            # Use limit mode to ensure FWD draft stays within limits
            opt_result = optimizer.solve(
                dfwd=opt_fwd,
                daft=opt_aft,
                limit_fwd=max_fwd,
                prefer_time=True,
            )

            if opt_result.success and not opt_result.plan_df.empty:
                # Store optimization result for BALLASTING sheet
                res[&#34;optimization_result&#34;] = opt_result
                res[&#34;tank_deltas&#34;] = opt_result.delta
                print(
                    f&#34;  [OK] BallastOptimizer solved: {len(opt_result.plan_df)} tank operations&#34;
                )
            else:
                # Fallback: no optimization result available
                res[&#34;tank_deltas&#34;] = {}
                print(
                    f&#34;  [WARNING] BallastOptimizer did not find solution for {stage_name}&#34;
                )

        # Update current state for next stage
        current_disp = res[&#34;Disp_t&#34;]
        current_tmean = res[&#34;Tmean_m&#34;]
        current_fwd = res[&#34;Dfwd_m&#34;]
        current_aft = res[&#34;Daft_m&#34;]

        # Store results
        stage_results[stage_name] = res

        print(
            f&#34;[INFO] {stage_name}: FWD={res[&#39;Dfwd_m&#39;]:.2f}m, AFT={res[&#39;Daft_m&#39;]:.2f}m, &#34;
            f&#34;Trim={res[&#39;Trim_cm&#39;]:.1f}cm, Status={res.get(&#39;vs_2.70m&#39;, &#39;N/A&#39;)}&#34;
        )

    # Export to Excel
    if not getattr(args, &#34;no_excel&#34;, False):
        excel_path = (
            Path(args.excel_out)
            if getattr(args, &#34;excel_out&#34;, None)
            else Path(&#34;roro_stages.xlsx&#34;)
        )
        export_roro_stages_to_excel(
            stage_results=stage_results,
            preballast_opt=preballast_opt,
            base_tmean=base_tmean_m,
            base_disp=base_disp_t,
            output_path=excel_path,
            params=params,
            tanks=tanks,
        )
        print(f&#34;\n[INFO] Excel file saved to {excel_path}&#34;)

    return stage_results</code></pre>
</details>
<div class="desc"><p>Run RORO stage-by-stage ballast optimization.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.validate_and_correct_transfer"><code class="name flex">
<span>def <span class="ident">validate_and_correct_transfer</span></span>(<span>transfer_t: float,<br>start_t: float,<br>tank: <a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank">Tank</a>,<br>stage_ballast_total: float,<br>available_tanks: List[<a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank">Tank</a>]) ‑> Tuple[float, List[str]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_and_correct_transfer(
    transfer_t: float,
    start_t: float,
    tank: Tank,
    stage_ballast_total: float,
    available_tanks: List[Tank],
) -&gt; Tuple[float, List[str]]:
    &#34;&#34;&#34;
    Validate and correct transfer to ensure capacity limits.

    Args:
        transfer_t: Proposed transfer amount (t)
        start_t: Starting tank level (t)
        tank: Tank object
        stage_ballast_total: Total ballast for this stage (t)
        available_tanks: List of available tanks for redistribution

    Returns:
        (corrected_transfer_t, warnings)
    &#34;&#34;&#34;
    # Check capacity limits
    end_t_calc = start_t + transfer_t
    warnings = []
    original_transfer = transfer_t

    if end_t_calc &gt; tank.max_t:
        # Over capacity - limit transfer
        max_transfer = tank.max_t - start_t
        transfer_t = max_transfer
        warnings.append(
            f&#34;Transfer limited: {tank.name} capacity exceeded &#34;
            f&#34;(requested {original_transfer:.2f}t, limited to {transfer_t:.2f}t)&#34;
        )

    if end_t_calc &lt; tank.min_t:
        # Below minimum - limit transfer
        min_transfer = tank.min_t - start_t
        transfer_t = min_transfer
        warnings.append(
            f&#34;Transfer limited: {tank.name} below minimum &#34;
            f&#34;(requested {original_transfer:.2f}t, limited to {min_transfer:.2f}t)&#34;
        )

    return transfer_t, warnings</code></pre>
</details>
<div class="desc"><p>Validate and correct transfer to ensure capacity limits.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transfer_t</code></strong></dt>
<dd>Proposed transfer amount (t)</dd>
<dt><strong><code>start_t</code></strong></dt>
<dd>Starting tank level (t)</dd>
<dt><strong><code>tank</code></strong></dt>
<dd>Tank object</dd>
<dt><strong><code>stage_ballast_total</code></strong></dt>
<dd>Total ballast for this stage (t)</dd>
<dt><strong><code>available_tanks</code></strong></dt>
<dd>List of available tanks for redistribution</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(corrected_transfer_t, warnings)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.validate_hydro_formula"><code class="name flex">
<span>def <span class="ident">validate_hydro_formula</span></span>(<span>) ‑> Dict[str, bool]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_hydro_formula() -&gt; Dict[str, bool]:
    &#34;&#34;&#34;Validate hydrostatic formulas using sympy.&#34;&#34;&#34;
    if not HAS_SYMPY:
        return {&#34;available&#34;: False, &#34;message&#34;: &#34;sympy not installed&#34;}

    try:
        # Define symbols
        tmean, tpc, mtc, lcf, lbp = sp.symbols(
            &#34;tmean tpc mtc lcf lbp&#34;, real=True, positive=True
        )
        total_w, total_m = sp.symbols(&#34;total_w total_m&#34;, real=True)

        # Draft change formulas
        d_tmean = total_w / (tpc * 100.0)
        d_trim = total_m / (mtc * 100.0)

        # New draft formulas
        dfwd_new = sp.Symbol(&#34;dfwd0&#34;) + d_tmean - 0.5 * d_trim
        daft_new = sp.Symbol(&#34;daft0&#34;) + d_tmean + 0.5 * d_trim

        # Validate: trim should be daft - dfwd
        trim_calc = daft_new - dfwd_new
        expected_trim = d_trim

        # Check if formulas are consistent
        trim_diff = sp.simplify(trim_calc - expected_trim)
        is_consistent = trim_diff == 0

        # Validate units: d_tmean should have units of length (meters)
        # This is a simplified check - in practice would need unit checking library
        d_tmean_dim = sp.simplify(d_tmean.subs({total_w: 1, tpc: 1}))
        is_dimensionally_consistent = True  # Simplified check

        return {
            &#34;available&#34;: True,
            &#34;formula_consistent&#34;: is_consistent,
            &#34;dimensionally_consistent&#34;: is_dimensionally_consistent,
            &#34;d_tmean_formula&#34;: str(d_tmean),
            &#34;d_trim_formula&#34;: str(d_trim),
        }
    except Exception as e:
        return {&#34;available&#34;: True, &#34;error&#34;: str(e)}</code></pre>
</details>
<div class="desc"><p>Validate hydrostatic formulas using sympy.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.validate_stage_continuity"><code class="name flex">
<span>def <span class="ident">validate_stage_continuity</span></span>(<span>stage_name: str,<br>tank_name: str,<br>current_start_t: float,<br>previous_end_t: Optional[float],<br>tolerance: float = 0.01) ‑> Tuple[float, List[str]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_stage_continuity(
    stage_name: str,
    tank_name: str,
    current_start_t: float,
    previous_end_t: Optional[float],
    tolerance: float = 0.01,
) -&gt; Tuple[float, List[str]]:
    &#34;&#34;&#34;
    Validate tank state continuity between stages.

    Args:
        stage_name: Current stage name
        tank_name: Tank name
        current_start_t: Current stage start level (t)
        previous_end_t: Previous stage end level (t)
        tolerance: Tolerance for continuity check (t)

    Returns:
        (corrected_start_t, warnings)
    &#34;&#34;&#34;
    warnings = []

    if previous_end_t is not None:
        if abs(current_start_t - previous_end_t) &gt; tolerance:
            warnings.append(
                f&#34;Continuity mismatch: {tank_name} in {stage_name} &#34;
                f&#34;(expected {previous_end_t:.2f}t, got {current_start_t:.2f}t)&#34;
            )
            # Force continuity
            current_start_t = previous_end_t

    return current_start_t, warnings</code></pre>
</details>
<div class="desc"><p>Validate tank state continuity between stages.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stage_name</code></strong></dt>
<dd>Current stage name</dd>
<dt><strong><code>tank_name</code></strong></dt>
<dd>Tank name</dd>
<dt><strong><code>current_start_t</code></strong></dt>
<dd>Current stage start level (t)</dd>
<dt><strong><code>previous_end_t</code></strong></dt>
<dd>Previous stage end level (t)</dd>
<dt><strong><code>tolerance</code></strong></dt>
<dd>Tolerance for continuity check (t)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(corrected_start_t, warnings)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.x_to_fr"><code class="name flex">
<span>def <span class="ident">x_to_fr</span></span>(<span>x: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_to_fr(x: float) -&gt; float:
    &#34;&#34;&#34;
    Inverse: x [m from midship] → Frame number.

    공식: fr = _FRAME_OFFSET - x / _FRAME_SLOPE
    (x = _FRAME_SLOPE * (fr - _FRAME_OFFSET) 이므로)
    &#34;&#34;&#34;
    return _FRAME_OFFSET - float(x) / _FRAME_SLOPE</code></pre>
</details>
<div class="desc"><p>Inverse: x [m from midship] → Frame number.</p>
<p>공식: fr = _FRAME_OFFSET - x / _FRAME_SLOPE
(x = _FRAME_SLOPE * (fr - _FRAME_OFFSET) 이므로)</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer"><code class="flex name class">
<span>class <span class="ident">BallastOptimizer</span></span>
<span>(</span><span>tanks: List[<a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank">Tank</a>],<br>hydro_df: Optional[pd.DataFrame] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BallastOptimizer:
    def __init__(self, tanks: List[Tank], hydro_df: Optional[pd.DataFrame] = None):
        self.tanks = tanks
        self.hydro_df = hydro_df if hydro_df is not None else get_default_hydro_table()
        # Sort hydro for interpolation
        self.hydro_df = self.hydro_df.sort_values(&#34;Tmean_m&#34;).reset_index(drop=True)

    def get_hydro_at_draft(self, tmean_m: float) -&gt; HydroPoint:
        x = self.hydro_df[&#34;Tmean_m&#34;].to_numpy(float)
        tmean_val = float(tmean_m)

        # Use advanced interpolation if available
        if HAS_SCIPY_INTERPOLATE and len(x) &gt;= 4:
            # Use CubicSpline for smooth interpolation (requires at least 4 points)
            def _interp_advanced(col: str) -&gt; float:
                y = self.hydro_df[col].to_numpy(float)
                # Check for NaN values
                mask = ~np.isnan(y)
                if mask.sum() &lt; 4:
                    # Fall back to linear interpolation
                    return float(np.interp(tmean_val, x[mask], y[mask]))
                try:
                    spline = CubicSpline(x[mask], y[mask], extrapolate=False)
                    return float(spline(tmean_val))
                except:
                    # Fall back to linear interpolation
                    return float(np.interp(tmean_val, x[mask], y[mask]))

        else:
            # Fall back to linear interpolation
            def _interp_advanced(col: str) -&gt; float:
                return float(
                    np.interp(tmean_val, x, self.hydro_df[col].to_numpy(float))
                )

            return HydroPoint(
                tmean_m=tmean_val,
                tpc_t_per_cm=_interp_advanced(&#34;TPC_t_per_cm&#34;),
                mtc_t_m_per_cm=_interp_advanced(&#34;MTC_t_m_per_cm&#34;),
                lcf_m=_interp_advanced(&#34;LCF_m&#34;),
                lbp_m=(
                    _interp_advanced(&#34;LBP_m&#34;)
                    if &#34;LBP_m&#34; in self.hydro_df.columns
                    else self.lbp_m
                ),
            )

        return HydroPoint(
            tmean_m=tmean_val,
            tpc_t_per_cm=_interp_advanced(&#34;TPC_t_per_cm&#34;),
            mtc_t_m_per_cm=_interp_advanced(&#34;MTC_t_m_per_cm&#34;),
            lcf_m=_interp_advanced(&#34;LCF_m&#34;),
            lbp_m=(
                _interp_advanced(&#34;LBP_m&#34;)
                if &#34;LBP_m&#34; in self.hydro_df.columns
                else VesselParams.LBP
            ),
        )

    def predict_drafts(
        self, dfwd0: float, daft0: float, delta: Dict[str, float]
    ) -&gt; Dict[str, float]:
        &#34;&#34;&#34;Calculate new drafts based on weight changes and current hydrostatics.&#34;&#34;&#34;
        tmean0 = 0.5 * (dfwd0 + daft0)
        hydro = self.get_hydro_at_draft(tmean0)

        tpc, mtc, lcf = hydro.tpc_t_per_cm, hydro.mtc_t_m_per_cm, hydro.lcf_m
        total_w = sum(float(delta.get(t.name, 0.0)) for t in self.tanks)
        total_m = sum(
            float(delta.get(t.name, 0.0)) * (t.x_from_mid_m - lcf) for t in self.tanks
        )

        # Apply safety factors
        d_tmean = (
            total_w / (tpc * 100.0) if tpc &gt; 0 else 0.0
        ) * VesselParams.SAFETY_FACTOR_DRAFT
        d_trim = (
            total_m / (mtc * 100.0) if mtc &gt; 0 else 0.0
        ) * VesselParams.SAFETY_FACTOR_TRIM

        dfwd_new = dfwd0 + d_tmean - 0.5 * d_trim
        daft_new = daft0 + d_tmean + 0.5 * d_trim

        return {
            &#34;total_w_t&#34;: float(total_w),
            &#34;total_m_t_m&#34;: float(total_m),
            &#34;dfwd_new_m&#34;: float(dfwd_new),
            &#34;daft_new_m&#34;: float(daft_new),
            &#34;trim_new_m&#34;: float(daft_new - dfwd_new),
            &#34;tmean_new_m&#34;: float(0.5 * (dfwd_new + daft_new)),
        }

    def solve(
        self,
        dfwd: float,
        daft: float,
        target_fwd: Optional[float] = None,
        target_aft: Optional[float] = None,
        limit_fwd: Optional[float] = None,
        limit_aft: Optional[float] = None,
        limit_trim: Optional[float] = None,
        prefer_time: bool = True,
        violation_penalty: float = 1e7,
    ) -&gt; OptimizationResult:
        &#34;&#34;&#34;
        Solves the ballast plan using Linear Programming.
        Supports &#39;Target&#39; mode (exact draft) or &#39;Limit&#39; mode (inequalities).
        &#34;&#34;&#34;

        # 1. Setup Hydro
        mean_draft = 0.5 * (dfwd + daft)
        hydro = self.get_hydro_at_draft(mean_draft)

        # 2. Setup Variables
        # x = [p1, n1, p2, n2, ..., slacks...]
        # p = pump in (positive), n = pump out (negative representation in math, but positive var)
        var_names = []
        bounds = []
        cost = []

        for t in self.tanks:
            p_lo, p_hi, n_lo, n_hi = t.bounds_pos_neg()
            var_names.extend([f&#34;{t.name}_p&#34;, f&#34;{t.name}_n&#34;])
            bounds.extend([(p_lo, p_hi), (n_lo, n_hi)])

            # Cost function
            w = t.priority_weight
            if prefer_time:
                c = w / t.pump_rate_tph if t.pump_rate_tph &gt; 0 else 1e6
            else:
                c = w
            cost.extend([c, c])

        # 3. Mode Determination &amp; Constraints
        A_eq, b_eq = None, None
        A_ub, b_ub = [], []

        # Helper to build rows
        # Weight Coef: 1/(TPC*100)
        # Moment Coef: (x - LCF)/(MTC*100) * (-1 for sign convention fix discussed earlier)

        inv_tpc = 1.0 / (hydro.tpc_t_per_cm * 100.0)
        inv_mtc = -1.0 / (
            hydro.mtc_t_m_per_cm * 100.0
        )  # Negative because pos moment (fwd) -&gt; neg trim

        def get_coeffs():
            # Returns arrays for dSinkage and dTrim
            c_sink = []
            c_trim = []
            for t in self.tanks:
                arm = t.x_from_mid_m - hydro.lcf_m
                # For P (Fill): +Weight
                c_sink.append(inv_tpc)
                c_trim.append(arm * inv_mtc)
                # For N (Discharge): -Weight
                c_sink.append(-inv_tpc)
                c_trim.append(-arm * inv_mtc)
            return np.array(c_sink), np.array(c_trim)

        kw_sink, kw_trim = get_coeffs()

        # Geometric factors for drafts
        # dFwd = dSink - dTrim * (0.5 - LCF/LBP)
        # dAft = dSink + dTrim * (0.5 + LCF/LBP)
        f_fac = 0.5 - (hydro.lcf_m / hydro.lbp_m)
        a_fac = 0.5 + (hydro.lcf_m / hydro.lbp_m)

        row_fwd = kw_sink - kw_trim * f_fac
        row_aft = kw_sink + kw_trim * a_fac

        # Mode: TARGET (Equality Constraints)
        if target_fwd is not None and target_aft is not None:
            # Add slack variables for soft constraints (penalty)
            # slack_fwd_p, slack_fwd_n, slack_aft_p, slack_aft_n
            var_names.extend([&#34;sf_p&#34;, &#34;sf_n&#34;, &#34;sa_p&#34;, &#34;sa_n&#34;])
            bounds.extend([(0, None)] * 4)
            cost.extend([1e6] * 4)  # High penalty for missing target

            # Current delta needed
            req_df = target_fwd - dfwd
            req_da = target_aft - daft

            # Rows with slacks
            # sum(weights) + slack_p - slack_n = required
            rf = np.concatenate([row_fwd, [1, -1, 0, 0]])
            ra = np.concatenate([row_aft, [0, 0, 1, -1]])

            A_eq = np.vstack([rf, ra])
            b_eq = np.array([req_df, req_da])

        # Mode: LIMIT (Inequality Constraints with Violation Variables)
        else:
            # Add violation variables for soft constraints
            viol_vars = [
                &#34;viol_fwd_m&#34;,
                &#34;viol_aft_m&#34;,
                &#34;viol_trim_pos_m&#34;,
                &#34;viol_trim_neg_m&#34;,
            ]
            var_names.extend(viol_vars)
            bounds.extend([(0.0, None)] * 4)
            cost.extend([violation_penalty] * 4)

            # Helper to pad rows with violation variables
            def pad_with_viol(row: np.ndarray) -&gt; np.ndarray:
                padded = np.zeros(len(var_names), float)
                padded[: len(row)] = row
                return padded

            # If Limit Fwd provided: Fwd_new &lt;= Limit -&gt; dFwd &lt;= Limit - Fwd_cur
            if limit_fwd is not None and not (
                np.isnan(limit_fwd) or np.isinf(limit_fwd)
            ):
                r = pad_with_viol(row_fwd)
                r[var_names.index(&#34;viol_fwd_m&#34;)] = -1.0
                # Check for invalid values
                if not (np.any(np.isnan(r)) or np.any(np.isinf(r))):
                    b_val = limit_fwd - dfwd
                    if not (np.isnan(b_val) or np.isinf(b_val)):
                        A_ub.append(r)
                        b_ub.append(b_val)

            if limit_aft is not None and not (
                np.isnan(limit_aft) or np.isinf(limit_aft)
            ):
                # Aft_new &lt;= Limit
                r = pad_with_viol(row_aft)
                r[var_names.index(&#34;viol_aft_m&#34;)] = -1.0
                # Check for invalid values
                if not (np.any(np.isnan(r)) or np.any(np.isinf(r))):
                    b_val = limit_aft - daft
                    if not (np.isnan(b_val) or np.isinf(b_val)):
                        A_ub.append(r)
                        b_ub.append(b_val)

            if limit_trim is not None and not (
                np.isnan(limit_trim) or np.isinf(limit_trim)
            ):
                # abs(Trim_new) &lt;= Limit
                trim_cur = daft - dfwd
                if not (np.isnan(trim_cur) or np.isinf(trim_cur)):
                    # Positive trim constraint
                    r = pad_with_viol(kw_trim)
                    r[var_names.index(&#34;viol_trim_pos_m&#34;)] = -1.0
                    # Check for invalid values
                    if not (np.any(np.isnan(r)) or np.any(np.isinf(r))):
                        b_val = limit_trim - trim_cur
                        if not (np.isnan(b_val) or np.isinf(b_val)):
                            A_ub.append(r)
                            b_ub.append(b_val)
                    # Negative trim constraint
                    r = pad_with_viol(-kw_trim)
                    r[var_names.index(&#34;viol_trim_neg_m&#34;)] = -1.0
                    # Check for invalid values
                    if not (np.any(np.isnan(r)) or np.any(np.isinf(r))):
                        b_val = limit_trim + trim_cur
                        if not (np.isnan(b_val) or np.isinf(b_val)):
                            A_ub.append(r)
                            b_ub.append(b_val)

        # Convert lists to arrays
        if len(A_ub) &gt; 0:
            A_ub = np.vstack(A_ub)
            # Final check for invalid values
            if np.any(np.isnan(A_ub)) or np.any(np.isinf(A_ub)):
                # Replace invalid values with 0
                A_ub = np.nan_to_num(A_ub, nan=0.0, posinf=1e6, neginf=-1e6)
            # Pad A_ub if variables were added (slacks) - not applicable in the Limit logic block above currently
            b_ub = np.array(b_ub)
            # Final check for invalid values in b_ub
            if np.any(np.isnan(b_ub)) or np.any(np.isinf(b_ub)):
                b_ub = np.nan_to_num(b_ub, nan=0.0, posinf=1e6, neginf=-1e6)
        else:
            A_ub, b_ub = None, None

        # Solve
        res = linprog(
            c=cost,
            A_ub=A_ub,
            b_ub=b_ub,
            A_eq=A_eq,
            b_eq=b_eq,
            bounds=bounds,
            method=&#34;highs&#34;,
        )

        if not res.success:
            return OptimizationResult(pd.DataFrame(), {}, {}, False, res.message)

        # Parse Result
        delta = {}
        rows = []
        total_pump_time = 0

        n_tanks = len(self.tanks)
        x = res.x

        for i, t in enumerate(self.tanks):
            p = x[2 * i]
            n = x[2 * i + 1]
            dw = p - n

            if abs(dw) &lt; 0.01:
                continue

            pump_time = (p + n) / t.pump_rate_tph
            total_pump_time += pump_time
            delta[t.name] = dw

            rows.append(
                {
                    &#34;Tank&#34;: t.name,
                    &#34;Action&#34;: &#34;Fill&#34; if dw &gt; 0 else &#34;Discharge&#34;,
                    &#34;Weight_t&#34;: round(dw, 1),
                    &#34;Start_%&#34;: round(t.current_pct, 1),
                    &#34;End_%&#34;: (
                        round(((t.current_t + dw) / t.max_t) * 100, 1) if t.max_t else 0
                    ),
                    &#34;Time_h&#34;: round(pump_time, 2),
                }
            )

        plan_df = pd.DataFrame(rows)
        pred = self.predict_drafts(dfwd, daft, delta)
        pred[&#34;total_time_h&#34;] = total_pump_time

        # Add violation values if in limit mode
        if target_fwd is None or target_aft is None:
            # Limit mode - extract violation values
            n_tanks = len(self.tanks)
            base_idx = 2 * n_tanks
            if &#34;viol_fwd_m&#34; in var_names:
                pred[&#34;viol_fwd_m&#34;] = float(x[var_names.index(&#34;viol_fwd_m&#34;)])
            if &#34;viol_aft_m&#34; in var_names:
                pred[&#34;viol_aft_m&#34;] = float(x[var_names.index(&#34;viol_aft_m&#34;)])
            if &#34;viol_trim_pos_m&#34; in var_names:
                pred[&#34;viol_trim_pos_m&#34;] = float(x[var_names.index(&#34;viol_trim_pos_m&#34;)])
            if &#34;viol_trim_neg_m&#34; in var_names:
                pred[&#34;viol_trim_neg_m&#34;] = float(x[var_names.index(&#34;viol_trim_neg_m&#34;)])

        # Safety validation
        warnings = []
        # Draft limits validation
        if pred[&#34;dfwd_new_m&#34;] &lt; VesselParams.MIN_DRAFT:
            warnings.append(
                f&#34;WARNING: FWD draft {pred[&#39;dfwd_new_m&#39;]:.3f}m below minimum {VesselParams.MIN_DRAFT}m&#34;
            )
        if pred[&#34;dfwd_new_m&#34;] &gt; VesselParams.MAX_FWD_DRAFT_OPS:
            warnings.append(
                f&#34;WARNING: FWD draft {pred[&#39;dfwd_new_m&#39;]:.3f}m exceeds operational limit {VesselParams.MAX_FWD_DRAFT_OPS}m&#34;
            )
        if pred[&#34;daft_new_m&#34;] &gt; VesselParams.MAX_AFT_DRAFT_OPS:
            warnings.append(
                f&#34;WARNING: AFT draft {pred[&#39;daft_new_m&#39;]:.3f}m exceeds operational limit {VesselParams.MAX_AFT_DRAFT_OPS}m&#34;
            )

        # Trim limit validation
        trim_cm = abs(pred[&#34;trim_new_m&#34;]) * 100.0
        if trim_cm &gt; VesselParams.TRIM_LIMIT_CM:
            warnings.append(
                f&#34;WARNING: Trim {trim_cm:.1f}cm exceeds limit {VesselParams.TRIM_LIMIT_CM}cm&#34;
            )

        # IMO/Industry standard compliance checks
        # GM check (simplified - would need actual GM calculation for full compliance)
        # Note: Full GM calculation requires additional hydrostatic data
        pred[&#34;_compliance_checks&#34;] = {
            &#34;draft_within_limits&#34;: (
                VesselParams.MIN_DRAFT
                &lt;= pred[&#34;dfwd_new_m&#34;]
                &lt;= VesselParams.MAX_FWD_DRAFT_OPS
                and pred[&#34;daft_new_m&#34;] &lt;= VesselParams.MAX_AFT_DRAFT_OPS
            ),
            &#34;trim_within_limit&#34;: trim_cm &lt;= VesselParams.TRIM_LIMIT_CM,
            &#34;imo_draft_compliant&#34;: pred[&#34;dfwd_new_m&#34;] &lt;= VesselParams.MAX_FWD_DRAFT_OPS,
        }

        # Tank capacity validation with group balance check
        tank_groups = {}
        for t in self.tanks:
            if t.name in delta:
                new_level = t.current_t + delta[t.name]
                if new_level &gt; t.max_t:
                    warnings.append(
                        f&#34;WARNING: Tank {t.name} exceeds max capacity ({new_level:.2f}t &gt; {t.max_t:.2f}t)&#34;
                    )
                if new_level &lt; t.min_t:
                    warnings.append(
                        f&#34;WARNING: Tank {t.name} below min level ({new_level:.2f}t &lt; {t.min_t:.2f}t)&#34;
                    )

                # Group balance tracking
                if t.group:
                    if t.group not in tank_groups:
                        tank_groups[t.group] = {&#34;total&#34;: 0.0, &#34;count&#34;: 0}
                    tank_groups[t.group][&#34;total&#34;] += new_level
                    tank_groups[t.group][&#34;count&#34;] += 1

        # Check group balance
        for group, data in tank_groups.items():
            avg_level = data[&#34;total&#34;] / data[&#34;count&#34;] if data[&#34;count&#34;] &gt; 0 else 0.0
            # Warn if significant imbalance (more than 10% difference from average)
            for t in self.tanks:
                if t.group == group and t.name in delta:
                    new_level = t.current_t + delta[t.name]
                    if abs(new_level - avg_level) &gt; avg_level * 0.1:
                        warnings.append(
                            f&#34;WARNING: Tank {t.name} in group {group} imbalanced ({new_level:.2f}t vs avg {avg_level:.2f}t)&#34;
                        )

        if warnings:
            pred[&#34;_warnings&#34;] = warnings

        return OptimizationResult(plan_df, pred, delta, True, &#34;Optimal&#34;)

    def update_tanks(self, delta: Dict[str, float]):
        &#34;&#34;&#34;Updates internal tank states based on delta.&#34;&#34;&#34;
        for t in self.tanks:
            if t.name in delta:
                t.current_t = min(max(t.current_t + delta[t.name], t.min_t), t.max_t)

    def apply_delta_to_tanks(self, delta: Dict[str, float]) -&gt; List[Tank]:
        &#34;&#34;&#34;Apply delta to tanks and return new tank list with updated states.&#34;&#34;&#34;
        new_tanks = []
        for t in self.tanks:
            dw = float(delta.get(t.name, 0.0))
            new_tanks.append(
                Tank(
                    name=t.name,
                    x_from_mid_m=t.x_from_mid_m,
                    current_t=min(max(t.current_t + dw, t.min_t), t.max_t),
                    min_t=t.min_t,
                    max_t=t.max_t,
                    mode=t.mode,
                    use_flag=t.use_flag,
                    pump_rate_tph=t.pump_rate_tph,
                    group=t.group,
                    priority_weight=t.priority_weight,
                    density_t_per_m3=t.density_t_per_m3,
                    freeze_flag=t.freeze_flag,
                )
            )
        return new_tanks

    def iterate_hydro_solve(
        self, dfwd0: float, daft0: float, iterate_hydro: int = 2, **kwargs
    ) -&gt; Tuple[pd.DataFrame, Dict[str, float], HydroPoint, Dict[str, float]]:
        &#34;&#34;&#34;
        Solve with iterative hydro interpolation for improved accuracy.

        Args:
            dfwd0: Initial forward draft
            daft0: Initial aft draft
            iterate_hydro: Number of iterations (default 2)
            **kwargs: Additional arguments for solve method

        Returns:
            Tuple of (plan_df, summary, hydro, delta)
        &#34;&#34;&#34;
        tmean = 0.5 * (dfwd0 + daft0)
        plan = None
        pred = None
        delta = None
        hydro = None

        for _ in range(max(int(iterate_hydro), 1)):
            hydro = self.get_hydro_at_draft(tmean)
            # Extract prefer_time and violation_penalty from kwargs if present
            prefer_time = kwargs.pop(&#34;prefer_time&#34;, True)
            violation_penalty = kwargs.pop(&#34;violation_penalty&#34;, 1e7)
            res = self.solve(
                dfwd0,
                daft0,
                prefer_time=prefer_time,
                violation_penalty=violation_penalty,
                **kwargs,
            )
            if not res.success:
                raise RuntimeError(f&#34;Optimization failed: {res.msg}&#34;)

            plan = res.plan_df
            pred = res.summary
            delta = res.delta

            # Update tmean for next iteration
            tmean = float(pred.get(&#34;tmean_new_m&#34;, tmean))

        return plan, pred, hydro, delta</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.apply_delta_to_tanks"><code class="name flex">
<span>def <span class="ident">apply_delta_to_tanks</span></span>(<span>self, delta: Dict[str, float]) ‑> List[01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_delta_to_tanks(self, delta: Dict[str, float]) -&gt; List[Tank]:
    &#34;&#34;&#34;Apply delta to tanks and return new tank list with updated states.&#34;&#34;&#34;
    new_tanks = []
    for t in self.tanks:
        dw = float(delta.get(t.name, 0.0))
        new_tanks.append(
            Tank(
                name=t.name,
                x_from_mid_m=t.x_from_mid_m,
                current_t=min(max(t.current_t + dw, t.min_t), t.max_t),
                min_t=t.min_t,
                max_t=t.max_t,
                mode=t.mode,
                use_flag=t.use_flag,
                pump_rate_tph=t.pump_rate_tph,
                group=t.group,
                priority_weight=t.priority_weight,
                density_t_per_m3=t.density_t_per_m3,
                freeze_flag=t.freeze_flag,
            )
        )
    return new_tanks</code></pre>
</details>
<div class="desc"><p>Apply delta to tanks and return new tank list with updated states.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.get_hydro_at_draft"><code class="name flex">
<span>def <span class="ident">get_hydro_at_draft</span></span>(<span>self, tmean_m: float) ‑> 01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hydro_at_draft(self, tmean_m: float) -&gt; HydroPoint:
    x = self.hydro_df[&#34;Tmean_m&#34;].to_numpy(float)
    tmean_val = float(tmean_m)

    # Use advanced interpolation if available
    if HAS_SCIPY_INTERPOLATE and len(x) &gt;= 4:
        # Use CubicSpline for smooth interpolation (requires at least 4 points)
        def _interp_advanced(col: str) -&gt; float:
            y = self.hydro_df[col].to_numpy(float)
            # Check for NaN values
            mask = ~np.isnan(y)
            if mask.sum() &lt; 4:
                # Fall back to linear interpolation
                return float(np.interp(tmean_val, x[mask], y[mask]))
            try:
                spline = CubicSpline(x[mask], y[mask], extrapolate=False)
                return float(spline(tmean_val))
            except:
                # Fall back to linear interpolation
                return float(np.interp(tmean_val, x[mask], y[mask]))

    else:
        # Fall back to linear interpolation
        def _interp_advanced(col: str) -&gt; float:
            return float(
                np.interp(tmean_val, x, self.hydro_df[col].to_numpy(float))
            )

        return HydroPoint(
            tmean_m=tmean_val,
            tpc_t_per_cm=_interp_advanced(&#34;TPC_t_per_cm&#34;),
            mtc_t_m_per_cm=_interp_advanced(&#34;MTC_t_m_per_cm&#34;),
            lcf_m=_interp_advanced(&#34;LCF_m&#34;),
            lbp_m=(
                _interp_advanced(&#34;LBP_m&#34;)
                if &#34;LBP_m&#34; in self.hydro_df.columns
                else self.lbp_m
            ),
        )

    return HydroPoint(
        tmean_m=tmean_val,
        tpc_t_per_cm=_interp_advanced(&#34;TPC_t_per_cm&#34;),
        mtc_t_m_per_cm=_interp_advanced(&#34;MTC_t_m_per_cm&#34;),
        lcf_m=_interp_advanced(&#34;LCF_m&#34;),
        lbp_m=(
            _interp_advanced(&#34;LBP_m&#34;)
            if &#34;LBP_m&#34; in self.hydro_df.columns
            else VesselParams.LBP
        ),
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.iterate_hydro_solve"><code class="name flex">
<span>def <span class="ident">iterate_hydro_solve</span></span>(<span>self, dfwd0: float, daft0: float, iterate_hydro: int = 2, **kwargs) ‑> Tuple[pandas.core.frame.DataFrame, Dict[str, float], 01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint, Dict[str, float]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterate_hydro_solve(
    self, dfwd0: float, daft0: float, iterate_hydro: int = 2, **kwargs
) -&gt; Tuple[pd.DataFrame, Dict[str, float], HydroPoint, Dict[str, float]]:
    &#34;&#34;&#34;
    Solve with iterative hydro interpolation for improved accuracy.

    Args:
        dfwd0: Initial forward draft
        daft0: Initial aft draft
        iterate_hydro: Number of iterations (default 2)
        **kwargs: Additional arguments for solve method

    Returns:
        Tuple of (plan_df, summary, hydro, delta)
    &#34;&#34;&#34;
    tmean = 0.5 * (dfwd0 + daft0)
    plan = None
    pred = None
    delta = None
    hydro = None

    for _ in range(max(int(iterate_hydro), 1)):
        hydro = self.get_hydro_at_draft(tmean)
        # Extract prefer_time and violation_penalty from kwargs if present
        prefer_time = kwargs.pop(&#34;prefer_time&#34;, True)
        violation_penalty = kwargs.pop(&#34;violation_penalty&#34;, 1e7)
        res = self.solve(
            dfwd0,
            daft0,
            prefer_time=prefer_time,
            violation_penalty=violation_penalty,
            **kwargs,
        )
        if not res.success:
            raise RuntimeError(f&#34;Optimization failed: {res.msg}&#34;)

        plan = res.plan_df
        pred = res.summary
        delta = res.delta

        # Update tmean for next iteration
        tmean = float(pred.get(&#34;tmean_new_m&#34;, tmean))

    return plan, pred, hydro, delta</code></pre>
</details>
<div class="desc"><p>Solve with iterative hydro interpolation for improved accuracy.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dfwd0</code></strong></dt>
<dd>Initial forward draft</dd>
<dt><strong><code>daft0</code></strong></dt>
<dd>Initial aft draft</dd>
<dt><strong><code>iterate_hydro</code></strong></dt>
<dd>Number of iterations (default 2)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments for solve method</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of (plan_df, summary, hydro, delta)</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.predict_drafts"><code class="name flex">
<span>def <span class="ident">predict_drafts</span></span>(<span>self, dfwd0: float, daft0: float, delta: Dict[str, float]) ‑> Dict[str, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_drafts(
    self, dfwd0: float, daft0: float, delta: Dict[str, float]
) -&gt; Dict[str, float]:
    &#34;&#34;&#34;Calculate new drafts based on weight changes and current hydrostatics.&#34;&#34;&#34;
    tmean0 = 0.5 * (dfwd0 + daft0)
    hydro = self.get_hydro_at_draft(tmean0)

    tpc, mtc, lcf = hydro.tpc_t_per_cm, hydro.mtc_t_m_per_cm, hydro.lcf_m
    total_w = sum(float(delta.get(t.name, 0.0)) for t in self.tanks)
    total_m = sum(
        float(delta.get(t.name, 0.0)) * (t.x_from_mid_m - lcf) for t in self.tanks
    )

    # Apply safety factors
    d_tmean = (
        total_w / (tpc * 100.0) if tpc &gt; 0 else 0.0
    ) * VesselParams.SAFETY_FACTOR_DRAFT
    d_trim = (
        total_m / (mtc * 100.0) if mtc &gt; 0 else 0.0
    ) * VesselParams.SAFETY_FACTOR_TRIM

    dfwd_new = dfwd0 + d_tmean - 0.5 * d_trim
    daft_new = daft0 + d_tmean + 0.5 * d_trim

    return {
        &#34;total_w_t&#34;: float(total_w),
        &#34;total_m_t_m&#34;: float(total_m),
        &#34;dfwd_new_m&#34;: float(dfwd_new),
        &#34;daft_new_m&#34;: float(daft_new),
        &#34;trim_new_m&#34;: float(daft_new - dfwd_new),
        &#34;tmean_new_m&#34;: float(0.5 * (dfwd_new + daft_new)),
    }</code></pre>
</details>
<div class="desc"><p>Calculate new drafts based on weight changes and current hydrostatics.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self,<br>dfwd: float,<br>daft: float,<br>target_fwd: Optional[float] = None,<br>target_aft: Optional[float] = None,<br>limit_fwd: Optional[float] = None,<br>limit_aft: Optional[float] = None,<br>limit_trim: Optional[float] = None,<br>prefer_time: bool = True,<br>violation_penalty: float = 10000000.0) ‑> 01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(
    self,
    dfwd: float,
    daft: float,
    target_fwd: Optional[float] = None,
    target_aft: Optional[float] = None,
    limit_fwd: Optional[float] = None,
    limit_aft: Optional[float] = None,
    limit_trim: Optional[float] = None,
    prefer_time: bool = True,
    violation_penalty: float = 1e7,
) -&gt; OptimizationResult:
    &#34;&#34;&#34;
    Solves the ballast plan using Linear Programming.
    Supports &#39;Target&#39; mode (exact draft) or &#39;Limit&#39; mode (inequalities).
    &#34;&#34;&#34;

    # 1. Setup Hydro
    mean_draft = 0.5 * (dfwd + daft)
    hydro = self.get_hydro_at_draft(mean_draft)

    # 2. Setup Variables
    # x = [p1, n1, p2, n2, ..., slacks...]
    # p = pump in (positive), n = pump out (negative representation in math, but positive var)
    var_names = []
    bounds = []
    cost = []

    for t in self.tanks:
        p_lo, p_hi, n_lo, n_hi = t.bounds_pos_neg()
        var_names.extend([f&#34;{t.name}_p&#34;, f&#34;{t.name}_n&#34;])
        bounds.extend([(p_lo, p_hi), (n_lo, n_hi)])

        # Cost function
        w = t.priority_weight
        if prefer_time:
            c = w / t.pump_rate_tph if t.pump_rate_tph &gt; 0 else 1e6
        else:
            c = w
        cost.extend([c, c])

    # 3. Mode Determination &amp; Constraints
    A_eq, b_eq = None, None
    A_ub, b_ub = [], []

    # Helper to build rows
    # Weight Coef: 1/(TPC*100)
    # Moment Coef: (x - LCF)/(MTC*100) * (-1 for sign convention fix discussed earlier)

    inv_tpc = 1.0 / (hydro.tpc_t_per_cm * 100.0)
    inv_mtc = -1.0 / (
        hydro.mtc_t_m_per_cm * 100.0
    )  # Negative because pos moment (fwd) -&gt; neg trim

    def get_coeffs():
        # Returns arrays for dSinkage and dTrim
        c_sink = []
        c_trim = []
        for t in self.tanks:
            arm = t.x_from_mid_m - hydro.lcf_m
            # For P (Fill): +Weight
            c_sink.append(inv_tpc)
            c_trim.append(arm * inv_mtc)
            # For N (Discharge): -Weight
            c_sink.append(-inv_tpc)
            c_trim.append(-arm * inv_mtc)
        return np.array(c_sink), np.array(c_trim)

    kw_sink, kw_trim = get_coeffs()

    # Geometric factors for drafts
    # dFwd = dSink - dTrim * (0.5 - LCF/LBP)
    # dAft = dSink + dTrim * (0.5 + LCF/LBP)
    f_fac = 0.5 - (hydro.lcf_m / hydro.lbp_m)
    a_fac = 0.5 + (hydro.lcf_m / hydro.lbp_m)

    row_fwd = kw_sink - kw_trim * f_fac
    row_aft = kw_sink + kw_trim * a_fac

    # Mode: TARGET (Equality Constraints)
    if target_fwd is not None and target_aft is not None:
        # Add slack variables for soft constraints (penalty)
        # slack_fwd_p, slack_fwd_n, slack_aft_p, slack_aft_n
        var_names.extend([&#34;sf_p&#34;, &#34;sf_n&#34;, &#34;sa_p&#34;, &#34;sa_n&#34;])
        bounds.extend([(0, None)] * 4)
        cost.extend([1e6] * 4)  # High penalty for missing target

        # Current delta needed
        req_df = target_fwd - dfwd
        req_da = target_aft - daft

        # Rows with slacks
        # sum(weights) + slack_p - slack_n = required
        rf = np.concatenate([row_fwd, [1, -1, 0, 0]])
        ra = np.concatenate([row_aft, [0, 0, 1, -1]])

        A_eq = np.vstack([rf, ra])
        b_eq = np.array([req_df, req_da])

    # Mode: LIMIT (Inequality Constraints with Violation Variables)
    else:
        # Add violation variables for soft constraints
        viol_vars = [
            &#34;viol_fwd_m&#34;,
            &#34;viol_aft_m&#34;,
            &#34;viol_trim_pos_m&#34;,
            &#34;viol_trim_neg_m&#34;,
        ]
        var_names.extend(viol_vars)
        bounds.extend([(0.0, None)] * 4)
        cost.extend([violation_penalty] * 4)

        # Helper to pad rows with violation variables
        def pad_with_viol(row: np.ndarray) -&gt; np.ndarray:
            padded = np.zeros(len(var_names), float)
            padded[: len(row)] = row
            return padded

        # If Limit Fwd provided: Fwd_new &lt;= Limit -&gt; dFwd &lt;= Limit - Fwd_cur
        if limit_fwd is not None and not (
            np.isnan(limit_fwd) or np.isinf(limit_fwd)
        ):
            r = pad_with_viol(row_fwd)
            r[var_names.index(&#34;viol_fwd_m&#34;)] = -1.0
            # Check for invalid values
            if not (np.any(np.isnan(r)) or np.any(np.isinf(r))):
                b_val = limit_fwd - dfwd
                if not (np.isnan(b_val) or np.isinf(b_val)):
                    A_ub.append(r)
                    b_ub.append(b_val)

        if limit_aft is not None and not (
            np.isnan(limit_aft) or np.isinf(limit_aft)
        ):
            # Aft_new &lt;= Limit
            r = pad_with_viol(row_aft)
            r[var_names.index(&#34;viol_aft_m&#34;)] = -1.0
            # Check for invalid values
            if not (np.any(np.isnan(r)) or np.any(np.isinf(r))):
                b_val = limit_aft - daft
                if not (np.isnan(b_val) or np.isinf(b_val)):
                    A_ub.append(r)
                    b_ub.append(b_val)

        if limit_trim is not None and not (
            np.isnan(limit_trim) or np.isinf(limit_trim)
        ):
            # abs(Trim_new) &lt;= Limit
            trim_cur = daft - dfwd
            if not (np.isnan(trim_cur) or np.isinf(trim_cur)):
                # Positive trim constraint
                r = pad_with_viol(kw_trim)
                r[var_names.index(&#34;viol_trim_pos_m&#34;)] = -1.0
                # Check for invalid values
                if not (np.any(np.isnan(r)) or np.any(np.isinf(r))):
                    b_val = limit_trim - trim_cur
                    if not (np.isnan(b_val) or np.isinf(b_val)):
                        A_ub.append(r)
                        b_ub.append(b_val)
                # Negative trim constraint
                r = pad_with_viol(-kw_trim)
                r[var_names.index(&#34;viol_trim_neg_m&#34;)] = -1.0
                # Check for invalid values
                if not (np.any(np.isnan(r)) or np.any(np.isinf(r))):
                    b_val = limit_trim + trim_cur
                    if not (np.isnan(b_val) or np.isinf(b_val)):
                        A_ub.append(r)
                        b_ub.append(b_val)

    # Convert lists to arrays
    if len(A_ub) &gt; 0:
        A_ub = np.vstack(A_ub)
        # Final check for invalid values
        if np.any(np.isnan(A_ub)) or np.any(np.isinf(A_ub)):
            # Replace invalid values with 0
            A_ub = np.nan_to_num(A_ub, nan=0.0, posinf=1e6, neginf=-1e6)
        # Pad A_ub if variables were added (slacks) - not applicable in the Limit logic block above currently
        b_ub = np.array(b_ub)
        # Final check for invalid values in b_ub
        if np.any(np.isnan(b_ub)) or np.any(np.isinf(b_ub)):
            b_ub = np.nan_to_num(b_ub, nan=0.0, posinf=1e6, neginf=-1e6)
    else:
        A_ub, b_ub = None, None

    # Solve
    res = linprog(
        c=cost,
        A_ub=A_ub,
        b_ub=b_ub,
        A_eq=A_eq,
        b_eq=b_eq,
        bounds=bounds,
        method=&#34;highs&#34;,
    )

    if not res.success:
        return OptimizationResult(pd.DataFrame(), {}, {}, False, res.message)

    # Parse Result
    delta = {}
    rows = []
    total_pump_time = 0

    n_tanks = len(self.tanks)
    x = res.x

    for i, t in enumerate(self.tanks):
        p = x[2 * i]
        n = x[2 * i + 1]
        dw = p - n

        if abs(dw) &lt; 0.01:
            continue

        pump_time = (p + n) / t.pump_rate_tph
        total_pump_time += pump_time
        delta[t.name] = dw

        rows.append(
            {
                &#34;Tank&#34;: t.name,
                &#34;Action&#34;: &#34;Fill&#34; if dw &gt; 0 else &#34;Discharge&#34;,
                &#34;Weight_t&#34;: round(dw, 1),
                &#34;Start_%&#34;: round(t.current_pct, 1),
                &#34;End_%&#34;: (
                    round(((t.current_t + dw) / t.max_t) * 100, 1) if t.max_t else 0
                ),
                &#34;Time_h&#34;: round(pump_time, 2),
            }
        )

    plan_df = pd.DataFrame(rows)
    pred = self.predict_drafts(dfwd, daft, delta)
    pred[&#34;total_time_h&#34;] = total_pump_time

    # Add violation values if in limit mode
    if target_fwd is None or target_aft is None:
        # Limit mode - extract violation values
        n_tanks = len(self.tanks)
        base_idx = 2 * n_tanks
        if &#34;viol_fwd_m&#34; in var_names:
            pred[&#34;viol_fwd_m&#34;] = float(x[var_names.index(&#34;viol_fwd_m&#34;)])
        if &#34;viol_aft_m&#34; in var_names:
            pred[&#34;viol_aft_m&#34;] = float(x[var_names.index(&#34;viol_aft_m&#34;)])
        if &#34;viol_trim_pos_m&#34; in var_names:
            pred[&#34;viol_trim_pos_m&#34;] = float(x[var_names.index(&#34;viol_trim_pos_m&#34;)])
        if &#34;viol_trim_neg_m&#34; in var_names:
            pred[&#34;viol_trim_neg_m&#34;] = float(x[var_names.index(&#34;viol_trim_neg_m&#34;)])

    # Safety validation
    warnings = []
    # Draft limits validation
    if pred[&#34;dfwd_new_m&#34;] &lt; VesselParams.MIN_DRAFT:
        warnings.append(
            f&#34;WARNING: FWD draft {pred[&#39;dfwd_new_m&#39;]:.3f}m below minimum {VesselParams.MIN_DRAFT}m&#34;
        )
    if pred[&#34;dfwd_new_m&#34;] &gt; VesselParams.MAX_FWD_DRAFT_OPS:
        warnings.append(
            f&#34;WARNING: FWD draft {pred[&#39;dfwd_new_m&#39;]:.3f}m exceeds operational limit {VesselParams.MAX_FWD_DRAFT_OPS}m&#34;
        )
    if pred[&#34;daft_new_m&#34;] &gt; VesselParams.MAX_AFT_DRAFT_OPS:
        warnings.append(
            f&#34;WARNING: AFT draft {pred[&#39;daft_new_m&#39;]:.3f}m exceeds operational limit {VesselParams.MAX_AFT_DRAFT_OPS}m&#34;
        )

    # Trim limit validation
    trim_cm = abs(pred[&#34;trim_new_m&#34;]) * 100.0
    if trim_cm &gt; VesselParams.TRIM_LIMIT_CM:
        warnings.append(
            f&#34;WARNING: Trim {trim_cm:.1f}cm exceeds limit {VesselParams.TRIM_LIMIT_CM}cm&#34;
        )

    # IMO/Industry standard compliance checks
    # GM check (simplified - would need actual GM calculation for full compliance)
    # Note: Full GM calculation requires additional hydrostatic data
    pred[&#34;_compliance_checks&#34;] = {
        &#34;draft_within_limits&#34;: (
            VesselParams.MIN_DRAFT
            &lt;= pred[&#34;dfwd_new_m&#34;]
            &lt;= VesselParams.MAX_FWD_DRAFT_OPS
            and pred[&#34;daft_new_m&#34;] &lt;= VesselParams.MAX_AFT_DRAFT_OPS
        ),
        &#34;trim_within_limit&#34;: trim_cm &lt;= VesselParams.TRIM_LIMIT_CM,
        &#34;imo_draft_compliant&#34;: pred[&#34;dfwd_new_m&#34;] &lt;= VesselParams.MAX_FWD_DRAFT_OPS,
    }

    # Tank capacity validation with group balance check
    tank_groups = {}
    for t in self.tanks:
        if t.name in delta:
            new_level = t.current_t + delta[t.name]
            if new_level &gt; t.max_t:
                warnings.append(
                    f&#34;WARNING: Tank {t.name} exceeds max capacity ({new_level:.2f}t &gt; {t.max_t:.2f}t)&#34;
                )
            if new_level &lt; t.min_t:
                warnings.append(
                    f&#34;WARNING: Tank {t.name} below min level ({new_level:.2f}t &lt; {t.min_t:.2f}t)&#34;
                )

            # Group balance tracking
            if t.group:
                if t.group not in tank_groups:
                    tank_groups[t.group] = {&#34;total&#34;: 0.0, &#34;count&#34;: 0}
                tank_groups[t.group][&#34;total&#34;] += new_level
                tank_groups[t.group][&#34;count&#34;] += 1

    # Check group balance
    for group, data in tank_groups.items():
        avg_level = data[&#34;total&#34;] / data[&#34;count&#34;] if data[&#34;count&#34;] &gt; 0 else 0.0
        # Warn if significant imbalance (more than 10% difference from average)
        for t in self.tanks:
            if t.group == group and t.name in delta:
                new_level = t.current_t + delta[t.name]
                if abs(new_level - avg_level) &gt; avg_level * 0.1:
                    warnings.append(
                        f&#34;WARNING: Tank {t.name} in group {group} imbalanced ({new_level:.2f}t vs avg {avg_level:.2f}t)&#34;
                    )

    if warnings:
        pred[&#34;_warnings&#34;] = warnings

    return OptimizationResult(plan_df, pred, delta, True, &#34;Optimal&#34;)</code></pre>
</details>
<div class="desc"><p>Solves the ballast plan using Linear Programming.
Supports 'Target' mode (exact draft) or 'Limit' mode (inequalities).</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.update_tanks"><code class="name flex">
<span>def <span class="ident">update_tanks</span></span>(<span>self, delta: Dict[str, float])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_tanks(self, delta: Dict[str, float]):
    &#34;&#34;&#34;Updates internal tank states based on delta.&#34;&#34;&#34;
    for t in self.tanks:
        if t.name in delta:
            t.current_t = min(max(t.current_t + delta[t.name], t.min_t), t.max_t)</code></pre>
</details>
<div class="desc"><p>Updates internal tank states based on delta.</p></div>
</dd>
</dl>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint"><code class="flex name class">
<span>class <span class="ident">HydroPoint</span></span>
<span>(</span><span>tmean_m: float,<br>tpc_t_per_cm: float,<br>mtc_t_m_per_cm: float,<br>lcf_m: float,<br>lbp_m: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class HydroPoint:
    tmean_m: float
    tpc_t_per_cm: float
    mtc_t_m_per_cm: float
    lcf_m: float
    lbp_m: float</code></pre>
</details>
<div class="desc"><p>HydroPoint(tmean_m: 'float', tpc_t_per_cm: 'float', mtc_t_m_per_cm: 'float', lcf_m: 'float', lbp_m: 'float')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.lbp_m"><code class="name">var <span class="ident">lbp_m</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.lcf_m"><code class="name">var <span class="ident">lcf_m</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.mtc_t_m_per_cm"><code class="name">var <span class="ident">mtc_t_m_per_cm</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.tmean_m"><code class="name">var <span class="ident">tmean_m</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.tpc_t_per_cm"><code class="name">var <span class="ident">tpc_t_per_cm</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel"><code class="flex name class">
<span>class <span class="ident">HydroPointModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HydroPointModel(BaseModel):
    &#34;&#34;&#34;Pydantic model for HydroPoint validation.&#34;&#34;&#34;

    tmean_m: Annotated[float, Field(gt=0, description=&#34;Mean draft in meters&#34;)]
    tpc_t_per_cm: Annotated[float, Field(gt=0, description=&#34;Tons per centimeter&#34;)]
    mtc_t_m_per_cm: Annotated[
        float, Field(gt=0, description=&#34;Moment to change trim&#34;)
    ]
    lcf_m: float = Field(
        description=&#34;Longitudinal center of floatation from midship&#34;
    )
    lbp_m: Annotated[
        float, Field(gt=0, description=&#34;Length between perpendiculars&#34;)
    ]

    @field_validator(&#34;tpc_t_per_cm&#34;, &#34;mtc_t_m_per_cm&#34;, &#34;lbp_m&#34;)
    @classmethod
    def validate_positive(cls, v):
        if v &lt;= 0:
            raise ValueError(f&#34;Value must be positive, got {v}&#34;)
        return v

    def to_hydropoint(self) -&gt; HydroPoint:
        &#34;&#34;&#34;Convert to dataclass.&#34;&#34;&#34;
        return HydroPoint(
            tmean_m=self.tmean_m,
            tpc_t_per_cm=self.tpc_t_per_cm,
            mtc_t_m_per_cm=self.mtc_t_m_per_cm,
            lcf_m=self.lcf_m,
            lbp_m=self.lbp_m,
        )</code></pre>
</details>
<div class="desc"><p>Pydantic model for HydroPoint validation.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.lbp_m"><code class="name">var <span class="ident">lbp_m</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.lcf_m"><code class="name">var <span class="ident">lcf_m</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.mtc_t_m_per_cm"><code class="name">var <span class="ident">mtc_t_m_per_cm</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.tmean_m"><code class="name">var <span class="ident">tmean_m</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.tpc_t_per_cm"><code class="name">var <span class="ident">tpc_t_per_cm</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.validate_positive"><code class="name flex">
<span>def <span class="ident">validate_positive</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.to_hydropoint"><code class="name flex">
<span>def <span class="ident">to_hydropoint</span></span>(<span>self) ‑> 01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_hydropoint(self) -&gt; HydroPoint:
    &#34;&#34;&#34;Convert to dataclass.&#34;&#34;&#34;
    return HydroPoint(
        tmean_m=self.tmean_m,
        tpc_t_per_cm=self.tpc_t_per_cm,
        mtc_t_m_per_cm=self.mtc_t_m_per_cm,
        lcf_m=self.lcf_m,
        lbp_m=self.lbp_m,
    )</code></pre>
</details>
<div class="desc"><p>Convert to dataclass.</p></div>
</dd>
</dl>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult"><code class="flex name class">
<span>class <span class="ident">OptimizationResult</span></span>
<span>(</span><span>plan_df: pd.DataFrame,<br>summary: Dict[str, float],<br>delta: Dict[str, float],<br>success: bool,<br>msg: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class OptimizationResult:
    plan_df: pd.DataFrame
    summary: Dict[str, float]
    delta: Dict[str, float]
    success: bool
    msg: str</code></pre>
</details>
<div class="desc"><p>OptimizationResult(plan_df: 'pd.DataFrame', summary: 'Dict[str, float]', delta: 'Dict[str, float]', success: 'bool', msg: 'str')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.delta"><code class="name">var <span class="ident">delta</span> : Dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.msg"><code class="name">var <span class="ident">msg</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.plan_df"><code class="name">var <span class="ident">plan_df</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.success"><code class="name">var <span class="ident">success</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.summary"><code class="name">var <span class="ident">summary</span> : Dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel"><code class="flex name class">
<span>class <span class="ident">OptimizationResultModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptimizationResultModel(BaseModel):
    &#34;&#34;&#34;Pydantic model for OptimizationResult validation.&#34;&#34;&#34;

    success: bool = Field(description=&#34;Whether optimization succeeded&#34;)
    msg: str = Field(description=&#34;Status message&#34;)
    summary: Dict[str, float] = Field(description=&#34;Summary dictionary&#34;)
    delta: Dict[str, float] = Field(description=&#34;Delta dictionary&#34;)

    class Config:
        arbitrary_types_allowed = True  # Allow pd.DataFrame

    def to_optimization_result(self, plan_df: pd.DataFrame) -&gt; OptimizationResult:
        &#34;&#34;&#34;Convert to dataclass.&#34;&#34;&#34;
        return OptimizationResult(
            plan_df=plan_df,
            summary=self.summary,
            delta=self.delta,
            success=self.success,
            msg=self.msg,
        )</code></pre>
</details>
<div class="desc"><p>Pydantic model for OptimizationResult validation.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.delta"><code class="name">var <span class="ident">delta</span> : Dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.msg"><code class="name">var <span class="ident">msg</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.success"><code class="name">var <span class="ident">success</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.summary"><code class="name">var <span class="ident">summary</span> : Dict[str, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.to_optimization_result"><code class="name flex">
<span>def <span class="ident">to_optimization_result</span></span>(<span>self, plan_df: pd.DataFrame) ‑> 01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_optimization_result(self, plan_df: pd.DataFrame) -&gt; OptimizationResult:
    &#34;&#34;&#34;Convert to dataclass.&#34;&#34;&#34;
    return OptimizationResult(
        plan_df=plan_df,
        summary=self.summary,
        delta=self.delta,
        success=self.success,
        msg=self.msg,
    )</code></pre>
</details>
<div class="desc"><p>Convert to dataclass.</p></div>
</dd>
</dl>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank"><code class="flex name class">
<span>class <span class="ident">Tank</span></span>
<span>(</span><span>name: str,<br>x_from_mid_m: float,<br>current_t: float,<br>min_t: float,<br>max_t: float,<br>mode: str,<br>use_flag: str,<br>pump_rate_tph: float,<br>group: Optional[str],<br>priority_weight: float,<br>density_t_per_m3: float,<br>freeze_flag: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Tank:
    name: str
    x_from_mid_m: float
    current_t: float
    min_t: float
    max_t: float
    mode: str  # FILL_DISCHARGE, FILL_ONLY, DISCHARGE_ONLY, FIXED, BLOCKED
    use_flag: str  # Y/N
    pump_rate_tph: float
    group: Optional[str]
    priority_weight: float
    density_t_per_m3: float
    freeze_flag: str  # Y/N

    @property
    def current_pct(self) -&gt; float:
        return (self.current_t / self.max_t * 100) if self.max_t &gt; 0 else 0

    def bounds_pos_neg(self) -&gt; Tuple[float, float, float, float]:
        &#34;&#34;&#34;Returns bounds for LP variables (pump_in, pump_out)&#34;&#34;&#34;
        mode = (self.mode or &#34;FILL_DISCHARGE&#34;).strip().upper()
        use = (self.use_flag or &#34;N&#34;).strip().upper()
        freeze = (self.freeze_flag or &#34;N&#34;).strip().upper()

        if use != &#34;Y&#34; or mode == &#34;BLOCKED&#34; or freeze == &#34;Y&#34; or mode == &#34;FIXED&#34;:
            return 0.0, 0.0, 0.0, 0.0

        cur, mn, mx = float(self.current_t), float(self.min_t), float(self.max_t)
        max_fill = max(0.0, mx - cur)
        max_dis = max(0.0, cur - mn)

        if mode == &#34;DISCHARGE_ONLY&#34;:
            max_fill = 0.0
        elif mode == &#34;FILL_ONLY&#34;:
            max_dis = 0.0

        # format: (fill_min, fill_max), (dis_min, dis_max)
        return 0.0, max_fill, 0.0, max_dis</code></pre>
</details>
<div class="desc"><p>Tank(name: 'str', x_from_mid_m: 'float', current_t: 'float', min_t: 'float', max_t: 'float', mode: 'str', use_flag: 'str', pump_rate_tph: 'float', group: 'Optional[str]', priority_weight: 'float', density_t_per_m3: 'float', freeze_flag: 'str')</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.current_pct"><code class="name">prop <span class="ident">current_pct</span> : float</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def current_pct(self) -&gt; float:
    return (self.current_t / self.max_t * 100) if self.max_t &gt; 0 else 0</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.current_t"><code class="name">var <span class="ident">current_t</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.density_t_per_m3"><code class="name">var <span class="ident">density_t_per_m3</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.freeze_flag"><code class="name">var <span class="ident">freeze_flag</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.group"><code class="name">var <span class="ident">group</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.max_t"><code class="name">var <span class="ident">max_t</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.min_t"><code class="name">var <span class="ident">min_t</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.mode"><code class="name">var <span class="ident">mode</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.priority_weight"><code class="name">var <span class="ident">priority_weight</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.pump_rate_tph"><code class="name">var <span class="ident">pump_rate_tph</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.use_flag"><code class="name">var <span class="ident">use_flag</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.x_from_mid_m"><code class="name">var <span class="ident">x_from_mid_m</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.bounds_pos_neg"><code class="name flex">
<span>def <span class="ident">bounds_pos_neg</span></span>(<span>self) ‑> Tuple[float, float, float, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounds_pos_neg(self) -&gt; Tuple[float, float, float, float]:
    &#34;&#34;&#34;Returns bounds for LP variables (pump_in, pump_out)&#34;&#34;&#34;
    mode = (self.mode or &#34;FILL_DISCHARGE&#34;).strip().upper()
    use = (self.use_flag or &#34;N&#34;).strip().upper()
    freeze = (self.freeze_flag or &#34;N&#34;).strip().upper()

    if use != &#34;Y&#34; or mode == &#34;BLOCKED&#34; or freeze == &#34;Y&#34; or mode == &#34;FIXED&#34;:
        return 0.0, 0.0, 0.0, 0.0

    cur, mn, mx = float(self.current_t), float(self.min_t), float(self.max_t)
    max_fill = max(0.0, mx - cur)
    max_dis = max(0.0, cur - mn)

    if mode == &#34;DISCHARGE_ONLY&#34;:
        max_fill = 0.0
    elif mode == &#34;FILL_ONLY&#34;:
        max_dis = 0.0

    # format: (fill_min, fill_max), (dis_min, dis_max)
    return 0.0, max_fill, 0.0, max_dis</code></pre>
</details>
<div class="desc"><p>Returns bounds for LP variables (pump_in, pump_out)</p></div>
</dd>
</dl>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel"><code class="flex name class">
<span>class <span class="ident">TankModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TankModel(BaseModel):
    &#34;&#34;&#34;Pydantic model for Tank validation.&#34;&#34;&#34;

    name: str = Field(min_length=1, description=&#34;Tank name&#34;)
    x_from_mid_m: float = Field(description=&#34;Distance from midship in meters&#34;)
    current_t: Annotated[float, Field(ge=0, description=&#34;Current weight in tons&#34;)]
    min_t: Annotated[float, Field(ge=0, description=&#34;Minimum weight in tons&#34;)]
    max_t: Annotated[float, Field(gt=0, description=&#34;Maximum weight in tons&#34;)]
    mode: str = Field(
        default=&#34;FILL_DISCHARGE&#34;,
        description=&#34;Operation mode: FILL_DISCHARGE, FILL_ONLY, DISCHARGE_ONLY, FIXED, BLOCKED&#34;,
    )
    use_flag: str = Field(
        default=&#34;Y&#34;, pattern=&#34;^[YN]$&#34;, description=&#34;Use flag: Y or N&#34;
    )
    pump_rate_tph: Annotated[
        float, Field(gt=0, description=&#34;Pump rate in tons per hour&#34;)
    ]
    group: Optional[str] = Field(default=None, description=&#34;Tank group&#34;)
    priority_weight: Annotated[float, Field(ge=0, description=&#34;Priority weight&#34;)]
    density_t_per_m3: Annotated[
        float, Field(gt=0, description=&#34;Density in tons per cubic meter&#34;)
    ]
    freeze_flag: str = Field(
        default=&#34;N&#34;, pattern=&#34;^[YN]$&#34;, description=&#34;Freeze flag: Y or N&#34;
    )

    @field_validator(&#34;mode&#34;)
    @classmethod
    def validate_mode(cls, v):
        valid_modes = [
            &#34;FILL_DISCHARGE&#34;,
            &#34;FILL_ONLY&#34;,
            &#34;DISCHARGE_ONLY&#34;,
            &#34;FIXED&#34;,
            &#34;BLOCKED&#34;,
        ]
        if v.upper() not in valid_modes:
            raise ValueError(f&#34;Mode must be one of {valid_modes}, got {v}&#34;)
        return v.upper()

    @model_validator(mode=&#34;after&#34;)
    def validate_bounds(self):
        if self.min_t &gt; self.max_t:
            raise ValueError(
                f&#34;min_t ({self.min_t}) must be &lt;= max_t ({self.max_t})&#34;
            )
        if self.current_t &lt; self.min_t or self.current_t &gt; self.max_t:
            raise ValueError(
                f&#34;current_t ({self.current_t}) must be between min_t ({self.min_t}) and max_t ({self.max_t})&#34;
            )
        return self

    def to_tank(self) -&gt; &#34;Tank&#34;:
        &#34;&#34;&#34;Convert to dataclass.&#34;&#34;&#34;
        return Tank(
            name=self.name,
            x_from_mid_m=self.x_from_mid_m,
            current_t=self.current_t,
            min_t=self.min_t,
            max_t=self.max_t,
            mode=self.mode,
            use_flag=self.use_flag,
            pump_rate_tph=self.pump_rate_tph,
            group=self.group,
            priority_weight=self.priority_weight,
            density_t_per_m3=self.density_t_per_m3,
            freeze_flag=self.freeze_flag,
        )</code></pre>
</details>
<div class="desc"><p>Pydantic model for Tank validation.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.current_t"><code class="name">var <span class="ident">current_t</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.density_t_per_m3"><code class="name">var <span class="ident">density_t_per_m3</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.freeze_flag"><code class="name">var <span class="ident">freeze_flag</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.group"><code class="name">var <span class="ident">group</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.max_t"><code class="name">var <span class="ident">max_t</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.min_t"><code class="name">var <span class="ident">min_t</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.mode"><code class="name">var <span class="ident">mode</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.priority_weight"><code class="name">var <span class="ident">priority_weight</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.pump_rate_tph"><code class="name">var <span class="ident">pump_rate_tph</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.use_flag"><code class="name">var <span class="ident">use_flag</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.x_from_mid_m"><code class="name">var <span class="ident">x_from_mid_m</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.validate_mode"><code class="name flex">
<span>def <span class="ident">validate_mode</span></span>(<span>v)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.to_tank"><code class="name flex">
<span>def <span class="ident">to_tank</span></span>(<span>self) ‑> 01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_tank(self) -&gt; &#34;Tank&#34;:
    &#34;&#34;&#34;Convert to dataclass.&#34;&#34;&#34;
    return Tank(
        name=self.name,
        x_from_mid_m=self.x_from_mid_m,
        current_t=self.current_t,
        min_t=self.min_t,
        max_t=self.max_t,
        mode=self.mode,
        use_flag=self.use_flag,
        pump_rate_tph=self.pump_rate_tph,
        group=self.group,
        priority_weight=self.priority_weight,
        density_t_per_m3=self.density_t_per_m3,
        freeze_flag=self.freeze_flag,
    )</code></pre>
</details>
<div class="desc"><p>Convert to dataclass.</p></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.validate_bounds"><code class="name flex">
<span>def <span class="ident">validate_bounds</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@model_validator(mode=&#34;after&#34;)
def validate_bounds(self):
    if self.min_t &gt; self.max_t:
        raise ValueError(
            f&#34;min_t ({self.min_t}) must be &lt;= max_t ({self.max_t})&#34;
        )
    if self.current_t &lt; self.min_t or self.current_t &gt; self.max_t:
        raise ValueError(
            f&#34;current_t ({self.current_t}) must be between min_t ({self.min_t}) and max_t ({self.max_t})&#34;
        )
    return self</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone"><code class="flex name class">
<span>class <span class="ident">TankZone</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TankZone(Enum):
    STERN = &#34;STERN&#34;
    AFT = &#34;AFT&#34;
    MID = &#34;MID&#34;
    FWD = &#34;FWD&#34;
    BOW = &#34;BOW&#34;</code></pre>
</details>
<div class="desc"><p>Create a collection of name/value pairs.</p>
<p>Example enumeration:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class Color(Enum):
...     RED = 1
...     BLUE = 2
...     GREEN = 3
</code></pre>
<p>Access them by:</p>
<ul>
<li>attribute access::</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; Color.RED
&lt;Color.RED: 1&gt;
</code></pre>
<ul>
<li>value lookup:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; Color(1)
&lt;Color.RED: 1&gt;
</code></pre>
<ul>
<li>name lookup:</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; Color['RED']
&lt;Color.RED: 1&gt;
</code></pre>
<p>Enumerations can be iterated over, and know how many members they have:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len(Color)
3
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; list(Color)
[&lt;Color.RED: 1&gt;, &lt;Color.BLUE: 2&gt;, &lt;Color.GREEN: 3&gt;]
</code></pre>
<p>Methods can be added to enumerations, and members can have their own
attributes &ndash; see the documentation for details.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.AFT"><code class="name">var <span class="ident">AFT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.BOW"><code class="name">var <span class="ident">BOW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.FWD"><code class="name">var <span class="ident">FWD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.MID"><code class="name">var <span class="ident">MID</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.STERN"><code class="name">var <span class="ident">STERN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams"><code class="flex name class">
<span>class <span class="ident">VesselParams</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VesselParams:
    &#34;&#34;&#34;Default LCT BUSHRA Parameters (Used if no Hydro table provided)&#34;&#34;&#34;

    LBP = 60.302
    MTC = 34.00  # t*m/cm
    TPC = 8.00  # t/cm
    LCF = 0.76  # m from midship
    D_VESSEL = 3.65  # Molded Depth

    # Operational Limits
    MAX_FWD_DRAFT_OPS = 2.70
    MAX_AFT_DRAFT_OPS = 3.50
    MIN_DRAFT = 1.50
    TRIM_LIMIT_CM = 240.0

    # Defaults
    PUMP_RATE = 50.0  # t/h
    DENSITY = 1.025  # t/m3

    # Safety margins and factors
    SAFETY_MARGIN_DRAFT_CM = 5.0  # 5cm safety margin for draft
    SAFETY_FACTOR_DRAFT = 1.05  # 5% safety factor for draft calculations
    SAFETY_FACTOR_TRIM = 1.05  # 5% safety factor for trim calculations
    MIN_GM_M = 1.5  # Minimum GM requirement

    # Safety margins and factors
    SAFETY_MARGIN_DRAFT_CM = 5.0  # 5cm safety margin for draft
    SAFETY_FACTOR_DRAFT = 1.05  # 5% safety factor for draft calculations
    SAFETY_FACTOR_TRIM = 1.05  # 5% safety factor for trim calculations
    MIN_GM_M = 1.5  # Minimum GM requirement</code></pre>
</details>
<div class="desc"><p>Default LCT BUSHRA Parameters (Used if no Hydro table provided)</p></div>
<h3>Class variables</h3>
<dl>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.DENSITY"><code class="name">var <span class="ident">DENSITY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.D_VESSEL"><code class="name">var <span class="ident">D_VESSEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.LBP"><code class="name">var <span class="ident">LBP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.LCF"><code class="name">var <span class="ident">LCF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MAX_AFT_DRAFT_OPS"><code class="name">var <span class="ident">MAX_AFT_DRAFT_OPS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MAX_FWD_DRAFT_OPS"><code class="name">var <span class="ident">MAX_FWD_DRAFT_OPS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MIN_DRAFT"><code class="name">var <span class="ident">MIN_DRAFT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MIN_GM_M"><code class="name">var <span class="ident">MIN_GM_M</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MTC"><code class="name">var <span class="ident">MTC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.PUMP_RATE"><code class="name">var <span class="ident">PUMP_RATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.SAFETY_FACTOR_DRAFT"><code class="name">var <span class="ident">SAFETY_FACTOR_DRAFT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.SAFETY_FACTOR_TRIM"><code class="name">var <span class="ident">SAFETY_FACTOR_TRIM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.SAFETY_MARGIN_DRAFT_CM"><code class="name">var <span class="ident">SAFETY_MARGIN_DRAFT_CM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.TPC"><code class="name">var <span class="ident">TPC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.TRIM_LIMIT_CM"><code class="name">var <span class="ident">TRIM_LIMIT_CM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="01_EXECUTION_FILES" href="index.html">01_EXECUTION_FILES</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.build_roro_stage_loads" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.build_roro_stage_loads">build_roro_stage_loads</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.build_tank_log" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.build_tank_log">build_tank_log</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.calc_draft_with_lcf" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.calc_draft_with_lcf">calc_draft_with_lcf</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.calc_trim_gate_cm_from_tmean" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.calc_trim_gate_cm_from_tmean">calc_trim_gate_cm_from_tmean</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.calculate_roro_stage_drafts" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.calculate_roro_stage_drafts">calculate_roro_stage_drafts</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.col_idx_to_excel_letter" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.col_idx_to_excel_letter">col_idx_to_excel_letter</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.create_ballasting_sheet" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.create_ballasting_sheet">create_ballasting_sheet</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.export_roro_stages_to_excel" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.export_roro_stages_to_excel">export_roro_stages_to_excel</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.export_to_excel" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.export_to_excel">export_to_excel</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.extend_roro_captain_req" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.extend_roro_captain_req">extend_roro_captain_req</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.extend_roro_structural_opt1" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.extend_roro_structural_opt1">extend_roro_structural_opt1</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.fr_to_x" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.fr_to_x">fr_to_x</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.generate_bwrb_log" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.generate_bwrb_log">generate_bwrb_log</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.get_default_hydro_table" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.get_default_hydro_table">get_default_hydro_table</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.get_default_tanks" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.get_default_tanks">get_default_tanks</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.get_styles" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.get_styles">get_styles</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.gm_2d_bilinear" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.gm_2d_bilinear">gm_2d_bilinear</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.interpolate_hydro_by_tmean" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.interpolate_hydro_by_tmean">interpolate_hydro_by_tmean</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.interpolate_tmean_from_disp" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.interpolate_tmean_from_disp">interpolate_tmean_from_disp</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.load_hydro_table" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.load_hydro_table">load_hydro_table</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.load_stage_table" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.load_stage_table">load_stage_table</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.load_tanks_from_file" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.load_tanks_from_file">load_tanks_from_file</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.optimize_preballast_for_roro" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.optimize_preballast_for_roro">optimize_preballast_for_roro</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.print_summary" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.print_summary">print_summary</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.redistribute_excess_ballast" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.redistribute_excess_ballast">redistribute_excess_ballast</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.run_batch_mode" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.run_batch_mode">run_batch_mode</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.run_interactive_mode" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.run_interactive_mode">run_interactive_mode</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.run_roro_mode" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.run_roro_mode">run_roro_mode</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.validate_and_correct_transfer" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.validate_and_correct_transfer">validate_and_correct_transfer</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.validate_hydro_formula" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.validate_hydro_formula">validate_hydro_formula</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.validate_stage_continuity" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.validate_stage_continuity">validate_stage_continuity</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.x_to_fr" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.x_to_fr">x_to_fr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer">BallastOptimizer</a></code></h4>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.apply_delta_to_tanks" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.apply_delta_to_tanks">apply_delta_to_tanks</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.get_hydro_at_draft" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.get_hydro_at_draft">get_hydro_at_draft</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.iterate_hydro_solve" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.iterate_hydro_solve">iterate_hydro_solve</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.predict_drafts" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.predict_drafts">predict_drafts</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.solve" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.solve">solve</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.update_tanks" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.BallastOptimizer.update_tanks">update_tanks</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint">HydroPoint</a></code></h4>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.lbp_m" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.lbp_m">lbp_m</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.lcf_m" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.lcf_m">lcf_m</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.mtc_t_m_per_cm" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.mtc_t_m_per_cm">mtc_t_m_per_cm</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.tmean_m" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.tmean_m">tmean_m</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.tpc_t_per_cm" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPoint.tpc_t_per_cm">tpc_t_per_cm</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel">HydroPointModel</a></code></h4>
<ul class="two-column">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.lbp_m" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.lbp_m">lbp_m</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.lcf_m" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.lcf_m">lcf_m</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.model_config" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.model_config">model_config</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.mtc_t_m_per_cm" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.mtc_t_m_per_cm">mtc_t_m_per_cm</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.tmean_m" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.tmean_m">tmean_m</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.to_hydropoint" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.to_hydropoint">to_hydropoint</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.tpc_t_per_cm" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.tpc_t_per_cm">tpc_t_per_cm</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.validate_positive" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.HydroPointModel.validate_positive">validate_positive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult">OptimizationResult</a></code></h4>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.delta" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.delta">delta</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.msg" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.msg">msg</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.plan_df" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.plan_df">plan_df</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.success" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.success">success</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.summary" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResult.summary">summary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel">OptimizationResultModel</a></code></h4>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.Config" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.Config">Config</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.delta" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.delta">delta</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.model_config" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.model_config">model_config</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.msg" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.msg">msg</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.success" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.success">success</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.summary" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.summary">summary</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.to_optimization_result" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.OptimizationResultModel.to_optimization_result">to_optimization_result</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank">Tank</a></code></h4>
<ul class="two-column">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.bounds_pos_neg" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.bounds_pos_neg">bounds_pos_neg</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.current_pct" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.current_pct">current_pct</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.current_t" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.current_t">current_t</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.density_t_per_m3" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.density_t_per_m3">density_t_per_m3</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.freeze_flag" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.freeze_flag">freeze_flag</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.group" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.group">group</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.max_t" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.max_t">max_t</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.min_t" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.min_t">min_t</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.mode" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.mode">mode</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.name" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.name">name</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.priority_weight" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.priority_weight">priority_weight</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.pump_rate_tph" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.pump_rate_tph">pump_rate_tph</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.use_flag" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.use_flag">use_flag</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.x_from_mid_m" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.Tank.x_from_mid_m">x_from_mid_m</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel">TankModel</a></code></h4>
<ul class="two-column">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.current_t" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.current_t">current_t</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.density_t_per_m3" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.density_t_per_m3">density_t_per_m3</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.freeze_flag" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.freeze_flag">freeze_flag</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.group" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.group">group</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.max_t" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.max_t">max_t</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.min_t" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.min_t">min_t</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.mode" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.mode">mode</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.model_config" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.model_config">model_config</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.name" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.name">name</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.priority_weight" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.priority_weight">priority_weight</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.pump_rate_tph" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.pump_rate_tph">pump_rate_tph</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.to_tank" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.to_tank">to_tank</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.use_flag" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.use_flag">use_flag</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.validate_bounds" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.validate_bounds">validate_bounds</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.validate_mode" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.validate_mode">validate_mode</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.x_from_mid_m" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankModel.x_from_mid_m">x_from_mid_m</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone">TankZone</a></code></h4>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.AFT" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.AFT">AFT</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.BOW" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.BOW">BOW</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.FWD" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.FWD">FWD</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.MID" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.MID">MID</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.STERN" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.TankZone.STERN">STERN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams">VesselParams</a></code></h4>
<ul class="">
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.DENSITY" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.DENSITY">DENSITY</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.D_VESSEL" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.D_VESSEL">D_VESSEL</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.LBP" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.LBP">LBP</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.LCF" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.LCF">LCF</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MAX_AFT_DRAFT_OPS" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MAX_AFT_DRAFT_OPS">MAX_AFT_DRAFT_OPS</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MAX_FWD_DRAFT_OPS" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MAX_FWD_DRAFT_OPS">MAX_FWD_DRAFT_OPS</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MIN_DRAFT" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MIN_DRAFT">MIN_DRAFT</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MIN_GM_M" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MIN_GM_M">MIN_GM_M</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MTC" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.MTC">MTC</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.PUMP_RATE" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.PUMP_RATE">PUMP_RATE</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.SAFETY_FACTOR_DRAFT" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.SAFETY_FACTOR_DRAFT">SAFETY_FACTOR_DRAFT</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.SAFETY_FACTOR_TRIM" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.SAFETY_FACTOR_TRIM">SAFETY_FACTOR_TRIM</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.SAFETY_MARGIN_DRAFT_CM" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.SAFETY_MARGIN_DRAFT_CM">SAFETY_MARGIN_DRAFT_CM</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.TPC" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.TPC">TPC</a></code></li>
<li><code><a title="01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.TRIM_LIMIT_CM" href="#01_EXECUTION_FILES.Untitled-2_patched_defsplit_v1_1.VesselParams.TRIM_LIMIT_CM">TRIM_LIMIT_CM</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
